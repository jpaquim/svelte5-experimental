import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-ZS7NZCD4.js";

// ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c2 = chars.charCodeAt(i);
        intToChar[i] = c2;
        charToInt[c2] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf(mappings, index);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state, j) {
        let value2 = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c2 = mappings.charCodeAt(pos++);
          integer = charToInt[c2];
          value2 |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value2 & 1;
        value2 >>>= 1;
        if (shouldNegate) {
          value2 = -2147483648 | -value2;
        }
        state[j] += value2;
        return pos;
      }
      function hasMoreVlq(mappings, i, length) {
        if (i >= length)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b2) {
        return a[0] - b2[0];
      }
      function encode3(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon;
          }
          if (line.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 1);
            pos = encodeInteger(buf, pos, state, segment, 2);
            pos = encodeInteger(buf, pos, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state, segment, j) {
        const next2 = segment[j];
        let num = next2 - state[j];
        state[j] = next2;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports2.decode = decode;
      exports2.encode = encode3;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash: hash2,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            case UrlType.Hash:
              url.query = baseUrl.query;
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri);
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri__default["default"](input, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b2) {
        return a[COLUMN] - b2[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key2) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key2 === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key2;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex];
            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array2, index, value2) {
        for (let i = array2.length; i > index; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index] = value2;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = typeof map === "string" ? JSON.parse(map) : map;
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings
        };
        return exports2.presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset: offset2 } = sections[i];
          let sl2 = stopLine;
          let sc2 = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl2 = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl2 === stopLine) {
              sc2 = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl2 < stopLine) {
              sc2 = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset2.line, columnOffset + offset2.column, sl2, sc2);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        if ("sections" in input)
          return recurse(...arguments);
        const map = new TraceMap(input, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = exports2.decodedMappings(map);
        const { resolvedSources, sourcesContent: contents } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      exports2.encodedMappings = void 0;
      exports2.decodedMappings = void 0;
      exports2.traceSegment = void 0;
      exports2.originalPositionFor = void 0;
      exports2.generatedPositionFor = void 0;
      exports2.allGeneratedPositionsFor = void 0;
      exports2.eachMapping = void 0;
      exports2.sourceContentFor = void 0;
      exports2.presortedDecodedMap = void 0;
      exports2.decodedMap = void 0;
      exports2.encodedMap = void 0;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version2;
          this.file = file;
          this.names = names;
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      (() => {
        exports2.encodedMappings = (map) => {
          var _a2;
          return (_a2 = map._encoded) !== null && _a2 !== void 0 ? _a2 : map._encoded = sourcemapCodec.encode(map._decoded);
        };
        exports2.decodedMappings = (map) => {
          return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
        };
        exports2.traceSegment = (map, line, column) => {
          const decoded = exports2.decodedMappings(map);
          if (line >= decoded.length)
            return null;
          const segments = decoded[line];
          const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
          return index === -1 ? null : segments[index];
        };
        exports2.originalPositionFor = (map, { line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const decoded = exports2.decodedMappings(map);
          if (line >= decoded.length)
            return OMapping(null, null, null, null);
          const segments = decoded[line];
          const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
          if (index === -1)
            return OMapping(null, null, null, null);
          const segment = segments[index];
          if (segment.length === 1)
            return OMapping(null, null, null, null);
          const { names, resolvedSources } = map;
          return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
        };
        exports2.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {
          return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
        };
        exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
          return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
        };
        exports2.eachMapping = (map, cb) => {
          const decoded = exports2.decodedMappings(map);
          const { names, resolvedSources } = map;
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generatedLine = i + 1;
              const generatedColumn = seg[0];
              let source = null;
              let originalLine = null;
              let originalColumn = null;
              let name8 = null;
              if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
              }
              if (seg.length === 5)
                name8 = names[seg[4]];
              cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name: name8
              });
            }
          }
        };
        exports2.sourceContentFor = (map, source) => {
          const { sources, resolvedSources, sourcesContent } = map;
          if (sourcesContent == null)
            return null;
          let index = sources.indexOf(source);
          if (index === -1)
            index = resolvedSources.indexOf(source);
          return index === -1 ? null : sourcesContent[index];
        };
        exports2.presortedDecodedMap = (map, mapUrl) => {
          const tracer = new TraceMap(clone(map, []), mapUrl);
          tracer._decoded = map.mappings;
          return tracer;
        };
        exports2.decodedMap = (map) => {
          return clone(map, exports2.decodedMappings(map));
        };
        exports2.encodedMap = (map) => {
          return clone(map, exports2.encodedMappings(map));
        };
        function generatedPosition(map, source, line, column, bias, all) {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const { sources, resolvedSources } = map;
          let sourceIndex = sources.indexOf(source);
          if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
          if (sourceIndex === -1)
            return all ? [] : GMapping(null, null);
          const generated = map._bySources || (map._bySources = buildBySources(exports2.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
          const segments = generated[sourceIndex][line];
          if (segments == null)
            return all ? [] : GMapping(null, null);
          const memo = map._bySourceMemos[sourceIndex];
          if (all)
            return sliceGeneratedPositions(segments, memo, line, column, bias);
          const index = traceSegmentInternal(segments, memo, line, column, bias);
          if (index === -1)
            return GMapping(null, null);
          const segment = segments[index];
          return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
        }
      })();
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings
        };
      }
      function OMapping(source, line, column, name8) {
        return { source, line, column, name: name8 };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.setArray = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.get = void 0;
      exports2.put = void 0;
      exports2.pop = void 0;
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      (() => {
        exports2.get = (strarr, key2) => strarr._indexes[key2];
        exports2.put = (strarr, key2) => {
          const index = exports2.get(strarr, key2);
          if (index !== void 0)
            return index;
          const { array: array2, _indexes: indexes } = strarr;
          return indexes[key2] = array2.push(key2) - 1;
        };
        exports2.pop = (strarr) => {
          const { array: array2, _indexes: indexes } = strarr;
          if (array2.length === 0)
            return;
          const last = array2.pop();
          indexes[last] = void 0;
        };
      })();
      exports2.SetArray = SetArray;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
    })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      exports2.addSegment = void 0;
      exports2.addMapping = void 0;
      exports2.maybeAddSegment = void 0;
      exports2.maybeAddMapping = void 0;
      exports2.setSourceContent = void 0;
      exports2.toDecodedMap = void 0;
      exports2.toEncodedMap = void 0;
      exports2.fromMap = void 0;
      exports2.allMappings = void 0;
      let addSegmentInternal;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
        }
      }
      (() => {
        exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name8, content) => {
          return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name8, content);
        };
        exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name8, content) => {
          return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name8, content);
        };
        exports2.addMapping = (map, mapping) => {
          return addMappingInternal(false, map, mapping);
        };
        exports2.maybeAddMapping = (map, mapping) => {
          return addMappingInternal(true, map, mapping);
        };
        exports2.setSourceContent = (map, source, content) => {
          const { _sources: sources, _sourcesContent: sourcesContent } = map;
          sourcesContent[setArray.put(sources, source)] = content;
        };
        exports2.toDecodedMap = (map) => {
          const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
          removeEmptyFinalLines(mappings);
          return {
            version: 3,
            file: file || void 0,
            names: names.array,
            sourceRoot: sourceRoot || void 0,
            sources: sources.array,
            sourcesContent,
            mappings
          };
        };
        exports2.toEncodedMap = (map) => {
          const decoded = exports2.toDecodedMap(map);
          return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
        };
        exports2.allMappings = (map) => {
          const out = [];
          const { _mappings: mappings, _sources: sources, _names: names } = map;
          for (let i = 0; i < mappings.length; i++) {
            const line = mappings[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generated = { line: i + 1, column: seg[COLUMN] };
              let source = void 0;
              let original = void 0;
              let name8 = void 0;
              if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                if (seg.length === 5)
                  name8 = names.array[seg[NAMES_INDEX]];
              }
              out.push({ generated, source, original, name: name8 });
            }
          }
          return out;
        };
        exports2.fromMap = (input) => {
          const map = new traceMapping.TraceMap(input);
          const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
          putAll(gen._names, map.names);
          putAll(gen._sources, map.sources);
          gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
          gen._mappings = traceMapping.decodedMappings(map);
          return gen;
        };
        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name8, content) => {
          const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
          const line = getLine(mappings, genLine);
          const index = getColumnIndex(line, genColumn);
          if (!source) {
            if (skipable && skipSourceless(line, index))
              return;
            return insert(line, index, [genColumn]);
          }
          const sourcesIndex = setArray.put(sources, source);
          const namesIndex = name8 ? setArray.put(names, name8) : NO_NAME;
          if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
          if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
          }
          return insert(line, index, name8 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
        };
      })();
      function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current2 = line[i];
          if (genColumn >= current2[COLUMN])
            break;
        }
        return index;
      }
      function insert(array2, index, value2) {
        for (let i = array2.length; i > index; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index] = value2;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(strarr, array2) {
        for (let i = 0; i < array2.length; i++)
          setArray.put(strarr, array2[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name: name8, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        const s = source;
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name8, content);
      }
      exports2.GenMapping = GenMapping;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS({
  "../../node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_trace_mapping_umd(), require_gen_mapping_umd()) : typeof define === "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));
    })(exports, function(traceMapping, genMapping) {
      "use strict";
      const SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null);
      const EMPTY_SOURCES = [];
      function SegmentObject(source, line, column, name8, content) {
        return { source, line, column, name: name8, content };
      }
      function Source(map, sources, source, content) {
        return {
          map,
          sources,
          source,
          content
        };
      }
      function MapSource(map, sources) {
        return Source(map, sources, "", null);
      }
      function OriginalSource(source, content) {
        return Source(null, EMPTY_SOURCES, source, content);
      }
      function traceMappings(tree) {
        const gen = new genMapping.GenMapping({ file: tree.map.file });
        const { sources: rootSources, map } = tree;
        const rootNames = map.names;
        const rootMappings = traceMapping.decodedMappings(map);
        for (let i = 0; i < rootMappings.length; i++) {
          const segments = rootMappings[i];
          for (let j = 0; j < segments.length; j++) {
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              const source2 = rootSources[segment[1]];
              traced = originalPositionFor(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (traced == null)
                continue;
            }
            const { column, line, name: name8, content, source } = traced;
            genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name8);
            if (source && content != null)
              genMapping.setSourceContent(gen, source, content);
          }
        }
        return gen;
      }
      function originalPositionFor(source, line, column, name8) {
        if (!source.map) {
          return SegmentObject(source.source, line, column, name8, source.content);
        }
        const segment = traceMapping.traceSegment(source.map, line, column);
        if (segment == null)
          return null;
        if (segment.length === 1)
          return SOURCELESS_MAPPING;
        return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name8);
      }
      function asArray(value2) {
        if (Array.isArray(value2))
          return value2;
        return [value2];
      }
      function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ""));
        const map = maps.pop();
        for (let i = 0; i < maps.length; i++) {
          if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
          }
        }
        let tree = build(map, loader, "", 0);
        for (let i = maps.length - 1; i >= 0; i--) {
          tree = MapSource(maps[i], [tree]);
        }
        return tree;
      }
      function build(map, loader, importer, importerDepth) {
        const { resolvedSources, sourcesContent } = map;
        const depth = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i) => {
          const ctx = {
            importer,
            depth,
            source: sourceFile || "",
            content: void 0
          };
          const sourceMap = loader(ctx.source, ctx);
          const { source, content } = ctx;
          if (sourceMap)
            return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);
          const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
          return OriginalSource(source, sourceContent);
        });
        return MapSource(map, children);
      }
      class SourceMap2 {
        constructor(map, options) {
          const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
          this.version = out.version;
          this.file = out.file;
          this.mappings = out.mappings;
          this.names = out.names;
          this.sourceRoot = out.sourceRoot;
          this.sources = out.sources;
          if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
          }
        }
        toString() {
          return JSON.stringify(this);
        }
      }
      function remapping2(input, loader, options) {
        const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap2(traceMappings(tree), opts);
      }
      return remapping2;
    });
  }
});

// ../../node_modules/.pnpm/acorn@8.10.0/node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name8, prec) {
  return new TokenType(name8, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name8, options) {
  if (options === void 0)
    options = {};
  options.keyword = name8;
  return keywords[name8] = new TokenType(name8, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next2 = code.charCodeAt(i);
    if (isNewLine(next2)) {
      return i < end - 1 && next2 === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty2 = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty2.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array2) {
  return function(block2, text2, start, end, startLoc, endLoc) {
    var comment = {
      type: block2 ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved2 = "";
  if (options.allowReserved !== true) {
    reserved2 = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved2 += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved2);
  var reservedStrict = (reserved2 ? reserved2 + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name8) {
  return this.type === types$1.name && this.value === name8 && !this.containsEsc;
};
pp$9.eatContextual = function(name8) {
  if (!this.isContextual(name8)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name8) {
  if (!this.eatContextual(name8)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt2 = this.parseStatement(null, true, exports);
    node2.body.push(stmt2);
  }
  if (this.inModule) {
    for (var i = 0, list2 = Object.keys(this.undefinedExports); i < list2.length; i += 1) {
      var name8 = list2[i];
      this.raiseRecoverable(this.undefinedExports[name8].start, "Export '" + name8 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node2.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node2, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init2);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node2, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node2 === void 0)
    node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node2.body.push(stmt2);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init2) {
  node2.init = init2;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init2;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node2.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node2.body.push(stmt2);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name8 = element.key.name;
  var curr = privateNameMap[name8];
  var next2 = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next2 = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name8] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name8] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name8) {
  var computed = node2.computed;
  var key2 = node2.key;
  return !computed && (key2.type === "Identifier" && key2.name === name8 || key2.type === "Literal" && key2.value === name8);
}
pp$8.parseExportAllDeclaration = function(node2, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node2.exported = this.parseModuleExportName();
      this.checkExport(exports, node2.exported, this.lastTokStart);
    } else {
      node2.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node2.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node2, "ExportAllDeclaration");
};
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node2, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node2.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseExportDeclaration(node2);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
    } else {
      for (var i = 0, list2 = node2.specifiers; i < list2.length; i += 1) {
        var spec = list2[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node2) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration2 = this.parseMaybeAssign();
    this.semicolon();
    return declaration2;
  }
};
pp$8.checkExport = function(exports, name8, pos) {
  if (!exports) {
    return;
  }
  if (typeof name8 !== "string") {
    name8 = name8.type === "Identifier" ? name8.name : name8.value;
  }
  if (hasOwn(exports, name8)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name8 + "'");
  }
  exports[name8] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list2 = pat.properties; i < list2.length; i += 1) {
      var prop2 = list2[i];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list2 = decls; i < list2.length; i += 1) {
    var decl = list2[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node2 = this.startNode();
  node2.local = this.parseModuleExportName();
  node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
  this.checkExport(
    exports,
    node2.exported,
    node2.exported.start
  );
  return this.finishNode(node2, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node2 = this.startNode();
  node2.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node2.local = this.parseIdent();
  } else {
    this.checkUnreserved(node2.imported);
    node2.local = node2.imported;
  }
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node2 = this.startNode();
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node2 = this.startNode();
  this.next();
  this.expectContextual("as");
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list2 = node2.properties; i < list2.length; i += 1) {
          var prop2 = list2[i];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest2 = this.parseRestBinding();
      this.parseBindingListItem(rest2);
      elts.push(rest2);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list2 = expr.properties; i < list2.length; i += 1) {
        var prop2 = list2[i];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update2, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update2 = type.updateContext) {
    update2.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key2 = prop2.key;
  var name8;
  switch (key2.type) {
    case "Identifier":
      name8 = key2.name;
      break;
    case "Literal":
      name8 = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name8 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name8 = "$" + name8;
  var other = propHash[name8];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name8] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node2.left = left;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op2 = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op2, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op2, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.operator = op2;
  node2.right = right;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update2 = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update2, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update2) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update2 ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional;
    }
    base = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value2 = this.value;
      node2 = this.parseLiteral(value2.value);
      node2.regex = { pattern: value2.pattern, flags: value2.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node2);
  } else if (this.type === types$1.dot) {
    node2.meta = meta;
    return this.parseImportMeta(node2);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node2 = this.startNode();
  node2.value = value2;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node2.meta = meta;
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop2);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parseGetterSetter = function(prop2) {
  prop2.kind = prop2.key.name;
  this.parsePropertyName(prop2);
  prop2.value = this.parseMethod(false);
  var paramCount = prop2.kind === "get" ? 0 : 1;
  if (prop2.value.params.length !== paramCount) {
    var start = prop2.value.start;
    if (prop2.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.kind = "init";
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop2);
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop2.kind = "init";
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list2 = params; i < list2.length; i += 1) {
    var param = list2[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list2 = node2.params; i < list2.length; i += 1) {
    var param = list2[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name8 = ref2.name;
  if (this.inGenerator && name8 === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name8 === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name8 === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name8 === "arguments" || name8 === "await")) {
    this.raise(start, "Cannot use " + name8 + " in class static initialization block");
  }
  if (this.keywords.test(name8)) {
    this.raise(start, "Unexpected keyword '" + name8 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re2.test(name8)) {
    if (!this.inAsync && name8 === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name8 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node2 = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parseIdentNode = function() {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
    }
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name8, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name8) > -1 || scope.functions.indexOf(name8) > -1 || scope.var.indexOf(name8) > -1;
    scope.lexical.push(name8);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name8];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name8);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name8) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name8) > -1 || scope$2.var.indexOf(name8) > -1;
    }
    scope$2.functions.push(name8);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name8) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name8) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name8) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name8);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name8];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name8 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node2, type, pos, loc) {
  node2.type = type;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type) {
  return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type, pos, loc) {
  return finishNodeAt.call(this, node2, type, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node(this, node2.start, this.startLoc);
  for (var prop2 in node2) {
    newNode[prop2] = node2[prop2];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d2 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (i = 0, list2 = [9, 10, 11, 12, 13, 14]; i < list2.length; i += 1) {
  ecmaVersion = list2[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list2;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l) {
    return c2;
  }
  var next2 = s.charCodeAt(i + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c2 << 10) + next2 - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c2 = s.charCodeAt(i), next2;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l || (next2 = s.charCodeAt(i + 1)) < 56320 || next2 > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch2) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0)
    forceU = false;
  var pos = this.pos;
  for (var i = 0, list2 = chs; i < list2.length; i += 1) {
    var ch2 = list2[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch2) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v2 = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v2 = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v2) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list2 = state.backReferenceNames; i < list2.length; i += 1) {
    var name8 = list2[i];
    if (state.groupNames.indexOf(name8) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch2 = state.current();
  if (isSyntaxCharacter(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch2) {
  return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch2 = 0;
  while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch2 = state.current();
  if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch2) {
  return isIdentifierStart(ch2, true) || ch2 === 36 || ch2 === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch2) {
  return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch2 = state.current();
  if (ch2 === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch2 === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch2 === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch2 === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch2 === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch2 = state.current();
  if (isControlLetter(ch2)) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch2) {
  return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch2) {
  return ch2 >= 0 && ch2 <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch2 = state.current();
  if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch2 = state.current();
  if (ch2 >= 49 && ch2 <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
      state.advance();
    } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch2 = state.current();
  if (isCharacterClassEscape(ch2)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch2 === 80) || ch2 === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch2) {
  return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name8 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name8, value2);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name8, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name8)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name8].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch2) {
  return isControlLetter(ch2) || ch2 === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch2) {
  return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch2 = state.current();
  if (ch2 !== 93) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch2 = state.current();
  if (ch2 < 0 || ch2 === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch2)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch2)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch2;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch2) {
  return ch2 === 33 || ch2 >= 35 && ch2 <= 38 || ch2 >= 42 && ch2 <= 44 || ch2 === 46 || ch2 >= 58 && ch2 <= 64 || ch2 === 94 || ch2 === 96 || ch2 === 126;
}
function isClassSetSyntaxCharacter(ch2) {
  return ch2 === 40 || ch2 === 41 || ch2 === 45 || ch2 === 47 || ch2 >= 91 && ch2 <= 93 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch2 = state.current();
  if (isClassSetReservedPunctuator(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch2) {
  return ch2 === 33 || ch2 === 35 || ch2 === 37 || ch2 === 38 || ch2 === 44 || ch2 === 45 || ch2 >= 58 && ch2 <= 62 || ch2 === 64 || ch2 === 96 || ch2 === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch2 = state.current();
  if (isDecimalDigit(ch2) || ch2 === 95) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch2 = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch2 = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
}
function hexToInt(ch2) {
  if (ch2 >= 65 && ch2 <= 70) {
    return 10 + (ch2 - 65);
  }
  if (ch2 >= 97 && ch2 <= 102) {
    return 10 + (ch2 - 97);
  }
  return ch2 - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch2 = state.current();
  if (isOctalDigit(ch2)) {
    state.lastIntValue = ch2 - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch2 = state.current();
    if (!isHexDigit(ch2)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code : (code << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch2 = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch2)) {
    ch2 = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch2 = this.input.charCodeAt(this.pos);
      switch (ch2) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch2 = this.input.charAt(this.pos);
    if (lineBreak.test(ch2)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch2 === "[") {
        inClass = true;
      } else if (ch2 === "]" && inClass) {
        inClass = false;
      } else if (ch2 === "/" && !inClass) {
        break;
      }
      escaped = ch2 === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch2 = this.input.charCodeAt(this.pos), code;
  if (ch2 === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === quote) {
      break;
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch2 === 8232 || ch2 === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch2)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch2 === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch2)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch2) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch2);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch2 = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch2) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch2 >= 48 && ch2 <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch2 = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch2)) {
        return "";
      }
      return String.fromCharCode(ch2);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch2 = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch2, astral)) {
      this.pos += ch2 <= 65535 ? 1 : 2;
    } else if (ch2 === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.10.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}

// src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]*/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]*$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_whitespaces_strict = /[ \t\n\r\f]+/g;
var regex_not_newline_characters = /[^\n]/g;
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

// src/compiler/phases/1-parse/utils/extract_svelte_ignore.ts
var regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
function extract_svelte_ignore(text2) {
  const match = regex_svelte_ignore.exec(text2);
  return match ? match[1].split(regex_whitespace).map((x2) => x2.trim()).filter(Boolean) : [];
}

// src/compiler/phases/1-parse/utils/fuzzymatch.ts
function fuzzymatch(name8, names) {
  const set2 = new FuzzySet(names);
  const matches2 = set2.get(name8);
  return matches2 && matches2[0][0] > 0.7 ? matches2[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null)
    return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  if (str1.length > str2.length) {
    return 1 - distance / str1.length;
  } else {
    return 1 - distance / str2.length;
  }
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev = 0;
  let value2 = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value2 = prev;
        } else {
          value2 = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value2 = i + j;
      }
      prev = current2[j];
      current2[j] = value2;
    }
  }
  return current2.pop();
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value2, gram_size = 2) {
  const simplified = "-" + value2.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value2 += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value2, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value2, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b2) {
  return b2[0] - a[0];
}
var FuzzySet = class {
  exact_set = {};
  match_dict = {};
  items = {};
  constructor(arr) {
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  add(value2) {
    const normalized_value = value2.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value2, i);
    }
  }
  _add(value2, gram_size) {
    const normalized_value = value2.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value2;
  }
  get(value2) {
    const normalized_value = value2.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return [[1, result]];
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value2, gram_size);
      if (results)
        return results;
    }
    return null;
  }
  __get(value2, gram_size) {
    const normalized_value = value2.toLowerCase();
    const matches2 = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches2) {
            matches2[index] += gram_count * other_gram_count;
          } else {
            matches2[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches2) {
      match_score = matches2[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// src/compiler/phases/1-parse/utils/names.ts
var reserved = [
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
];
var void_element_names = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name8) {
  return void_element_names.includes(name8) || name8.toLowerCase() === "!doctype";
}

// src/compiler/phases/1-parse/acorn.ts
var parse4 = (source) => parse3(source, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});
var parse_expression_at = (source, index) => parseExpressionAt2(source, index, {
  sourceType: "module",
  ecmaVersion: 13,
  locations: true
});

// src/compiler/errors.js
function list(items, conjunction = "or") {
  if (items.length === 1)
    return items[0];
  return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
}
var internal = {
  /** @param {string} message */
  TODO: (message) => `TODO ${message}`,
  /** @param {string} message */
  INTERNAL: (message) => `Internal compiler error: ${message}. Please report this to https://github.com/sveltejs/svelte/issues`
};
var parse5 = {
  /** @param {string} name */
  "unclosed-element": (name8) => `<${name8}> was left open`,
  "unclosed-block": () => `block was left open`,
  "unexpected-block-close": () => `Unexpected block closing tag`,
  "unexpected-eof": () => `Unexpected end of input`,
  /** @param {string} message */
  "js-parse-error": (message) => message,
  /** @param {string} token */
  "expected-token": (token) => `Expected token ${token}`,
  /** @param {string} word */
  "unexpected-reserved-word": (word) => `'${word}' is a reserved word in JavaScript and cannot be used here`,
  "missing-whitespace": () => `Expected whitespace`,
  "expected-pattern": () => `Expected identifier or destructure pattern`,
  "invalid-script-context": () => `If the context attribute is supplied, its value must be "module"`,
  "invalid-elseif": () => `'elseif' should be 'else if'`,
  /**
   * @param {string} child
   * @param {string} parent
   */
  "invalid-block-parent": (child, parent) => `Expected to close ${parent} before seeing ${child} block`,
  /**
   * @param {string} child
   * @param {string} parent
   */
  "invalid-block-missing-parent": (child, parent) => `${child} block must be a child of ${parent}`,
  "expected-block-type": () => `Expected 'if', 'each', 'await' or 'key'`,
  "expected-identifier": () => `Expected an identifier`,
  "invalid-debug": () => `{@debug ...} arguments must be identifiers, not arbitrary expressions`,
  "invalid-const": () => `{@const ...} must be an assignment`,
  /**
   * @param {string} location
   * @param {string} name
   */
  "invalid-block-placement": (location, name8) => `{#${name8} ...} block cannot be ${location}`,
  /**
   * @param {string} location
   * @param {string} name
   */
  "invalid-tag-placement": (location, name8) => `{@${name8} ...} tag cannot be ${location}`,
  "missing-attribute-value": () => `Expected attribute value`,
  /** @param {string} delimiter */
  "unclosed-attribute-value": (delimiter) => `Expected closing ${delimiter} character`,
  "invalid-directive-value": () => `Directive value must be a JavaScript expression enclosed in curly braces`,
  /** @param {string} type */
  "empty-directive-name": (type) => `${type} name cannot be empty`,
  /** @param {string} name */
  "invalid-closing-tag": (name8) => `</${name8}> attempted to close an element that was not open`,
  /**
   * @param {string} name
   * @param {string} reason
   */
  "invalid-closing-tag-after-autoclose": (name8, reason) => `</${name8}> attempted to close element that was already automatically closed by <${reason}>`
};
var css = {
  /** @param {string} message */
  "css-parse-error": (message) => message,
  "invalid-css-empty-declaration": () => `Declaration cannot be empty`,
  "invalid-css-global-placement": () => `:global(...) can be at the start or end of a selector sequence, but not in the middle`,
  "invalid-css-global-selector": () => `:global(...) must contain exactly one selector`,
  "invalid-css-global-selector-list": () => `:global(...) cannot be used to modify a selector, or be modified by another selector`,
  "invalid-css-selector": () => `Invalid selector`
};
var special_elements = {
  "invalid-svelte-option-attribute": () => `<svelte:options> can only receive static attributes`,
  "invalid-svelte-option-namespace": () => `Unsupported <svelte:option> value for "namespace". Valid values are "html" or "svg".`,
  "invalid-svelte-fragment-attribute": () => `<svelte:fragment> can only have a slot attribute and (optionall) a let: directive`,
  "invalid-svelte-fragment-slot": () => `<svelte:fragment> slot attribute must have a static value`,
  /** @param {string} name */
  "invalid-svelte-element-placement": (name8) => `<${name8}> tags cannot be inside elements or blocks`,
  /** @param {string} name */
  "duplicate-svelte-element": (name8) => `A component can only have one <${name8}> element`,
  "invalid-self-placement": () => `<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components`,
  "missing-svelte-element-definition": () => `<svelte:element> must have a 'this' attribute`,
  "missing-svelte-component-definition": () => `<svelte:component> must have a 'this' attribute`,
  "invalid-svelte-element-definition": () => `Invalid element definition \u2014 must be an {expression}`,
  "invalid-svelte-component-definition": () => `Invalid component definition \u2014 must be an {expression}`,
  /**
   * @param {string[]} tags
   * @param {string | null} match
   */
  "invalid-svelte-tag": (tags, match) => `Valid <svelte:...> tag names are ${list(tags)}${match ? " (did you mean " + match + "?)" : ""}`
};
var runes = {
  "invalid-legacy-props": () => `Cannot use $$props in runes mode`,
  "invalid-legacy-rest-props": () => `Cannot use $$restProps in runes mode`,
  "invalid-legacy-reactive-statement": () => `$: is not allowed in runes mode, use $derived or $effect instead`,
  "invalid-legacy-export": () => `Cannot use \`export let\` in runes mode \u2014 use $props instead`,
  /** @param {string} rune */
  "invalid-rune-usage": (rune) => `Cannot use ${rune} rune in non-runes mode`,
  /** @param {string} rune */
  "invalid-rune-export": (rune) => `Cannot export value created with ${rune}`,
  "invalid-props-id": () => `$props() can only be used with an object destructuring pattern`,
  "invalid-props-pattern": () => `$props() assignment must not contain nested properties or computed keys`,
  "invalid-props-location": () => `$props() can only be used at the top level of components as a variable declaration initializer`,
  "invalid-derived-location": () => `$derived() can only be used as a variable declaration initializer`,
  "invalid-state-location": () => `$state() can only be used as a variable declaration initializer`,
  "invalid-effect-location": () => `$effect() can only be used as an expression statement`,
  "invalid-const-assignment": () => `Invalid assignment to const`,
  "invalid-derived-assignment": () => `Invalid assignment to derived state`,
  /**
   * @param {string} rune
   * @param {number[]} args
   */
  "invalid-rune-args-length": (rune, args) => `${rune} can only be called with ${list(args, "or")} ${args.length === 1 && args[0] === 1 ? "argument" : "arguments"}`
};
var elements = {
  "invalid-textarea-content": () => `A <textarea> can have either a value attribute or (equivalently) child content, but not both`,
  "invalid-void-content": () => `Void elements cannot have children or closing tags`,
  /** @param {string} name */
  "invalid-element-content": (name8) => `<${name8}> cannot have children`,
  "invalid-tag-name": () => "Expected valid tag name",
  /**
   * @param {string} node
   * @param {string} parent
   */
  "invalid-node-placement": (node2, parent) => `${node2} is invalid inside <${parent}>`
};
var components = {
  "invalid-component-directive": () => `Directive is not valid on components`
};
var attributes = {
  "empty-attribute-shorthand": () => `Attribute shorthand cannot be empty`,
  "duplicate-attribute": () => `Attributes need to be unique`
};
var slots = {
  "invalid-slot-element-attribute": () => `<slot> can only receive attributes, not directives`,
  "invalid-slot-attribute": () => `slot attribute must be a static value`,
  "invalid-slot-name": () => `slot attribute must be a static value`,
  "invalid-slot-placement": () => `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element`
};
var bindings = {
  "invalid-binding-expression": () => `Can only bind to an Identifier or MemberExpression`,
  "invalid-binding-value": () => `Can only bind to state or props`
};
var variables = {
  "illegal-global": (
    /** @param {string} name */
    (name8) => `${name8} is an illegal variable name`
  )
};
var errors = {
  ...internal,
  ...parse5,
  ...css,
  ...special_elements,
  ...runes,
  ...elements,
  ...components,
  ...attributes,
  ...slots,
  ...bindings,
  ...variables
  // /**
  //  * @param {string} binding
  //  * @param {string} elements
  //  */
  // 'invalid-binding-element': (binding, elements) =>
  // 	`'${binding}' binding can only be used with ${elements}`,
  // // invalid_binding_on: /**
  // //  * @param {string} binding
  // //  * @param {string} element
  // //  * @param {string} [post]
  // //  */ (binding, element, post) => ({
  // // 	code: 'invalid-binding',
  // // 	message: `'${binding}' is not a valid binding on ${element}` + (post || '')
  // // }),
  // /**
  //  * @param {'checked' | 'indeterminate'} binding
  //  * @param {boolean} is_radio
  //  */
  // 'invalid-binding-no-checkbox': (binding, is_radio) =>
  // 	`'${binding}' binding can only be used with <input type="checkbox">` +
  // 	(is_radio ? '  for <input type="radio">, use \'group\' binding' : ''),
  // /** @param {string} binding */
  // 'invalid-binding': (binding) => `'${binding}' is not a valid binding`,
  // /** @param {string[]} parts */
  // 'invalid-binding-window': (parts) =>
  // 	`Bindings on <svelte:window> must be to top-level properties, e.g. '${
  // 		parts[parts.length - 1]
  // 	}' rather than '${parts.join('.')}'`,
  // 'invalid-binding-let': () => 'Cannot bind to a variable declared with the let: directive',
  // 'invalid-binding-await': () =>
  // 	'Cannot bind to a variable declared with {#await ... then} or {:catch} blocks',
  // 'invalid-binding-const': () => 'Cannot bind to a variable declared with {@const ...}',
  // 'invalid-binding-readonly': () => 'Cannot bind to a variable which is not writable'
  // binding_undeclared: /** @param {string} name */ (name) => ({
  // 	code: 'binding-undeclared',
  // 	message: `${name} is not declared`
  // }),
  // invalid_type: {
  // 	code: 'invalid-type',
  // 	message: "'type' attribute cannot be dynamic if input uses two-way binding"
  // },
  // missing_type: {
  // 	code: 'missing-type',
  // 	message: "'type' attribute must be specified"
  // },
  // dynamic_multiple_attribute: {
  // 	code: 'dynamic-multiple-attribute',
  // 	message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
  // },
  // missing_contenteditable_attribute: {
  // 	code: 'missing-contenteditable-attribute',
  // 	message:
  // 		"'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings"
  // },
  // dynamic_contenteditable_attribute: {
  // 	code: 'dynamic-contenteditable-attribute',
  // 	message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
  // },
  // invalid_event_modifier_combination: /**
  //  * @param {string} modifier1
  //  * @param {string} modifier2
  //  */ (modifier1, modifier2) => ({
  // 	code: 'invalid-event-modifier',
  // 	message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
  // }),
  // invalid_event_modifier_legacy: /** @param {string} modifier */ (modifier) => ({
  // 	code: 'invalid-event-modifier',
  // 	message: `The '${modifier}' modifier cannot be used in legacy mode`
  // }),
  // invalid_event_modifier: /** @param {string} valid */ (valid) => ({
  // 	code: 'invalid-event-modifier',
  // 	message: `Valid event modifiers are ${valid}`
  // }),
  // invalid_event_modifier_component: {
  // 	code: 'invalid-event-modifier',
  // 	message: "Event modifiers other than 'once' can only be used on DOM elements"
  // },
  // textarea_duplicate_value: {
  // 	code: 'textarea-duplicate-value',
  // 	message:
  // 		'A <textarea> can have either a value attribute or (equivalently) child content, but not both'
  // },
  // illegal_attribute: /** @param {string} name */ (name) => ({
  // 	code: 'illegal-attribute',
  // 	message: `'${name}' is not a valid attribute name`
  // }),
  // invalid_slot_attribute: {
  // 	code: 'invalid-slot-attribute',
  // 	message: 'slot attribute cannot have a dynamic value'
  // },
  // duplicate_slot_attribute: /** @param {string} name */ (name) => ({
  // 	code: 'duplicate-slot-attribute',
  // 	message: `Duplicate '${name}' slot`
  // }),
  // invalid_slotted_content: {
  // 	code: 'invalid-slotted-content',
  // 	message:
  // 		"Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
  // },
  // invalid_attribute_head: {
  // 	code: 'invalid-attribute',
  // 	message: '<svelte:head> should not have any attributes or directives'
  // },
  // invalid_action: {
  // 	code: 'invalid-action',
  // 	message: 'Actions can only be applied to DOM elements, not components'
  // },
  // invalid_animation: {
  // 	code: 'invalid-animation',
  // 	message: 'Animations can only be applied to DOM elements, not components'
  // },
  // invalid_class: {
  // 	code: 'invalid-class',
  // 	message: 'Classes can only be applied to DOM elements, not components'
  // },
  // invalid_transition: {
  // 	code: 'invalid-transition',
  // 	message: 'Transitions can only be applied to DOM elements, not components'
  // },
  // invalid_let: {
  // 	code: 'invalid-let',
  // 	message: 'let directive value must be an identifier or an object/array pattern'
  // },
  // invalid_slot_directive: {
  // 	code: 'invalid-slot-directive',
  // 	message: '<slot> cannot have directives'
  // },
  // dynamic_slot_name: {
  // 	code: 'dynamic-slot-name',
  // 	message: '<slot> name cannot be dynamic'
  // },
  // invalid_slot_name: {
  // 	code: 'invalid-slot-name',
  // 	message: 'default is a reserved word  it cannot be used as a slot name'
  // },
  // invalid_slot_attribute_value_missing: {
  // 	code: 'invalid-slot-attribute',
  // 	message: 'slot attribute value is missing'
  // },
  // invalid_slotted_content_fragment: {
  // 	code: 'invalid-slotted-content',
  // 	message: '<svelte:fragment> must be a child of a component'
  // },
  // illegal_attribute_title: {
  // 	code: 'illegal-attribute',
  // 	message: '<title> cannot have attributes'
  // },
  // illegal_structure_title: {
  // 	code: 'illegal-structure',
  // 	message: '<title> can only contain text and {tags}'
  // },
  // duplicate_transition: /**
  //  * @param {string} directive
  //  * @param {string} parent_directive
  //  */ (directive, parent_directive) => {
  // 	/** @param {string} _directive */
  // 	function describe(_directive) {
  // 		return _directive === 'transition' ? "a 'transition'" : `an '${_directive}'`;
  // 	}
  // 	const message =
  // 		directive === parent_directive
  // 			? `An element can only have one '${directive}' directive`
  // 			: `An element cannot have both ${describe(parent_directive)} directive and ${describe(
  // 					directive
  // 			  )} directive`;
  // 	return {
  // 		code: 'duplicate-transition',
  // 		message
  // 	};
  // },
  // contextual_store: {
  // 	code: 'contextual-store',
  // 	message:
  // 		'Stores must be declared at the top level of the component (this may change in a future version of Svelte)'
  // },
  // default_export: {
  // 	code: 'default-export',
  // 	message: 'A component cannot have a default export'
  // },
  // illegal_declaration: {
  // 	code: 'illegal-declaration',
  // 	message: 'The $ prefix is reserved, and cannot be used for variable and import names'
  // },
  // illegal_subscription: {
  // 	code: 'illegal-subscription',
  // 	message: 'Cannot reference store value inside <script context="module">'
  // },
  // illegal_global: /** @param {string} name */ (name) => ({
  // 	code: 'illegal-global',
  // 	message: `${name} is an illegal variable name`
  // }),
  // illegal_variable_declaration: {
  // 	code: 'illegal-variable-declaration',
  // 	message: 'Cannot declare same variable name which is imported inside <script context="module">'
  // },
  // cyclical_reactive_declaration: /** @param {string[]} cycle */ (cycle) => ({
  // 	code: 'cyclical-reactive-declaration',
  // 	message: `Cyclical dependency detected: ${cycle.join('  ')}`
  // }),
  // invalid_tag_property: {
  // 	code: 'invalid-tag-property',
  // 	message: "tag name must be two or more words joined by the '-' character"
  // },
  // invalid_customElement_attribute: {
  // 	code: 'invalid-customElement-attribute',
  // 	message:
  // 		"'customElement' must be a string literal defining a valid custom element name or an object of the form " +
  // 		"{ tag: string; shadow?: 'open' | 'none'; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }"
  // },
  // invalid_tag_attribute: {
  // 	code: 'invalid-tag-attribute',
  // 	message: "'tag' must be a string literal"
  // },
  // invalid_shadow_attribute: {
  // 	code: 'invalid-shadow-attribute',
  // 	message: "'shadow' must be either 'open' or 'none'"
  // },
  // invalid_props_attribute: {
  // 	code: 'invalid-props-attribute',
  // 	message:
  // 		"'props' must be a statically analyzable object literal of the form " +
  // 		"'{ [key: string]: { attribute?: string; reflect?: boolean; type?: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object' }'"
  // },
  // invalid_namespace_property: /**
  //  * @param {string} namespace
  //  * @param {string} [suggestion]
  //  */ (namespace, suggestion) => ({
  // 	code: 'invalid-namespace-property',
  // 	message:
  // 		`Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : '')
  // }),
  // invalid_namespace_attribute: {
  // 	code: 'invalid-namespace-attribute',
  // 	message: "The 'namespace' attribute must be a string literal representing a valid namespace"
  // },
  // invalid_attribute_value: /** @param {string} name */ (name) => ({
  // 	code: `invalid-${name}-value`,
  // 	message: `${name} attribute must be true or false`
  // }),
  // invalid_options_attribute_unknown: /** @param {string} name */ (name) => ({
  // 	code: 'invalid-options-attribute',
  // 	message: `<svelte:options> unknown attribute '${name}'`
  // }),
  // invalid_options_attribute: {
  // 	code: 'invalid-options-attribute',
  // 	message:
  // 		"<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
  // },
  // css_invalid_global: {
  // 	code: 'css-invalid-global',
  // 	message: ':global(...) can be at the start or end of a selector sequence, but not in the middle'
  // },
  // css_invalid_global_selector: {
  // 	code: 'css-invalid-global-selector',
  // 	message: ':global(...) must contain a single selector'
  // },
  // css_invalid_global_selector_position: {
  // 	code: 'css-invalid-global-selector-position',
  // 	message:
  // 		':global(...) not at the start of a selector sequence should not contain type or universal selectors'
  // },
  // css_invalid_selector: /** @param {string} selector */ (selector) => ({
  // 	code: 'css-invalid-selector',
  // 	message: `Invalid selector "${selector}"`
  // }),
  // duplicate_animation: {
  // 	code: 'duplicate-animation',
  // 	message: "An element can only have one 'animate' directive"
  // },
  // invalid_animation_immediate: {
  // 	code: 'invalid-animation',
  // 	message:
  // 		'An element that uses the animate directive must be the immediate child of a keyed each block'
  // },
  // invalid_animation_key: {
  // 	code: 'invalid-animation',
  // 	message:
  // 		'An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?'
  // },
  // invalid_animation_sole: {
  // 	code: 'invalid-animation',
  // 	message:
  // 		'An element that uses the animate directive must be the sole child of a keyed each block'
  // },
  // invalid_animation_dynamic_element: {
  // 	code: 'invalid-animation',
  // 	message: '<svelte:element> cannot have a animate directive'
  // },
  // invalid_directive_value: {
  // 	code: 'invalid-directive-value',
  // 	message:
  // 		'Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)'
  // },
  // invalid_const_placement: {
  // 	code: 'invalid-const-placement',
  // 	message:
  // 		'{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>'
  // },
  // invalid_const_declaration: /** @param {string} name */ (name) => ({
  // 	code: 'invalid-const-declaration',
  // 	message: `'${name}' has already been declared`
  // }),
  // invalid_const_update: /** @param {string} name */ (name) => ({
  // 	code: 'invalid-const-update',
  // 	message: `'${name}' is declared using {@const ...} and is read-only`
  // }),
  // cyclical_const_tags: /** @param {string[]} cycle */ (cycle) => ({
  // 	code: 'cyclical-const-tags',
  // 	message: `Cyclical dependency detected: ${cycle.join('  ')}`
  // }),
  // invalid_component_style_directive: {
  // 	code: 'invalid-component-style-directive',
  // 	message: 'Style directives cannot be used on components'
  // },
  // invalid_var_declaration: {
  // 	code: 'invalid_var_declaration',
  // 	message: '"var" scope should not extend outside the reactive block'
  // },
  // invalid_style_directive_modifier: /** @param {string} valid */ (valid) => ({
  // 	code: 'invalid-style-directive-modifier',
  // 	message: `Valid modifiers for style directives are: ${valid}`
  // })
};
function error(node2, code, ...args) {
  const fn2 = errors[code];
  const error2 = new Error(fn2(...args));
  error2.code = code;
  if (node2 !== void 0 && node2 !== null) {
    error2.node = typeof node2 === "number" ? { start: node2, end: node2 } : node2;
  }
  throw error2;
}

// src/compiler/phases/1-parse/read/expression.ts
function read_expression(parser) {
  try {
    const node2 = parse_expression_at(parser.template, parser.index);
    let num_parens = 0;
    for (let i = parser.index; i < node2.start; i += 1) {
      if (parser.template[i] === "(")
        num_parens += 1;
    }
    let index = node2.end;
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        error(index, "expected-token", ")");
      }
      index += 1;
    }
    parser.index = index;
    return node2;
  } catch (err) {
    parser.acorn_error(err);
  }
}

// src/compiler/phases/1-parse/read/script.ts
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
function get_context(attributes2) {
  const context = attributes2.find((attribute) => attribute.name === "context");
  if (!context)
    return "default";
  if (context.value.length !== 1 || context.value[0].type !== "Text") {
    error(context.start, "invalid-script-context");
  }
  const value2 = context.value[0].data;
  if (value2 !== "module") {
    error(context.start, "invalid-script-context");
  }
  return value2;
}
function read_script(parser, start, attributes2) {
  const script_start = parser.index;
  const data2 = parser.read_until(regex_closing_script_tag);
  if (parser.index >= parser.template.length) {
    error(parser.template.length, "unclosed-element", "script");
  }
  const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data2;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse4(source);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  return {
    type: "Script",
    start,
    end: parser.index,
    context: get_context(attributes2),
    content: ast,
    parent: null
  };
}

// ../../node_modules/.pnpm/css-tree@2.3.1/node_modules/css-tree/dist/csstree.esm.js
var rs = Object.create;
var tr = Object.defineProperty;
var ns = Object.getOwnPropertyDescriptor;
var os = Object.getOwnPropertyNames;
var is = Object.getPrototypeOf;
var as = Object.prototype.hasOwnProperty;
var Oe = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var b = (e, t) => {
  for (var r in t)
    tr(e, r, { get: t[r], enumerable: true });
};
var ss = (e, t, r, n2) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of os(t))
      !as.call(e, o) && o !== r && tr(e, o, { get: () => t[o], enumerable: !(n2 = ns(t, o)) || n2.enumerable });
  return e;
};
var ls = (e, t, r) => (r = e != null ? rs(is(e)) : {}, ss(t || !e || !e.__esModule ? tr(r, "default", { value: e, enumerable: true }) : r, e));
var Jo = Oe((ur) => {
  var Zo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  ur.encode = function(e) {
    if (0 <= e && e < Zo.length)
      return Zo[e];
    throw new TypeError("Must be between 0 and 63: " + e);
  };
  ur.decode = function(e) {
    var t = 65, r = 90, n2 = 97, o = 122, i = 48, s = 57, u = 43, c2 = 47, a = 26, l = 52;
    return t <= e && e <= r ? e - t : n2 <= e && e <= o ? e - n2 + a : i <= e && e <= s ? e - i + l : e == u ? 62 : e == c2 ? 63 : -1;
  };
});
var oi = Oe((hr) => {
  var ei = Jo(), pr = 5, ti = 1 << pr, ri = ti - 1, ni = ti;
  function ks(e) {
    return e < 0 ? (-e << 1) + 1 : (e << 1) + 0;
  }
  function ws(e) {
    var t = (e & 1) === 1, r = e >> 1;
    return t ? -r : r;
  }
  hr.encode = function(t) {
    var r = "", n2, o = ks(t);
    do
      n2 = o & ri, o >>>= pr, o > 0 && (n2 |= ni), r += ei.encode(n2);
    while (o > 0);
    return r;
  };
  hr.decode = function(t, r, n2) {
    var o = t.length, i = 0, s = 0, u, c2;
    do {
      if (r >= o)
        throw new Error("Expected more digits in base 64 VLQ value.");
      if (c2 = ei.decode(t.charCodeAt(r++)), c2 === -1)
        throw new Error("Invalid base64 digit: " + t.charAt(r - 1));
      u = !!(c2 & ni), c2 &= ri, i = i + (c2 << s), s += pr;
    } while (u);
    n2.value = ws(i), n2.rest = r;
  };
});
var Et = Oe((K) => {
  function vs(e, t, r) {
    if (t in e)
      return e[t];
    if (arguments.length === 3)
      return r;
    throw new Error('"' + t + '" is a required argument.');
  }
  K.getArg = vs;
  var ii = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, Ss = /^data:.+\,.+$/;
  function nt(e) {
    var t = e.match(ii);
    return t ? { scheme: t[1], auth: t[2], host: t[3], port: t[4], path: t[5] } : null;
  }
  K.urlParse = nt;
  function qe(e) {
    var t = "";
    return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t;
  }
  K.urlGenerate = qe;
  var Cs = 32;
  function As(e) {
    var t = [];
    return function(r) {
      for (var n2 = 0; n2 < t.length; n2++)
        if (t[n2].input === r) {
          var o = t[0];
          return t[0] = t[n2], t[n2] = o, t[0].result;
        }
      var i = e(r);
      return t.unshift({ input: r, result: i }), t.length > Cs && t.pop(), i;
    };
  }
  var mr = As(function(t) {
    var r = t, n2 = nt(t);
    if (n2) {
      if (!n2.path)
        return t;
      r = n2.path;
    }
    for (var o = K.isAbsolute(r), i = [], s = 0, u = 0; ; )
      if (s = u, u = r.indexOf("/", s), u === -1) {
        i.push(r.slice(s));
        break;
      } else
        for (i.push(r.slice(s, u)); u < r.length && r[u] === "/"; )
          u++;
    for (var c2, a = 0, u = i.length - 1; u >= 0; u--)
      c2 = i[u], c2 === "." ? i.splice(u, 1) : c2 === ".." ? a++ : a > 0 && (c2 === "" ? (i.splice(u + 1, a), a = 0) : (i.splice(u, 2), a--));
    return r = i.join("/"), r === "" && (r = o ? "/" : "."), n2 ? (n2.path = r, qe(n2)) : r;
  });
  K.normalize = mr;
  function ai(e, t) {
    e === "" && (e = "."), t === "" && (t = ".");
    var r = nt(t), n2 = nt(e);
    if (n2 && (e = n2.path || "/"), r && !r.scheme)
      return n2 && (r.scheme = n2.scheme), qe(r);
    if (r || t.match(Ss))
      return t;
    if (n2 && !n2.host && !n2.path)
      return n2.host = t, qe(n2);
    var o = t.charAt(0) === "/" ? t : mr(e.replace(/\/+$/, "") + "/" + t);
    return n2 ? (n2.path = o, qe(n2)) : o;
  }
  K.join = ai;
  K.isAbsolute = function(e) {
    return e.charAt(0) === "/" || ii.test(e);
  };
  function Ts(e, t) {
    e === "" && (e = "."), e = e.replace(/\/$/, "");
    for (var r = 0; t.indexOf(e + "/") !== 0; ) {
      var n2 = e.lastIndexOf("/");
      if (n2 < 0 || (e = e.slice(0, n2), e.match(/^([^\/]+:\/)?\/*$/)))
        return t;
      ++r;
    }
    return Array(r + 1).join("../") + t.substr(e.length + 1);
  }
  K.relative = Ts;
  var si = function() {
    var e = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in e);
  }();
  function li(e) {
    return e;
  }
  function Es(e) {
    return ci(e) ? "$" + e : e;
  }
  K.toSetString = si ? li : Es;
  function Ls(e) {
    return ci(e) ? e.slice(1) : e;
  }
  K.fromSetString = si ? li : Ls;
  function ci(e) {
    if (!e)
      return false;
    var t = e.length;
    if (t < 9 || e.charCodeAt(t - 1) !== 95 || e.charCodeAt(t - 2) !== 95 || e.charCodeAt(t - 3) !== 111 || e.charCodeAt(t - 4) !== 116 || e.charCodeAt(t - 5) !== 111 || e.charCodeAt(t - 6) !== 114 || e.charCodeAt(t - 7) !== 112 || e.charCodeAt(t - 8) !== 95 || e.charCodeAt(t - 9) !== 95)
      return false;
    for (var r = t - 10; r >= 0; r--)
      if (e.charCodeAt(r) !== 36)
        return false;
    return true;
  }
  function Ps(e, t, r) {
    var n2 = be(e.source, t.source);
    return n2 !== 0 || (n2 = e.originalLine - t.originalLine, n2 !== 0) || (n2 = e.originalColumn - t.originalColumn, n2 !== 0 || r) || (n2 = e.generatedColumn - t.generatedColumn, n2 !== 0) || (n2 = e.generatedLine - t.generatedLine, n2 !== 0) ? n2 : be(e.name, t.name);
  }
  K.compareByOriginalPositions = Ps;
  function Is(e, t, r) {
    var n2;
    return n2 = e.originalLine - t.originalLine, n2 !== 0 || (n2 = e.originalColumn - t.originalColumn, n2 !== 0 || r) || (n2 = e.generatedColumn - t.generatedColumn, n2 !== 0) || (n2 = e.generatedLine - t.generatedLine, n2 !== 0) ? n2 : be(e.name, t.name);
  }
  K.compareByOriginalPositionsNoSource = Is;
  function Ds(e, t, r) {
    var n2 = e.generatedLine - t.generatedLine;
    return n2 !== 0 || (n2 = e.generatedColumn - t.generatedColumn, n2 !== 0 || r) || (n2 = be(e.source, t.source), n2 !== 0) || (n2 = e.originalLine - t.originalLine, n2 !== 0) || (n2 = e.originalColumn - t.originalColumn, n2 !== 0) ? n2 : be(e.name, t.name);
  }
  K.compareByGeneratedPositionsDeflated = Ds;
  function Os(e, t, r) {
    var n2 = e.generatedColumn - t.generatedColumn;
    return n2 !== 0 || r || (n2 = be(e.source, t.source), n2 !== 0) || (n2 = e.originalLine - t.originalLine, n2 !== 0) || (n2 = e.originalColumn - t.originalColumn, n2 !== 0) ? n2 : be(e.name, t.name);
  }
  K.compareByGeneratedPositionsDeflatedNoLine = Os;
  function be(e, t) {
    return e === t ? 0 : e === null ? 1 : t === null ? -1 : e > t ? 1 : -1;
  }
  function Ns(e, t) {
    var r = e.generatedLine - t.generatedLine;
    return r !== 0 || (r = e.generatedColumn - t.generatedColumn, r !== 0) || (r = be(e.source, t.source), r !== 0) || (r = e.originalLine - t.originalLine, r !== 0) || (r = e.originalColumn - t.originalColumn, r !== 0) ? r : be(e.name, t.name);
  }
  K.compareByGeneratedPositionsInflated = Ns;
  function zs(e) {
    return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""));
  }
  K.parseSourceMapInput = zs;
  function Ms(e, t, r) {
    if (t = t || "", e && (e[e.length - 1] !== "/" && t[0] !== "/" && (e += "/"), t = e + t), r) {
      var n2 = nt(r);
      if (!n2)
        throw new Error("sourceMapURL could not be parsed");
      if (n2.path) {
        var o = n2.path.lastIndexOf("/");
        o >= 0 && (n2.path = n2.path.substring(0, o + 1));
      }
      t = ai(qe(n2), t);
    }
    return mr(t);
  }
  K.computeSourceURL = Ms;
});
var pi = Oe((ui) => {
  var fr = Et(), dr = Object.prototype.hasOwnProperty, Le = typeof Map < "u";
  function xe() {
    this._array = [], this._set = Le ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  xe.fromArray = function(t, r) {
    for (var n2 = new xe(), o = 0, i = t.length; o < i; o++)
      n2.add(t[o], r);
    return n2;
  };
  xe.prototype.size = function() {
    return Le ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  xe.prototype.add = function(t, r) {
    var n2 = Le ? t : fr.toSetString(t), o = Le ? this.has(t) : dr.call(this._set, n2), i = this._array.length;
    (!o || r) && this._array.push(t), o || (Le ? this._set.set(t, i) : this._set[n2] = i);
  };
  xe.prototype.has = function(t) {
    if (Le)
      return this._set.has(t);
    var r = fr.toSetString(t);
    return dr.call(this._set, r);
  };
  xe.prototype.indexOf = function(t) {
    if (Le) {
      var r = this._set.get(t);
      if (r >= 0)
        return r;
    } else {
      var n2 = fr.toSetString(t);
      if (dr.call(this._set, n2))
        return this._set[n2];
    }
    throw new Error('"' + t + '" is not in the set.');
  };
  xe.prototype.at = function(t) {
    if (t >= 0 && t < this._array.length)
      return this._array[t];
    throw new Error("No element indexed by " + t);
  };
  xe.prototype.toArray = function() {
    return this._array.slice();
  };
  ui.ArraySet = xe;
});
var fi = Oe((mi) => {
  var hi = Et();
  function Rs(e, t) {
    var r = e.generatedLine, n2 = t.generatedLine, o = e.generatedColumn, i = t.generatedColumn;
    return n2 > r || n2 == r && i >= o || hi.compareByGeneratedPositionsInflated(e, t) <= 0;
  }
  function Lt() {
    this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  Lt.prototype.unsortedForEach = function(t, r) {
    this._array.forEach(t, r);
  };
  Lt.prototype.add = function(t) {
    Rs(this._last, t) ? (this._last = t, this._array.push(t)) : (this._sorted = false, this._array.push(t));
  };
  Lt.prototype.toArray = function() {
    return this._sorted || (this._array.sort(hi.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
  };
  mi.MappingList = Lt;
});
var gi = Oe((di) => {
  var ot = oi(), j = Et(), Pt = pi().ArraySet, Fs = fi().MappingList;
  function oe(e) {
    e || (e = {}), this._file = j.getArg(e, "file", null), this._sourceRoot = j.getArg(e, "sourceRoot", null), this._skipValidation = j.getArg(e, "skipValidation", false), this._sources = new Pt(), this._names = new Pt(), this._mappings = new Fs(), this._sourcesContents = null;
  }
  oe.prototype._version = 3;
  oe.fromSourceMap = function(t) {
    var r = t.sourceRoot, n2 = new oe({ file: t.file, sourceRoot: r });
    return t.eachMapping(function(o) {
      var i = { generated: { line: o.generatedLine, column: o.generatedColumn } };
      o.source != null && (i.source = o.source, r != null && (i.source = j.relative(r, i.source)), i.original = { line: o.originalLine, column: o.originalColumn }, o.name != null && (i.name = o.name)), n2.addMapping(i);
    }), t.sources.forEach(function(o) {
      var i = o;
      r !== null && (i = j.relative(r, o)), n2._sources.has(i) || n2._sources.add(i);
      var s = t.sourceContentFor(o);
      s != null && n2.setSourceContent(o, s);
    }), n2;
  };
  oe.prototype.addMapping = function(t) {
    var r = j.getArg(t, "generated"), n2 = j.getArg(t, "original", null), o = j.getArg(t, "source", null), i = j.getArg(t, "name", null);
    this._skipValidation || this._validateMapping(r, n2, o, i), o != null && (o = String(o), this._sources.has(o) || this._sources.add(o)), i != null && (i = String(i), this._names.has(i) || this._names.add(i)), this._mappings.add({ generatedLine: r.line, generatedColumn: r.column, originalLine: n2 != null && n2.line, originalColumn: n2 != null && n2.column, source: o, name: i });
  };
  oe.prototype.setSourceContent = function(t, r) {
    var n2 = t;
    this._sourceRoot != null && (n2 = j.relative(this._sourceRoot, n2)), r != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[j.toSetString(n2)] = r) : this._sourcesContents && (delete this._sourcesContents[j.toSetString(n2)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  };
  oe.prototype.applySourceMap = function(t, r, n2) {
    var o = r;
    if (r == null) {
      if (t.file == null)
        throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      o = t.file;
    }
    var i = this._sourceRoot;
    i != null && (o = j.relative(i, o));
    var s = new Pt(), u = new Pt();
    this._mappings.unsortedForEach(function(c2) {
      if (c2.source === o && c2.originalLine != null) {
        var a = t.originalPositionFor({ line: c2.originalLine, column: c2.originalColumn });
        a.source != null && (c2.source = a.source, n2 != null && (c2.source = j.join(n2, c2.source)), i != null && (c2.source = j.relative(i, c2.source)), c2.originalLine = a.line, c2.originalColumn = a.column, a.name != null && (c2.name = a.name));
      }
      var l = c2.source;
      l != null && !s.has(l) && s.add(l);
      var p = c2.name;
      p != null && !u.has(p) && u.add(p);
    }, this), this._sources = s, this._names = u, t.sources.forEach(function(c2) {
      var a = t.sourceContentFor(c2);
      a != null && (n2 != null && (c2 = j.join(n2, c2)), i != null && (c2 = j.relative(i, c2)), this.setSourceContent(c2, a));
    }, this);
  };
  oe.prototype._validateMapping = function(t, r, n2, o) {
    if (r && typeof r.line != "number" && typeof r.column != "number")
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if (!(t && "line" in t && "column" in t && t.line > 0 && t.column >= 0 && !r && !n2 && !o)) {
      if (t && "line" in t && "column" in t && r && "line" in r && "column" in r && t.line > 0 && t.column >= 0 && r.line > 0 && r.column >= 0 && n2)
        return;
      throw new Error("Invalid mapping: " + JSON.stringify({ generated: t, source: n2, original: r, name: o }));
    }
  };
  oe.prototype._serializeMappings = function() {
    for (var t = 0, r = 1, n2 = 0, o = 0, i = 0, s = 0, u = "", c2, a, l, p, m = this._mappings.toArray(), f = 0, P = m.length; f < P; f++) {
      if (a = m[f], c2 = "", a.generatedLine !== r)
        for (t = 0; a.generatedLine !== r; )
          c2 += ";", r++;
      else if (f > 0) {
        if (!j.compareByGeneratedPositionsInflated(a, m[f - 1]))
          continue;
        c2 += ",";
      }
      c2 += ot.encode(a.generatedColumn - t), t = a.generatedColumn, a.source != null && (p = this._sources.indexOf(a.source), c2 += ot.encode(p - s), s = p, c2 += ot.encode(a.originalLine - 1 - o), o = a.originalLine - 1, c2 += ot.encode(a.originalColumn - n2), n2 = a.originalColumn, a.name != null && (l = this._names.indexOf(a.name), c2 += ot.encode(l - i), i = l)), u += c2;
    }
    return u;
  };
  oe.prototype._generateSourcesContent = function(t, r) {
    return t.map(function(n2) {
      if (!this._sourcesContents)
        return null;
      r != null && (n2 = j.relative(r, n2));
      var o = j.toSetString(n2);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, o) ? this._sourcesContents[o] : null;
    }, this);
  };
  oe.prototype.toJSON = function() {
    var t = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
    return this._file != null && (t.file = this._file), this._sourceRoot != null && (t.sourceRoot = this._sourceRoot), this._sourcesContents && (t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot)), t;
  };
  oe.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  };
  di.SourceMapGenerator = oe;
});
var $e = {};
b($e, { AtKeyword: () => I, BadString: () => Ae, BadUrl: () => Y, CDC: () => U, CDO: () => ue, Colon: () => O, Comma: () => G, Comment: () => E, Delim: () => g, Dimension: () => y, EOF: () => Xe, Function: () => x, Hash: () => v, Ident: () => h, LeftCurlyBracket: () => M, LeftParenthesis: () => T, LeftSquareBracket: () => q, Number: () => d, Percentage: () => A, RightCurlyBracket: () => H, RightParenthesis: () => w, RightSquareBracket: () => V, Semicolon: () => _, String: () => W, Url: () => F, WhiteSpace: () => k });
var Xe = 0;
var h = 1;
var x = 2;
var I = 3;
var v = 4;
var W = 5;
var Ae = 6;
var F = 7;
var Y = 8;
var g = 9;
var d = 10;
var A = 11;
var y = 12;
var k = 13;
var ue = 14;
var U = 15;
var O = 16;
var _ = 17;
var G = 18;
var q = 19;
var V = 20;
var T = 21;
var w = 22;
var M = 23;
var H = 24;
var E = 25;
function B(e) {
  return e >= 48 && e <= 57;
}
function ee(e) {
  return B(e) || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function yt(e) {
  return e >= 65 && e <= 90;
}
function cs(e) {
  return e >= 97 && e <= 122;
}
function us(e) {
  return yt(e) || cs(e);
}
function ps(e) {
  return e >= 128;
}
function xt(e) {
  return us(e) || ps(e) || e === 95;
}
function Ne(e) {
  return xt(e) || B(e) || e === 45;
}
function hs(e) {
  return e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e === 127;
}
function Ze(e) {
  return e === 10 || e === 13 || e === 12;
}
function pe(e) {
  return Ze(e) || e === 32 || e === 9;
}
function $(e, t) {
  return !(e !== 92 || Ze(t) || t === 0);
}
function ze(e, t, r) {
  return e === 45 ? xt(t) || t === 45 || $(t, r) : xt(e) ? true : e === 92 ? $(e, t) : false;
}
function kt(e, t, r) {
  return e === 43 || e === 45 ? B(t) ? 2 : t === 46 && B(r) ? 3 : 0 : e === 46 ? B(t) ? 2 : 0 : B(e) ? 1 : 0;
}
function wt(e) {
  return e === 65279 || e === 65534 ? 1 : 0;
}
var rr = new Array(128);
var ms = 128;
var Je = 130;
var nr = 131;
var vt = 132;
var or = 133;
for (let e = 0; e < rr.length; e++)
  rr[e] = pe(e) && Je || B(e) && nr || xt(e) && vt || hs(e) && or || e || ms;
function St(e) {
  return e < 128 ? rr[e] : vt;
}
function Me(e, t) {
  return t < e.length ? e.charCodeAt(t) : 0;
}
function Ct(e, t, r) {
  return r === 13 && Me(e, t + 1) === 10 ? 2 : 1;
}
function de(e, t, r) {
  let n2 = e.charCodeAt(t);
  return yt(n2) && (n2 = n2 | 32), n2 === r;
}
function ge(e, t, r, n2) {
  if (r - t !== n2.length || t < 0 || r > e.length)
    return false;
  for (let o = t; o < r; o++) {
    let i = n2.charCodeAt(o - t), s = e.charCodeAt(o);
    if (yt(s) && (s = s | 32), s !== i)
      return false;
  }
  return true;
}
function qo(e, t) {
  for (; t >= 0 && pe(e.charCodeAt(t)); t--)
    ;
  return t + 1;
}
function et(e, t) {
  for (; t < e.length && pe(e.charCodeAt(t)); t++)
    ;
  return t;
}
function ir(e, t) {
  for (; t < e.length && B(e.charCodeAt(t)); t++)
    ;
  return t;
}
function se(e, t) {
  if (t += 2, ee(Me(e, t - 1))) {
    for (let n2 = Math.min(e.length, t + 5); t < n2 && ee(Me(e, t)); t++)
      ;
    let r = Me(e, t);
    pe(r) && (t += Ct(e, t, r));
  }
  return t;
}
function tt(e, t) {
  for (; t < e.length; t++) {
    let r = e.charCodeAt(t);
    if (!Ne(r)) {
      if ($(r, Me(e, t + 1))) {
        t = se(e, t) - 1;
        continue;
      }
      break;
    }
  }
  return t;
}
function Te(e, t) {
  let r = e.charCodeAt(t);
  if ((r === 43 || r === 45) && (r = e.charCodeAt(t += 1)), B(r) && (t = ir(e, t + 1), r = e.charCodeAt(t)), r === 46 && B(e.charCodeAt(t + 1)) && (t += 2, t = ir(e, t)), de(e, t, 101)) {
    let n2 = 0;
    r = e.charCodeAt(t + 1), (r === 45 || r === 43) && (n2 = 1, r = e.charCodeAt(t + 2)), B(r) && (t = ir(e, t + 1 + n2 + 1));
  }
  return t;
}
function At(e, t) {
  for (; t < e.length; t++) {
    let r = e.charCodeAt(t);
    if (r === 41) {
      t++;
      break;
    }
    $(r, Me(e, t + 1)) && (t = se(e, t));
  }
  return t;
}
function Re(e) {
  if (e.length === 1 && !ee(e.charCodeAt(0)))
    return e[0];
  let t = parseInt(e, 16);
  return (t === 0 || t >= 55296 && t <= 57343 || t > 1114111) && (t = 65533), String.fromCodePoint(t);
}
var Fe = ["EOF-token", "ident-token", "function-token", "at-keyword-token", "hash-token", "string-token", "bad-string-token", "url-token", "bad-url-token", "delim-token", "number-token", "percentage-token", "dimension-token", "whitespace-token", "CDO-token", "CDC-token", "colon-token", "semicolon-token", "comma-token", "[-token", "]-token", "(-token", ")-token", "{-token", "}-token"];
function Be(e = null, t) {
  return e === null || e.length < t ? new Uint32Array(Math.max(t + 1024, 16384)) : e;
}
var Uo = 10;
var fs = 12;
var jo = 13;
function Wo(e) {
  let t = e.source, r = t.length, n2 = t.length > 0 ? wt(t.charCodeAt(0)) : 0, o = Be(e.lines, r), i = Be(e.columns, r), s = e.startLine, u = e.startColumn;
  for (let c2 = n2; c2 < r; c2++) {
    let a = t.charCodeAt(c2);
    o[c2] = s, i[c2] = u++, (a === Uo || a === jo || a === fs) && (a === jo && c2 + 1 < r && t.charCodeAt(c2 + 1) === Uo && (c2++, o[c2] = s, i[c2] = u), s++, u = 1);
  }
  o[r] = s, i[r] = u, e.lines = o, e.columns = i, e.computed = true;
}
var Tt = class {
  constructor() {
    this.lines = null, this.columns = null, this.computed = false;
  }
  setSource(t, r = 0, n2 = 1, o = 1) {
    this.source = t, this.startOffset = r, this.startLine = n2, this.startColumn = o, this.computed = false;
  }
  getLocation(t, r) {
    return this.computed || Wo(this), { source: r, offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] };
  }
  getLocationRange(t, r, n2) {
    return this.computed || Wo(this), { source: n2, start: { offset: this.startOffset + t, line: this.lines[t], column: this.columns[t] }, end: { offset: this.startOffset + r, line: this.lines[r], column: this.columns[r] } };
  }
};
var ne = 16777215;
var we = 24;
var ds = /* @__PURE__ */ new Map([[2, 22], [21, 22], [19, 20], [23, 24]]);
var rt = class {
  constructor(t, r) {
    this.setSource(t, r);
  }
  reset() {
    this.eof = false, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset;
  }
  setSource(t = "", r = () => {
  }) {
    t = String(t || "");
    let n2 = t.length, o = Be(this.offsetAndType, t.length + 1), i = Be(this.balance, t.length + 1), s = 0, u = 0, c2 = 0, a = -1;
    for (this.offsetAndType = null, this.balance = null, r(t, (l, p, m) => {
      switch (l) {
        default:
          i[s] = n2;
          break;
        case u: {
          let f = c2 & ne;
          for (c2 = i[f], u = c2 >> we, i[s] = f, i[f++] = s; f < s; f++)
            i[f] === n2 && (i[f] = s);
          break;
        }
        case 21:
        case 2:
        case 19:
        case 23:
          i[s] = c2, u = ds.get(l), c2 = u << we | s;
          break;
      }
      o[s++] = l << we | m, a === -1 && (a = p);
    }), o[s] = 0 << we | n2, i[s] = n2, i[n2] = n2; c2 !== 0; ) {
      let l = c2 & ne;
      c2 = i[l], i[l] = n2;
    }
    this.source = t, this.firstCharOffset = a === -1 ? 0 : a, this.tokenCount = s, this.offsetAndType = o, this.balance = i, this.reset(), this.next();
  }
  lookupType(t) {
    return t += this.tokenIndex, t < this.tokenCount ? this.offsetAndType[t] >> we : 0;
  }
  lookupOffset(t) {
    return t += this.tokenIndex, t < this.tokenCount ? this.offsetAndType[t - 1] & ne : this.source.length;
  }
  lookupValue(t, r) {
    return t += this.tokenIndex, t < this.tokenCount ? ge(this.source, this.offsetAndType[t - 1] & ne, this.offsetAndType[t] & ne, r) : false;
  }
  getTokenStart(t) {
    return t === this.tokenIndex ? this.tokenStart : t > 0 ? t < this.tokenCount ? this.offsetAndType[t - 1] & ne : this.offsetAndType[this.tokenCount] & ne : this.firstCharOffset;
  }
  substrToCursor(t) {
    return this.source.substring(t, this.tokenStart);
  }
  isBalanceEdge(t) {
    return this.balance[this.tokenIndex] < t;
  }
  isDelim(t, r) {
    return r ? this.lookupType(r) === 9 && this.source.charCodeAt(this.lookupOffset(r)) === t : this.tokenType === 9 && this.source.charCodeAt(this.tokenStart) === t;
  }
  skip(t) {
    let r = this.tokenIndex + t;
    r < this.tokenCount ? (this.tokenIndex = r, this.tokenStart = this.offsetAndType[r - 1] & ne, r = this.offsetAndType[r], this.tokenType = r >> we, this.tokenEnd = r & ne) : (this.tokenIndex = this.tokenCount, this.next());
  }
  next() {
    let t = this.tokenIndex + 1;
    t < this.tokenCount ? (this.tokenIndex = t, this.tokenStart = this.tokenEnd, t = this.offsetAndType[t], this.tokenType = t >> we, this.tokenEnd = t & ne) : (this.eof = true, this.tokenIndex = this.tokenCount, this.tokenType = 0, this.tokenStart = this.tokenEnd = this.source.length);
  }
  skipSC() {
    for (; this.tokenType === 13 || this.tokenType === 25; )
      this.next();
  }
  skipUntilBalanced(t, r) {
    let n2 = t, o, i;
    e:
      for (; n2 < this.tokenCount; n2++) {
        if (o = this.balance[n2], o < t)
          break e;
        switch (i = n2 > 0 ? this.offsetAndType[n2 - 1] & ne : this.firstCharOffset, r(this.source.charCodeAt(i))) {
          case 1:
            break e;
          case 2:
            n2++;
            break e;
          default:
            this.balance[o] === n2 && (n2 = o);
        }
      }
    this.skip(n2 - this.tokenIndex);
  }
  forEachToken(t) {
    for (let r = 0, n2 = this.firstCharOffset; r < this.tokenCount; r++) {
      let o = n2, i = this.offsetAndType[r], s = i & ne, u = i >> we;
      n2 = s, t(u, o, s, r);
    }
  }
  dump() {
    let t = new Array(this.tokenCount);
    return this.forEachToken((r, n2, o, i) => {
      t[i] = { idx: i, type: Fe[r], chunk: this.source.substring(n2, o), balance: this.balance[i] };
    }), t;
  }
};
function ve(e, t) {
  function r(p) {
    return p < u ? e.charCodeAt(p) : 0;
  }
  function n2() {
    if (a = Te(e, a), ze(r(a), r(a + 1), r(a + 2))) {
      l = 12, a = tt(e, a);
      return;
    }
    if (r(a) === 37) {
      l = 11, a++;
      return;
    }
    l = 10;
  }
  function o() {
    let p = a;
    if (a = tt(e, a), ge(e, p, a, "url") && r(a) === 40) {
      if (a = et(e, a + 1), r(a) === 34 || r(a) === 39) {
        l = 2, a = p + 4;
        return;
      }
      s();
      return;
    }
    if (r(a) === 40) {
      l = 2, a++;
      return;
    }
    l = 1;
  }
  function i(p) {
    for (p || (p = r(a++)), l = 5; a < e.length; a++) {
      let m = e.charCodeAt(a);
      switch (St(m)) {
        case p:
          a++;
          return;
        case Je:
          if (Ze(m)) {
            a += Ct(e, a, m), l = 6;
            return;
          }
          break;
        case 92:
          if (a === e.length - 1)
            break;
          let f = r(a + 1);
          Ze(f) ? a += Ct(e, a + 1, f) : $(m, f) && (a = se(e, a) - 1);
          break;
      }
    }
  }
  function s() {
    for (l = 7, a = et(e, a); a < e.length; a++) {
      let p = e.charCodeAt(a);
      switch (St(p)) {
        case 41:
          a++;
          return;
        case Je:
          if (a = et(e, a), r(a) === 41 || a >= e.length) {
            a < e.length && a++;
            return;
          }
          a = At(e, a), l = 8;
          return;
        case 34:
        case 39:
        case 40:
        case or:
          a = At(e, a), l = 8;
          return;
        case 92:
          if ($(p, r(a + 1))) {
            a = se(e, a) - 1;
            break;
          }
          a = At(e, a), l = 8;
          return;
      }
    }
  }
  e = String(e || "");
  let u = e.length, c2 = wt(r(0)), a = c2, l;
  for (; a < u; ) {
    let p = e.charCodeAt(a);
    switch (St(p)) {
      case Je:
        l = 13, a = et(e, a + 1);
        break;
      case 34:
        i();
        break;
      case 35:
        Ne(r(a + 1)) || $(r(a + 1), r(a + 2)) ? (l = 4, a = tt(e, a + 1)) : (l = 9, a++);
        break;
      case 39:
        i();
        break;
      case 40:
        l = 21, a++;
        break;
      case 41:
        l = 22, a++;
        break;
      case 43:
        kt(p, r(a + 1), r(a + 2)) ? n2() : (l = 9, a++);
        break;
      case 44:
        l = 18, a++;
        break;
      case 45:
        kt(p, r(a + 1), r(a + 2)) ? n2() : r(a + 1) === 45 && r(a + 2) === 62 ? (l = 15, a = a + 3) : ze(p, r(a + 1), r(a + 2)) ? o() : (l = 9, a++);
        break;
      case 46:
        kt(p, r(a + 1), r(a + 2)) ? n2() : (l = 9, a++);
        break;
      case 47:
        r(a + 1) === 42 ? (l = 25, a = e.indexOf("*/", a + 2), a = a === -1 ? e.length : a + 2) : (l = 9, a++);
        break;
      case 58:
        l = 16, a++;
        break;
      case 59:
        l = 17, a++;
        break;
      case 60:
        r(a + 1) === 33 && r(a + 2) === 45 && r(a + 3) === 45 ? (l = 14, a = a + 4) : (l = 9, a++);
        break;
      case 64:
        ze(r(a + 1), r(a + 2), r(a + 3)) ? (l = 3, a = tt(e, a + 1)) : (l = 9, a++);
        break;
      case 91:
        l = 19, a++;
        break;
      case 92:
        $(p, r(a + 1)) ? o() : (l = 9, a++);
        break;
      case 93:
        l = 20, a++;
        break;
      case 123:
        l = 23, a++;
        break;
      case 125:
        l = 24, a++;
        break;
      case nr:
        n2();
        break;
      case vt:
        o();
        break;
      default:
        l = 9, a++;
    }
    t(l, c2, c2 = a);
  }
}
var _e = null;
var D = class {
  static createItem(t) {
    return { prev: null, next: null, data: t };
  }
  constructor() {
    this.head = null, this.tail = null, this.cursor = null;
  }
  createItem(t) {
    return D.createItem(t);
  }
  allocateCursor(t, r) {
    let n2;
    return _e !== null ? (n2 = _e, _e = _e.cursor, n2.prev = t, n2.next = r, n2.cursor = this.cursor) : n2 = { prev: t, next: r, cursor: this.cursor }, this.cursor = n2, n2;
  }
  releaseCursor() {
    let { cursor: t } = this;
    this.cursor = t.cursor, t.prev = null, t.next = null, t.cursor = _e, _e = t;
  }
  updateCursors(t, r, n2, o) {
    let { cursor: i } = this;
    for (; i !== null; )
      i.prev === t && (i.prev = r), i.next === n2 && (i.next = o), i = i.cursor;
  }
  *[Symbol.iterator]() {
    for (let t = this.head; t !== null; t = t.next)
      yield t.data;
  }
  get size() {
    let t = 0;
    for (let r = this.head; r !== null; r = r.next)
      t++;
    return t;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  fromArray(t) {
    let r = null;
    this.head = null;
    for (let n2 of t) {
      let o = D.createItem(n2);
      r !== null ? r.next = o : this.head = o, o.prev = r, r = o;
    }
    return this.tail = r, this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  forEach(t, r = this) {
    let n2 = this.allocateCursor(null, this.head);
    for (; n2.next !== null; ) {
      let o = n2.next;
      n2.next = o.next, t.call(r, o.data, o, this);
    }
    this.releaseCursor();
  }
  forEachRight(t, r = this) {
    let n2 = this.allocateCursor(this.tail, null);
    for (; n2.prev !== null; ) {
      let o = n2.prev;
      n2.prev = o.prev, t.call(r, o.data, o, this);
    }
    this.releaseCursor();
  }
  reduce(t, r, n2 = this) {
    let o = this.allocateCursor(null, this.head), i = r, s;
    for (; o.next !== null; )
      s = o.next, o.next = s.next, i = t.call(n2, i, s.data, s, this);
    return this.releaseCursor(), i;
  }
  reduceRight(t, r, n2 = this) {
    let o = this.allocateCursor(this.tail, null), i = r, s;
    for (; o.prev !== null; )
      s = o.prev, o.prev = s.prev, i = t.call(n2, i, s.data, s, this);
    return this.releaseCursor(), i;
  }
  some(t, r = this) {
    for (let n2 = this.head; n2 !== null; n2 = n2.next)
      if (t.call(r, n2.data, n2, this))
        return true;
    return false;
  }
  map(t, r = this) {
    let n2 = new D();
    for (let o = this.head; o !== null; o = o.next)
      n2.appendData(t.call(r, o.data, o, this));
    return n2;
  }
  filter(t, r = this) {
    let n2 = new D();
    for (let o = this.head; o !== null; o = o.next)
      t.call(r, o.data, o, this) && n2.appendData(o.data);
    return n2;
  }
  nextUntil(t, r, n2 = this) {
    if (t === null)
      return;
    let o = this.allocateCursor(null, t);
    for (; o.next !== null; ) {
      let i = o.next;
      if (o.next = i.next, r.call(n2, i.data, i, this))
        break;
    }
    this.releaseCursor();
  }
  prevUntil(t, r, n2 = this) {
    if (t === null)
      return;
    let o = this.allocateCursor(t, null);
    for (; o.prev !== null; ) {
      let i = o.prev;
      if (o.prev = i.prev, r.call(n2, i.data, i, this))
        break;
    }
    this.releaseCursor();
  }
  clear() {
    this.head = null, this.tail = null;
  }
  copy() {
    let t = new D();
    for (let r of this)
      t.appendData(r);
    return t;
  }
  prepend(t) {
    return this.updateCursors(null, t, this.head, t), this.head !== null ? (this.head.prev = t, t.next = this.head) : this.tail = t, this.head = t, this;
  }
  prependData(t) {
    return this.prepend(D.createItem(t));
  }
  append(t) {
    return this.insert(t);
  }
  appendData(t) {
    return this.insert(D.createItem(t));
  }
  insert(t, r = null) {
    if (r !== null)
      if (this.updateCursors(r.prev, t, r, t), r.prev === null) {
        if (this.head !== r)
          throw new Error("before doesn't belong to list");
        this.head = t, r.prev = t, t.next = r, this.updateCursors(null, t);
      } else
        r.prev.next = t, t.prev = r.prev, r.prev = t, t.next = r;
    else
      this.updateCursors(this.tail, t, null, t), this.tail !== null ? (this.tail.next = t, t.prev = this.tail) : this.head = t, this.tail = t;
    return this;
  }
  insertData(t, r) {
    return this.insert(D.createItem(t), r);
  }
  remove(t) {
    if (this.updateCursors(t, t.prev, t, t.next), t.prev !== null)
      t.prev.next = t.next;
    else {
      if (this.head !== t)
        throw new Error("item doesn't belong to list");
      this.head = t.next;
    }
    if (t.next !== null)
      t.next.prev = t.prev;
    else {
      if (this.tail !== t)
        throw new Error("item doesn't belong to list");
      this.tail = t.prev;
    }
    return t.prev = null, t.next = null, t;
  }
  push(t) {
    this.insert(D.createItem(t));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(t) {
    this.prepend(D.createItem(t));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(t) {
    return this.insertList(t, this.head);
  }
  appendList(t) {
    return this.insertList(t);
  }
  insertList(t, r) {
    return t.head === null ? this : (r != null ? (this.updateCursors(r.prev, t.tail, r, t.head), r.prev !== null ? (r.prev.next = t.head, t.head.prev = r.prev) : this.head = t.head, r.prev = t.tail, t.tail.next = r) : (this.updateCursors(this.tail, t.tail, null, t.head), this.tail !== null ? (this.tail.next = t.head, t.head.prev = this.tail) : this.head = t.head, this.tail = t.tail), t.head = null, t.tail = null, this);
  }
  replace(t, r) {
    "head" in r ? this.insertList(r, t) : this.insert(r, t), this.remove(t);
  }
};
function Ee(e, t) {
  let r = Object.create(SyntaxError.prototype), n2 = new Error();
  return Object.assign(r, { name: e, message: t, get stack() {
    return (n2.stack || "").replace(/^(.+\n){1,3}/, `${e}: ${t}
`);
  } });
}
var ar = 100;
var Ho = 60;
var Yo = "    ";
function Go({ source: e, line: t, column: r }, n2) {
  function o(l, p) {
    return i.slice(l, p).map((m, f) => String(l + f + 1).padStart(c2) + " |" + m).join(`
`);
  }
  let i = e.split(/\r\n?|\n|\f/), s = Math.max(1, t - n2) - 1, u = Math.min(t + n2, i.length + 1), c2 = Math.max(4, String(u).length) + 1, a = 0;
  r += (Yo.length - 1) * (i[t - 1].substr(0, r - 1).match(/\t/g) || []).length, r > ar && (a = r - Ho + 3, r = Ho - 2);
  for (let l = s; l <= u; l++)
    l >= 0 && l < i.length && (i[l] = i[l].replace(/\t/g, Yo), i[l] = (a > 0 && i[l].length > a ? "\u2026" : "") + i[l].substr(a, ar - 2) + (i[l].length > a + ar - 1 ? "\u2026" : ""));
  return [o(s, t), new Array(r + c2 + 2).join("-") + "^", o(t, u)].filter(Boolean).join(`
`);
}
function sr(e, t, r, n2, o) {
  return Object.assign(Ee("SyntaxError", e), { source: t, offset: r, line: n2, column: o, sourceFragment(s) {
    return Go({ source: t, line: n2, column: o }, isNaN(s) ? 0 : s);
  }, get formattedMessage() {
    return `Parse error: ${e}
` + Go({ source: t, line: n2, column: o }, 2);
  } });
}
function Vo(e) {
  let t = this.createList(), r = false, n2 = { recognizer: e };
  for (; !this.eof; ) {
    switch (this.tokenType) {
      case 25:
        this.next();
        continue;
      case 13:
        r = true, this.next();
        continue;
    }
    let o = e.getNode.call(this, n2);
    if (o === void 0)
      break;
    r && (e.onWhiteSpace && e.onWhiteSpace.call(this, o, t, n2), r = false), t.push(o);
  }
  return r && e.onWhiteSpace && e.onWhiteSpace.call(this, null, t, n2), t;
}
var Ko = () => {
};
var gs = 33;
var bs = 35;
var lr = 59;
var Qo = 123;
var Xo = 0;
function xs(e) {
  return function() {
    return this[e]();
  };
}
function cr(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let n2 = e[r], o = n2.parse || n2;
    o && (t[r] = o);
  }
  return t;
}
function ys(e) {
  let t = { context: /* @__PURE__ */ Object.create(null), scope: Object.assign(/* @__PURE__ */ Object.create(null), e.scope), atrule: cr(e.atrule), pseudo: cr(e.pseudo), node: cr(e.node) };
  for (let r in e.parseContext)
    switch (typeof e.parseContext[r]) {
      case "function":
        t.context[r] = e.parseContext[r];
        break;
      case "string":
        t.context[r] = xs(e.parseContext[r]);
        break;
    }
  return { config: t, ...t, ...t.node };
}
function $o(e) {
  let t = "", r = "<unknown>", n2 = false, o = Ko, i = false, s = new Tt(), u = Object.assign(new rt(), ys(e || {}), { parseAtrulePrelude: true, parseRulePrelude: true, parseValue: true, parseCustomProperty: false, readSequence: Vo, consumeUntilBalanceEnd: () => 0, consumeUntilLeftCurlyBracket(a) {
    return a === Qo ? 1 : 0;
  }, consumeUntilLeftCurlyBracketOrSemicolon(a) {
    return a === Qo || a === lr ? 1 : 0;
  }, consumeUntilExclamationMarkOrSemicolon(a) {
    return a === gs || a === lr ? 1 : 0;
  }, consumeUntilSemicolonIncluded(a) {
    return a === lr ? 2 : 0;
  }, createList() {
    return new D();
  }, createSingleNodeList(a) {
    return new D().appendData(a);
  }, getFirstListNode(a) {
    return a && a.first;
  }, getLastListNode(a) {
    return a && a.last;
  }, parseWithFallback(a, l) {
    let p = this.tokenIndex;
    try {
      return a.call(this);
    } catch (m) {
      if (i)
        throw m;
      let f = l.call(this, p);
      return i = true, o(m, f), i = false, f;
    }
  }, lookupNonWSType(a) {
    let l;
    do
      if (l = this.lookupType(a++), l !== 13)
        return l;
    while (l !== Xo);
    return Xo;
  }, charCodeAt(a) {
    return a >= 0 && a < t.length ? t.charCodeAt(a) : 0;
  }, substring(a, l) {
    return t.substring(a, l);
  }, substrToCursor(a) {
    return this.source.substring(a, this.tokenStart);
  }, cmpChar(a, l) {
    return de(t, a, l);
  }, cmpStr(a, l, p) {
    return ge(t, a, l, p);
  }, consume(a) {
    let l = this.tokenStart;
    return this.eat(a), this.substrToCursor(l);
  }, consumeFunctionName() {
    let a = t.substring(this.tokenStart, this.tokenEnd - 1);
    return this.eat(2), a;
  }, consumeNumber(a) {
    let l = t.substring(this.tokenStart, Te(t, this.tokenStart));
    return this.eat(a), l;
  }, eat(a) {
    if (this.tokenType !== a) {
      let l = Fe[a].slice(0, -6).replace(/-/g, " ").replace(/^./, (f) => f.toUpperCase()), p = `${/[[\](){}]/.test(l) ? `"${l}"` : l} is expected`, m = this.tokenStart;
      switch (a) {
        case 1:
          this.tokenType === 2 || this.tokenType === 7 ? (m = this.tokenEnd - 1, p = "Identifier is expected but function found") : p = "Identifier is expected";
          break;
        case 4:
          this.isDelim(bs) && (this.next(), m++, p = "Name is expected");
          break;
        case 11:
          this.tokenType === 10 && (m = this.tokenEnd, p = "Percent sign is expected");
          break;
      }
      this.error(p, m);
    }
    this.next();
  }, eatIdent(a) {
    (this.tokenType !== 1 || this.lookupValue(0, a) === false) && this.error(`Identifier "${a}" is expected`), this.next();
  }, eatDelim(a) {
    this.isDelim(a) || this.error(`Delim "${String.fromCharCode(a)}" is expected`), this.next();
  }, getLocation(a, l) {
    return n2 ? s.getLocationRange(a, l, r) : null;
  }, getLocationFromList(a) {
    if (n2) {
      let l = this.getFirstListNode(a), p = this.getLastListNode(a);
      return s.getLocationRange(l !== null ? l.loc.start.offset - s.startOffset : this.tokenStart, p !== null ? p.loc.end.offset - s.startOffset : this.tokenStart, r);
    }
    return null;
  }, error(a, l) {
    let p = typeof l < "u" && l < t.length ? s.getLocation(l) : this.eof ? s.getLocation(qo(t, t.length - 1)) : s.getLocation(this.tokenStart);
    throw new sr(a || "Unexpected input", t, p.offset, p.line, p.column);
  } });
  return Object.assign(function(a, l) {
    t = a, l = l || {}, u.setSource(t, ve), s.setSource(t, l.offset, l.line, l.column), r = l.filename || "<unknown>", n2 = Boolean(l.positions), o = typeof l.onParseError == "function" ? l.onParseError : Ko, i = false, u.parseAtrulePrelude = "parseAtrulePrelude" in l ? Boolean(l.parseAtrulePrelude) : true, u.parseRulePrelude = "parseRulePrelude" in l ? Boolean(l.parseRulePrelude) : true, u.parseValue = "parseValue" in l ? Boolean(l.parseValue) : true, u.parseCustomProperty = "parseCustomProperty" in l ? Boolean(l.parseCustomProperty) : false;
    let { context: p = "default", onComment: m } = l;
    if (!(p in u.context))
      throw new Error("Unknown context `" + p + "`");
    typeof m == "function" && u.forEachToken((P, te, X) => {
      if (P === 25) {
        let S = u.getLocation(te, X), R = ge(t, X - 2, X, "*/") ? t.slice(te + 2, X - 2) : t.slice(te + 2, X);
        m(R, S);
      }
    });
    let f = u.context[p].call(u, l);
    return u.eof || u.error(), f;
  }, { SyntaxError: sr, config: u.config });
}
var xi = ls(gi(), 1);
var bi = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function yi(e) {
  let t = new xi.SourceMapGenerator(), r = { line: 1, column: 0 }, n2 = { line: 0, column: 0 }, o = { line: 1, column: 0 }, i = { generated: o }, s = 1, u = 0, c2 = false, a = e.node;
  e.node = function(m) {
    if (m.loc && m.loc.start && bi.has(m.type)) {
      let f = m.loc.start.line, P = m.loc.start.column - 1;
      (n2.line !== f || n2.column !== P) && (n2.line = f, n2.column = P, r.line = s, r.column = u, c2 && (c2 = false, (r.line !== o.line || r.column !== o.column) && t.addMapping(i)), c2 = true, t.addMapping({ source: m.loc.source, original: n2, generated: r }));
    }
    a.call(this, m), c2 && bi.has(m.type) && (o.line = s, o.column = u);
  };
  let l = e.emit;
  e.emit = function(m, f, P) {
    for (let te = 0; te < m.length; te++)
      m.charCodeAt(te) === 10 ? (s++, u = 0) : u++;
    l(m, f, P);
  };
  let p = e.result;
  return e.result = function() {
    return c2 && t.addMapping(i), { css: p(), map: t };
  }, e;
}
var It = {};
b(It, { safe: () => br, spec: () => Us });
var Bs = 43;
var _s = 45;
var gr = (e, t) => {
  if (e === 9 && (e = t), typeof e == "string") {
    let r = e.charCodeAt(0);
    return r > 127 ? 32768 : r << 8;
  }
  return e;
};
var ki = [[1, 1], [1, 2], [1, 7], [1, 8], [1, "-"], [1, 10], [1, 11], [1, 12], [1, 15], [1, 21], [3, 1], [3, 2], [3, 7], [3, 8], [3, "-"], [3, 10], [3, 11], [3, 12], [3, 15], [4, 1], [4, 2], [4, 7], [4, 8], [4, "-"], [4, 10], [4, 11], [4, 12], [4, 15], [12, 1], [12, 2], [12, 7], [12, 8], [12, "-"], [12, 10], [12, 11], [12, 12], [12, 15], ["#", 1], ["#", 2], ["#", 7], ["#", 8], ["#", "-"], ["#", 10], ["#", 11], ["#", 12], ["#", 15], ["-", 1], ["-", 2], ["-", 7], ["-", 8], ["-", "-"], ["-", 10], ["-", 11], ["-", 12], ["-", 15], [10, 1], [10, 2], [10, 7], [10, 8], [10, 10], [10, 11], [10, 12], [10, "%"], [10, 15], ["@", 1], ["@", 2], ["@", 7], ["@", 8], ["@", "-"], ["@", 15], [".", 10], [".", 11], [".", 12], ["+", 10], ["+", 11], ["+", 12], ["/", "*"]];
var qs = ki.concat([[1, 4], [12, 4], [4, 4], [3, 21], [3, 5], [3, 16], [11, 11], [11, 12], [11, 2], [11, "-"], [22, 1], [22, 2], [22, 11], [22, 12], [22, 4], [22, "-"]]);
function wi(e) {
  let t = new Set(e.map(([r, n2]) => gr(r) << 16 | gr(n2)));
  return function(r, n2, o) {
    let i = gr(n2, o), s = o.charCodeAt(0);
    return (s === _s && n2 !== 1 && n2 !== 2 && n2 !== 15 || s === Bs ? t.has(r << 16 | s << 8) : t.has(r << 16 | i)) && this.emit(" ", 13, true), i;
  };
}
var Us = wi(ki);
var br = wi(qs);
var js = 92;
function Ws(e, t) {
  if (typeof t == "function") {
    let r = null;
    e.children.forEach((n2) => {
      r !== null && t.call(this, r), this.node(n2), r = n2;
    });
    return;
  }
  e.children.forEach(this.node, this);
}
function Hs(e) {
  ve(e, (t, r, n2) => {
    this.token(t, e.slice(r, n2));
  });
}
function vi(e) {
  let t = /* @__PURE__ */ new Map();
  for (let r in e.node) {
    let n2 = e.node[r];
    typeof (n2.generate || n2) == "function" && t.set(r, n2.generate || n2);
  }
  return function(r, n2) {
    let o = "", i = 0, s = { node(c2) {
      if (t.has(c2.type))
        t.get(c2.type).call(u, c2);
      else
        throw new Error("Unknown node type: " + c2.type);
    }, tokenBefore: br, token(c2, a) {
      i = this.tokenBefore(i, c2, a), this.emit(a, c2, false), c2 === 9 && a.charCodeAt(0) === js && this.emit(`
`, 13, true);
    }, emit(c2) {
      o += c2;
    }, result() {
      return o;
    } };
    n2 && (typeof n2.decorator == "function" && (s = n2.decorator(s)), n2.sourceMap && (s = yi(s)), n2.mode in It && (s.tokenBefore = It[n2.mode]));
    let u = { node: (c2) => s.node(c2), children: Ws, token: (c2, a) => s.token(c2, a), tokenize: Hs };
    return s.node(r), s.result();
  };
}
function Si(e) {
  return { fromPlainObject(t) {
    return e(t, { enter(r) {
      r.children && !(r.children instanceof D) && (r.children = new D().fromArray(r.children));
    } }), t;
  }, toPlainObject(t) {
    return e(t, { leave(r) {
      r.children && r.children instanceof D && (r.children = r.children.toArray());
    } }), t;
  } };
}
var { hasOwnProperty: xr } = Object.prototype;
var it = function() {
};
function Ci(e) {
  return typeof e == "function" ? e : it;
}
function Ai(e, t) {
  return function(r, n2, o) {
    r.type === t && e.call(this, r, n2, o);
  };
}
function Ys(e, t) {
  let r = t.structure, n2 = [];
  for (let o in r) {
    if (xr.call(r, o) === false)
      continue;
    let i = r[o], s = { name: o, type: false, nullable: false };
    Array.isArray(i) || (i = [i]);
    for (let u of i)
      u === null ? s.nullable = true : typeof u == "string" ? s.type = "node" : Array.isArray(u) && (s.type = "list");
    s.type && n2.push(s);
  }
  return n2.length ? { context: t.walkContext, fields: n2 } : null;
}
function Gs(e) {
  let t = {};
  for (let r in e.node)
    if (xr.call(e.node, r)) {
      let n2 = e.node[r];
      if (!n2.structure)
        throw new Error("Missed `structure` field in `" + r + "` node type definition");
      t[r] = Ys(r, n2);
    }
  return t;
}
function Ti(e, t) {
  let r = e.fields.slice(), n2 = e.context, o = typeof n2 == "string";
  return t && r.reverse(), function(i, s, u, c2) {
    let a;
    o && (a = s[n2], s[n2] = i);
    for (let l of r) {
      let p = i[l.name];
      if (!l.nullable || p) {
        if (l.type === "list") {
          if (t ? p.reduceRight(c2, false) : p.reduce(c2, false))
            return true;
        } else if (u(p))
          return true;
      }
    }
    o && (s[n2] = a);
  };
}
function Ei({ StyleSheet: e, Atrule: t, Rule: r, Block: n2, DeclarationList: o }) {
  return { Atrule: { StyleSheet: e, Atrule: t, Rule: r, Block: n2 }, Rule: { StyleSheet: e, Atrule: t, Rule: r, Block: n2 }, Declaration: { StyleSheet: e, Atrule: t, Rule: r, Block: n2, DeclarationList: o } };
}
function Li(e) {
  let t = Gs(e), r = {}, n2 = {}, o = Symbol("break-walk"), i = Symbol("skip-node");
  for (let a in t)
    xr.call(t, a) && t[a] !== null && (r[a] = Ti(t[a], false), n2[a] = Ti(t[a], true));
  let s = Ei(r), u = Ei(n2), c2 = function(a, l) {
    function p(S, R, ke) {
      let z = m.call(X, S, R, ke);
      return z === o ? true : z === i ? false : !!(P.hasOwnProperty(S.type) && P[S.type](S, X, p, te) || f.call(X, S, R, ke) === o);
    }
    let m = it, f = it, P = r, te = (S, R, ke, z) => S || p(R, ke, z), X = { break: o, skip: i, root: a, stylesheet: null, atrule: null, atrulePrelude: null, rule: null, selector: null, block: null, declaration: null, function: null };
    if (typeof l == "function")
      m = l;
    else if (l && (m = Ci(l.enter), f = Ci(l.leave), l.reverse && (P = n2), l.visit)) {
      if (s.hasOwnProperty(l.visit))
        P = l.reverse ? u[l.visit] : s[l.visit];
      else if (!t.hasOwnProperty(l.visit))
        throw new Error("Bad value `" + l.visit + "` for `visit` option (should be: " + Object.keys(t).sort().join(", ") + ")");
      m = Ai(m, l.visit), f = Ai(f, l.visit);
    }
    if (m === it && f === it)
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    p(a);
  };
  return c2.break = o, c2.skip = i, c2.find = function(a, l) {
    let p = null;
    return c2(a, function(m, f, P) {
      if (l.call(this, m, f, P))
        return p = m, o;
    }), p;
  }, c2.findLast = function(a, l) {
    let p = null;
    return c2(a, { reverse: true, enter(m, f, P) {
      if (l.call(this, m, f, P))
        return p = m, o;
    } }), p;
  }, c2.findAll = function(a, l) {
    let p = [];
    return c2(a, function(m, f, P) {
      l.call(this, m, f, P) && p.push(m);
    }), p;
  }, c2;
}
function Vs(e) {
  return e;
}
function Ks(e) {
  let { min: t, max: r, comma: n2 } = e;
  return t === 0 && r === 0 ? n2 ? "#?" : "*" : t === 0 && r === 1 ? "?" : t === 1 && r === 0 ? n2 ? "#" : "+" : t === 1 && r === 1 ? "" : (n2 ? "#" : "") + (t === r ? "{" + t + "}" : "{" + t + "," + (r !== 0 ? r : "") + "}");
}
function Qs(e) {
  switch (e.type) {
    case "Range":
      return " [" + (e.min === null ? "-\u221E" : e.min) + "," + (e.max === null ? "\u221E" : e.max) + "]";
    default:
      throw new Error("Unknown node type `" + e.type + "`");
  }
}
function Xs(e, t, r, n2) {
  let o = e.combinator === " " || n2 ? e.combinator : " " + e.combinator + " ", i = e.terms.map((s) => yr(s, t, r, n2)).join(o);
  return e.explicit || r ? (n2 || i[0] === "," ? "[" : "[ ") + i + (n2 ? "]" : " ]") : i;
}
function yr(e, t, r, n2) {
  let o;
  switch (e.type) {
    case "Group":
      o = Xs(e, t, r, n2) + (e.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return yr(e.term, t, r, n2) + t(Ks(e), e);
    case "Type":
      o = "<" + e.name + (e.opts ? t(Qs(e.opts), e.opts) : "") + ">";
      break;
    case "Property":
      o = "<'" + e.name + "'>";
      break;
    case "Keyword":
      o = e.name;
      break;
    case "AtKeyword":
      o = "@" + e.name;
      break;
    case "Function":
      o = e.name + "(";
      break;
    case "String":
    case "Token":
      o = e.value;
      break;
    case "Comma":
      o = ",";
      break;
    default:
      throw new Error("Unknown node type `" + e.type + "`");
  }
  return t(o, e);
}
function Pe(e, t) {
  let r = Vs, n2 = false, o = false;
  return typeof t == "function" ? r = t : t && (n2 = Boolean(t.forceBraces), o = Boolean(t.compact), typeof t.decorate == "function" && (r = t.decorate)), yr(e, r, n2, o);
}
var Pi = { offset: 0, line: 1, column: 1 };
function $s(e, t) {
  let r = e.tokens, n2 = e.longestMatch, o = n2 < r.length && r[n2].node || null, i = o !== t ? o : null, s = 0, u = 0, c2 = 0, a = "", l, p;
  for (let m = 0; m < r.length; m++) {
    let f = r[m].value;
    m === n2 && (u = f.length, s = a.length), i !== null && r[m].node === i && (m <= n2 ? c2++ : c2 = 0), a += f;
  }
  return n2 === r.length || c2 > 1 ? (l = Dt(i || t, "end") || at2(Pi, a), p = at2(l)) : (l = Dt(i, "start") || at2(Dt(t, "start") || Pi, a.slice(0, s)), p = Dt(i, "end") || at2(l, a.substr(s, u))), { css: a, mismatchOffset: s, mismatchLength: u, start: l, end: p };
}
function Dt(e, t) {
  let r = e && e.loc && e.loc[t];
  return r ? "line" in r ? at2(r) : r : null;
}
function at2({ offset: e, line: t, column: r }, n2) {
  let o = { offset: e, line: t, column: r };
  if (n2) {
    let i = n2.split(/\n|\r\n?|\f/);
    o.offset += n2.length, o.line += i.length - 1, o.column = i.length === 1 ? o.column + n2.length : i.pop().length + 1;
  }
  return o;
}
var Ue = function(e, t) {
  let r = Ee("SyntaxReferenceError", e + (t ? " `" + t + "`" : ""));
  return r.reference = t, r;
};
var Ii = function(e, t, r, n2) {
  let o = Ee("SyntaxMatchError", e), { css: i, mismatchOffset: s, mismatchLength: u, start: c2, end: a } = $s(n2, r);
  return o.rawMessage = e, o.syntax = t ? Pe(t) : "<generic>", o.css = i, o.mismatchOffset = s, o.mismatchLength = u, o.message = e + `
  syntax: ` + o.syntax + `
   value: ` + (i || "<empty string>") + `
  --------` + new Array(o.mismatchOffset + 1).join("-") + "^", Object.assign(o, c2), o.loc = { source: r && r.loc && r.loc.source || "<unknown>", start: c2, end: a }, o;
};
var Ot = /* @__PURE__ */ new Map();
var je = /* @__PURE__ */ new Map();
var Nt = 45;
var zt = Zs;
var kr = Js;
function Mt(e, t) {
  return t = t || 0, e.length - t >= 2 && e.charCodeAt(t) === Nt && e.charCodeAt(t + 1) === Nt;
}
function wr(e, t) {
  if (t = t || 0, e.length - t >= 3 && e.charCodeAt(t) === Nt && e.charCodeAt(t + 1) !== Nt) {
    let r = e.indexOf("-", t + 2);
    if (r !== -1)
      return e.substring(t, r + 1);
  }
  return "";
}
function Zs(e) {
  if (Ot.has(e))
    return Ot.get(e);
  let t = e.toLowerCase(), r = Ot.get(t);
  if (r === void 0) {
    let n2 = Mt(t, 0), o = n2 ? "" : wr(t, 0);
    r = Object.freeze({ basename: t.substr(o.length), name: t, prefix: o, vendor: o, custom: n2 });
  }
  return Ot.set(e, r), r;
}
function Js(e) {
  if (je.has(e))
    return je.get(e);
  let t = e, r = e[0];
  r === "/" ? r = e[1] === "/" ? "//" : "/" : r !== "_" && r !== "*" && r !== "$" && r !== "#" && r !== "+" && r !== "&" && (r = "");
  let n2 = Mt(t, r.length);
  if (!n2 && (t = t.toLowerCase(), je.has(t))) {
    let u = je.get(t);
    return je.set(e, u), u;
  }
  let o = n2 ? "" : wr(t, r.length), i = t.substr(0, r.length + o.length), s = Object.freeze({ basename: t.substr(i.length), name: t.substr(r.length), hack: r, vendor: o, prefix: i, custom: n2 });
  return je.set(e, s), s;
}
var Rt = ["initial", "inherit", "unset", "revert", "revert-layer"];
var lt = 43;
var he = 45;
var vr = 110;
var We = true;
var tl = false;
function Cr(e, t) {
  return e !== null && e.type === 9 && e.value.charCodeAt(0) === t;
}
function st(e, t, r) {
  for (; e !== null && (e.type === 13 || e.type === 25); )
    e = r(++t);
  return t;
}
function Se(e, t, r, n2) {
  if (!e)
    return 0;
  let o = e.value.charCodeAt(t);
  if (o === lt || o === he) {
    if (r)
      return 0;
    t++;
  }
  for (; t < e.value.length; t++)
    if (!B(e.value.charCodeAt(t)))
      return 0;
  return n2 + 1;
}
function Sr(e, t, r) {
  let n2 = false, o = st(e, t, r);
  if (e = r(o), e === null)
    return t;
  if (e.type !== 10)
    if (Cr(e, lt) || Cr(e, he)) {
      if (n2 = true, o = st(r(++o), o, r), e = r(o), e === null || e.type !== 10)
        return 0;
    } else
      return t;
  if (!n2) {
    let i = e.value.charCodeAt(0);
    if (i !== lt && i !== he)
      return 0;
  }
  return Se(e, n2 ? 0 : 1, n2, o);
}
function Ar(e, t) {
  let r = 0;
  if (!e)
    return 0;
  if (e.type === 10)
    return Se(e, 0, tl, r);
  if (e.type === 1 && e.value.charCodeAt(0) === he) {
    if (!de(e.value, 1, vr))
      return 0;
    switch (e.value.length) {
      case 2:
        return Sr(t(++r), r, t);
      case 3:
        return e.value.charCodeAt(2) !== he ? 0 : (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r));
      default:
        return e.value.charCodeAt(2) !== he ? 0 : Se(e, 3, We, r);
    }
  } else if (e.type === 1 || Cr(e, lt) && t(r + 1).type === 1) {
    if (e.type !== 1 && (e = t(++r)), e === null || !de(e.value, 0, vr))
      return 0;
    switch (e.value.length) {
      case 1:
        return Sr(t(++r), r, t);
      case 2:
        return e.value.charCodeAt(1) !== he ? 0 : (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r));
      default:
        return e.value.charCodeAt(1) !== he ? 0 : Se(e, 2, We, r);
    }
  } else if (e.type === 12) {
    let n2 = e.value.charCodeAt(0), o = n2 === lt || n2 === he ? 1 : 0, i = o;
    for (; i < e.value.length && B(e.value.charCodeAt(i)); i++)
      ;
    return i === o || !de(e.value, i, vr) ? 0 : i + 1 === e.value.length ? Sr(t(++r), r, t) : e.value.charCodeAt(i + 1) !== he ? 0 : i + 2 === e.value.length ? (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r)) : Se(e, i + 2, We, r);
  }
  return 0;
}
var rl = 43;
var Di = 45;
var Oi = 63;
var nl = 117;
function Tr(e, t) {
  return e !== null && e.type === 9 && e.value.charCodeAt(0) === t;
}
function ol(e, t) {
  return e.value.charCodeAt(0) === t;
}
function ct(e, t, r) {
  let n2 = 0;
  for (let o = t; o < e.value.length; o++) {
    let i = e.value.charCodeAt(o);
    if (i === Di && r && n2 !== 0)
      return ct(e, t + n2 + 1, false), 6;
    if (!ee(i) || ++n2 > 6)
      return 0;
  }
  return n2;
}
function Ft(e, t, r) {
  if (!e)
    return 0;
  for (; Tr(r(t), Oi); ) {
    if (++e > 6)
      return 0;
    t++;
  }
  return t;
}
function Er(e, t) {
  let r = 0;
  if (e === null || e.type !== 1 || !de(e.value, 0, nl) || (e = t(++r), e === null))
    return 0;
  if (Tr(e, rl))
    return e = t(++r), e === null ? 0 : e.type === 1 ? Ft(ct(e, 0, true), ++r, t) : Tr(e, Oi) ? Ft(1, ++r, t) : 0;
  if (e.type === 10) {
    let n2 = ct(e, 1, true);
    return n2 === 0 ? 0 : (e = t(++r), e === null ? r : e.type === 12 || e.type === 10 ? !ol(e, Di) || !ct(e, 1, false) ? 0 : r + 1 : Ft(n2, r, t));
  }
  return e.type === 12 ? Ft(ct(e, 1, true), ++r, t) : 0;
}
var il = ["calc(", "-moz-calc(", "-webkit-calc("];
var Lr = /* @__PURE__ */ new Map([[2, 22], [21, 22], [19, 20], [23, 24]]);
function le(e, t) {
  return t < e.length ? e.charCodeAt(t) : 0;
}
function Ni(e, t) {
  return ge(e, 0, e.length, t);
}
function zi(e, t) {
  for (let r = 0; r < t.length; r++)
    if (Ni(e, t[r]))
      return true;
  return false;
}
function Mi(e, t) {
  return t !== e.length - 2 ? false : le(e, t) === 92 && B(le(e, t + 1));
}
function Bt(e, t, r) {
  if (e && e.type === "Range") {
    let n2 = Number(r !== void 0 && r !== t.length ? t.substr(0, r) : t);
    if (isNaN(n2) || e.min !== null && n2 < e.min && typeof e.min != "string" || e.max !== null && n2 > e.max && typeof e.max != "string")
      return true;
  }
  return false;
}
function al(e, t) {
  let r = 0, n2 = [], o = 0;
  e:
    do {
      switch (e.type) {
        case 24:
        case 22:
        case 20:
          if (e.type !== r)
            break e;
          if (r = n2.pop(), n2.length === 0) {
            o++;
            break e;
          }
          break;
        case 2:
        case 21:
        case 19:
        case 23:
          n2.push(r), r = Lr.get(e.type);
          break;
      }
      o++;
    } while (e = t(o));
  return o;
}
function ie(e) {
  return function(t, r, n2) {
    return t === null ? 0 : t.type === 2 && zi(t.value, il) ? al(t, r) : e(t, r, n2);
  };
}
function N(e) {
  return function(t) {
    return t === null || t.type !== e ? 0 : 1;
  };
}
function sl(e) {
  if (e === null || e.type !== 1)
    return 0;
  let t = e.value.toLowerCase();
  return zi(t, Rt) || Ni(t, "default") ? 0 : 1;
}
function ll(e) {
  return e === null || e.type !== 1 || le(e.value, 0) !== 45 || le(e.value, 1) !== 45 ? 0 : 1;
}
function cl(e) {
  if (e === null || e.type !== 4)
    return 0;
  let t = e.value.length;
  if (t !== 4 && t !== 5 && t !== 7 && t !== 9)
    return 0;
  for (let r = 1; r < t; r++)
    if (!ee(le(e.value, r)))
      return 0;
  return 1;
}
function ul(e) {
  return e === null || e.type !== 4 || !ze(le(e.value, 1), le(e.value, 2), le(e.value, 3)) ? 0 : 1;
}
function pl(e, t) {
  if (!e)
    return 0;
  let r = 0, n2 = [], o = 0;
  e:
    do {
      switch (e.type) {
        case 6:
        case 8:
          break e;
        case 24:
        case 22:
        case 20:
          if (e.type !== r)
            break e;
          r = n2.pop();
          break;
        case 17:
          if (r === 0)
            break e;
          break;
        case 9:
          if (r === 0 && e.value === "!")
            break e;
          break;
        case 2:
        case 21:
        case 19:
        case 23:
          n2.push(r), r = Lr.get(e.type);
          break;
      }
      o++;
    } while (e = t(o));
  return o;
}
function hl(e, t) {
  if (!e)
    return 0;
  let r = 0, n2 = [], o = 0;
  e:
    do {
      switch (e.type) {
        case 6:
        case 8:
          break e;
        case 24:
        case 22:
        case 20:
          if (e.type !== r)
            break e;
          r = n2.pop();
          break;
        case 2:
        case 21:
        case 19:
        case 23:
          n2.push(r), r = Lr.get(e.type);
          break;
      }
      o++;
    } while (e = t(o));
  return o;
}
function ye(e) {
  return e && (e = new Set(e)), function(t, r, n2) {
    if (t === null || t.type !== 12)
      return 0;
    let o = Te(t.value, 0);
    if (e !== null) {
      let i = t.value.indexOf("\\", o), s = i === -1 || !Mi(t.value, i) ? t.value.substr(o) : t.value.substring(o, i);
      if (e.has(s.toLowerCase()) === false)
        return 0;
    }
    return Bt(n2, t.value, o) ? 0 : 1;
  };
}
function ml(e, t, r) {
  return e === null || e.type !== 11 || Bt(r, e.value, e.value.length - 1) ? 0 : 1;
}
function Ri(e) {
  return typeof e != "function" && (e = function() {
    return 0;
  }), function(t, r, n2) {
    return t !== null && t.type === 10 && Number(t.value) === 0 ? 1 : e(t, r, n2);
  };
}
function fl(e, t, r) {
  if (e === null)
    return 0;
  let n2 = Te(e.value, 0);
  return !(n2 === e.value.length) && !Mi(e.value, n2) || Bt(r, e.value, n2) ? 0 : 1;
}
function dl(e, t, r) {
  if (e === null || e.type !== 10)
    return 0;
  let n2 = le(e.value, 0) === 43 || le(e.value, 0) === 45 ? 1 : 0;
  for (; n2 < e.value.length; n2++)
    if (!B(le(e.value, n2)))
      return 0;
  return Bt(r, e.value, n2) ? 0 : 1;
}
var gl = { "ident-token": N(1), "function-token": N(2), "at-keyword-token": N(3), "hash-token": N(4), "string-token": N(5), "bad-string-token": N(6), "url-token": N(7), "bad-url-token": N(8), "delim-token": N(9), "number-token": N(10), "percentage-token": N(11), "dimension-token": N(12), "whitespace-token": N(13), "CDO-token": N(14), "CDC-token": N(15), "colon-token": N(16), "semicolon-token": N(17), "comma-token": N(18), "[-token": N(19), "]-token": N(20), "(-token": N(21), ")-token": N(22), "{-token": N(23), "}-token": N(24) };
var bl = { string: N(5), ident: N(1), percentage: ie(ml), zero: Ri(), number: ie(fl), integer: ie(dl), "custom-ident": sl, "custom-property-name": ll, "hex-color": cl, "id-selector": ul, "an-plus-b": Ar, urange: Er, "declaration-value": pl, "any-value": hl };
function xl(e) {
  let { angle: t, decibel: r, frequency: n2, flex: o, length: i, resolution: s, semitones: u, time: c2 } = e || {};
  return { dimension: ie(ye(null)), angle: ie(ye(t)), decibel: ie(ye(r)), frequency: ie(ye(n2)), flex: ie(ye(o)), length: ie(Ri(ye(i))), resolution: ie(ye(s)), semitones: ie(ye(u)), time: ie(ye(c2)) };
}
function Fi(e) {
  return { ...gl, ...bl, ...xl(e) };
}
var _t = {};
b(_t, { angle: () => kl, decibel: () => Al, flex: () => Cl, frequency: () => vl, length: () => yl, resolution: () => Sl, semitones: () => Tl, time: () => wl });
var yl = ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var kl = ["deg", "grad", "rad", "turn"];
var wl = ["s", "ms"];
var vl = ["hz", "khz"];
var Sl = ["dpi", "dpcm", "dppx", "x"];
var Cl = ["fr"];
var Al = ["db"];
var Tl = ["st"];
var $i = {};
b($i, { SyntaxError: () => qt, generate: () => Pe, parse: () => Ge, walk: () => Vt });
function qt(e, t, r) {
  return Object.assign(Ee("SyntaxError", e), { input: t, offset: r, rawMessage: e, message: e + `
  ` + t + `
--` + new Array((r || t.length) + 1).join("-") + "^" });
}
var El = 9;
var Ll = 10;
var Pl = 12;
var Il = 13;
var Dl = 32;
var Ut = class {
  constructor(t) {
    this.str = t, this.pos = 0;
  }
  charCodeAt(t) {
    return t < this.str.length ? this.str.charCodeAt(t) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(t) {
    return this.charCodeAt(this.findWsEnd(t));
  }
  findWsEnd(t) {
    for (; t < this.str.length; t++) {
      let r = this.str.charCodeAt(t);
      if (r !== Il && r !== Ll && r !== Pl && r !== Dl && r !== El)
        break;
    }
    return t;
  }
  substringToPos(t) {
    return this.str.substring(this.pos, this.pos = t);
  }
  eat(t) {
    this.charCode() !== t && this.error("Expect `" + String.fromCharCode(t) + "`"), this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(t) {
    throw new qt(t, this.str, this.pos);
  }
};
var Ol = 9;
var Nl = 10;
var zl = 12;
var Ml = 13;
var Rl = 32;
var Yi = 33;
var Dr = 35;
var Bi = 38;
var jt = 39;
var Gi = 40;
var Fl = 41;
var Vi = 42;
var Or = 43;
var Nr = 44;
var _i = 45;
var zr = 60;
var Ki = 62;
var Ir = 63;
var Bl = 64;
var Gt = 91;
var Mr = 93;
var Wt = 123;
var qi = 124;
var Ui = 125;
var ji = 8734;
var ut = new Uint8Array(128).map((e, t) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(t)) ? 1 : 0);
var Wi = { " ": 1, "&&": 2, "||": 3, "|": 4 };
function Ht(e) {
  return e.substringToPos(e.findWsEnd(e.pos));
}
function He(e) {
  let t = e.pos;
  for (; t < e.str.length; t++) {
    let r = e.str.charCodeAt(t);
    if (r >= 128 || ut[r] === 0)
      break;
  }
  return e.pos === t && e.error("Expect a keyword"), e.substringToPos(t);
}
function Yt(e) {
  let t = e.pos;
  for (; t < e.str.length; t++) {
    let r = e.str.charCodeAt(t);
    if (r < 48 || r > 57)
      break;
  }
  return e.pos === t && e.error("Expect a number"), e.substringToPos(t);
}
function _l(e) {
  let t = e.str.indexOf("'", e.pos + 1);
  return t === -1 && (e.pos = e.str.length, e.error("Expect an apostrophe")), e.substringToPos(t + 1);
}
function Hi(e) {
  let t = null, r = null;
  return e.eat(Wt), t = Yt(e), e.charCode() === Nr ? (e.pos++, e.charCode() !== Ui && (r = Yt(e))) : r = t, e.eat(Ui), { min: Number(t), max: r ? Number(r) : 0 };
}
function ql(e) {
  let t = null, r = false;
  switch (e.charCode()) {
    case Vi:
      e.pos++, t = { min: 0, max: 0 };
      break;
    case Or:
      e.pos++, t = { min: 1, max: 0 };
      break;
    case Ir:
      e.pos++, t = { min: 0, max: 1 };
      break;
    case Dr:
      e.pos++, r = true, e.charCode() === Wt ? t = Hi(e) : e.charCode() === Ir ? (e.pos++, t = { min: 0, max: 0 }) : t = { min: 1, max: 0 };
      break;
    case Wt:
      t = Hi(e);
      break;
    default:
      return null;
  }
  return { type: "Multiplier", comma: r, min: t.min, max: t.max, term: null };
}
function Ye(e, t) {
  let r = ql(e);
  return r !== null ? (r.term = t, e.charCode() === Dr && e.charCodeAt(e.pos - 1) === Or ? Ye(e, r) : r) : t;
}
function Pr(e) {
  let t = e.peek();
  return t === "" ? null : { type: "Token", value: t };
}
function Ul(e) {
  let t;
  return e.eat(zr), e.eat(jt), t = He(e), e.eat(jt), e.eat(Ki), Ye(e, { type: "Property", name: t });
}
function jl(e) {
  let t = null, r = null, n2 = 1;
  return e.eat(Gt), e.charCode() === _i && (e.peek(), n2 = -1), n2 == -1 && e.charCode() === ji ? e.peek() : (t = n2 * Number(Yt(e)), ut[e.charCode()] !== 0 && (t += He(e))), Ht(e), e.eat(Nr), Ht(e), e.charCode() === ji ? e.peek() : (n2 = 1, e.charCode() === _i && (e.peek(), n2 = -1), r = n2 * Number(Yt(e)), ut[e.charCode()] !== 0 && (r += He(e))), e.eat(Mr), { type: "Range", min: t, max: r };
}
function Wl(e) {
  let t, r = null;
  return e.eat(zr), t = He(e), e.charCode() === Gi && e.nextCharCode() === Fl && (e.pos += 2, t += "()"), e.charCodeAt(e.findWsEnd(e.pos)) === Gt && (Ht(e), r = jl(e)), e.eat(Ki), Ye(e, { type: "Type", name: t, opts: r });
}
function Hl(e) {
  let t = He(e);
  return e.charCode() === Gi ? (e.pos++, { type: "Function", name: t }) : Ye(e, { type: "Keyword", name: t });
}
function Yl(e, t) {
  function r(o, i) {
    return { type: "Group", terms: o, combinator: i, disallowEmpty: false, explicit: false };
  }
  let n2;
  for (t = Object.keys(t).sort((o, i) => Wi[o] - Wi[i]); t.length > 0; ) {
    n2 = t.shift();
    let o = 0, i = 0;
    for (; o < e.length; o++) {
      let s = e[o];
      s.type === "Combinator" && (s.value === n2 ? (i === -1 && (i = o - 1), e.splice(o, 1), o--) : (i !== -1 && o - i > 1 && (e.splice(i, o - i, r(e.slice(i, o), n2)), o = i + 1), i = -1));
    }
    i !== -1 && t.length && e.splice(i, o - i, r(e.slice(i, o), n2));
  }
  return n2;
}
function Qi(e) {
  let t = [], r = {}, n2, o = null, i = e.pos;
  for (; n2 = Vl(e); )
    n2.type !== "Spaces" && (n2.type === "Combinator" ? ((o === null || o.type === "Combinator") && (e.pos = i, e.error("Unexpected combinator")), r[n2.value] = true) : o !== null && o.type !== "Combinator" && (r[" "] = true, t.push({ type: "Combinator", value: " " })), t.push(n2), o = n2, i = e.pos);
  return o !== null && o.type === "Combinator" && (e.pos -= i, e.error("Unexpected combinator")), { type: "Group", terms: t, combinator: Yl(t, r) || " ", disallowEmpty: false, explicit: false };
}
function Gl(e) {
  let t;
  return e.eat(Gt), t = Qi(e), e.eat(Mr), t.explicit = true, e.charCode() === Yi && (e.pos++, t.disallowEmpty = true), t;
}
function Vl(e) {
  let t = e.charCode();
  if (t < 128 && ut[t] === 1)
    return Hl(e);
  switch (t) {
    case Mr:
      break;
    case Gt:
      return Ye(e, Gl(e));
    case zr:
      return e.nextCharCode() === jt ? Ul(e) : Wl(e);
    case qi:
      return { type: "Combinator", value: e.substringToPos(e.pos + (e.nextCharCode() === qi ? 2 : 1)) };
    case Bi:
      return e.pos++, e.eat(Bi), { type: "Combinator", value: "&&" };
    case Nr:
      return e.pos++, { type: "Comma" };
    case jt:
      return Ye(e, { type: "String", value: _l(e) });
    case Rl:
    case Ol:
    case Nl:
    case Ml:
    case zl:
      return { type: "Spaces", value: Ht(e) };
    case Bl:
      return t = e.nextCharCode(), t < 128 && ut[t] === 1 ? (e.pos++, { type: "AtKeyword", name: He(e) }) : Pr(e);
    case Vi:
    case Or:
    case Ir:
    case Dr:
    case Yi:
      break;
    case Wt:
      if (t = e.nextCharCode(), t < 48 || t > 57)
        return Pr(e);
      break;
    default:
      return Pr(e);
  }
}
function Ge(e) {
  let t = new Ut(e), r = Qi(t);
  return t.pos !== e.length && t.error("Unexpected input"), r.terms.length === 1 && r.terms[0].type === "Group" ? r.terms[0] : r;
}
var pt = function() {
};
function Xi(e) {
  return typeof e == "function" ? e : pt;
}
function Vt(e, t, r) {
  function n2(s) {
    switch (o.call(r, s), s.type) {
      case "Group":
        s.terms.forEach(n2);
        break;
      case "Multiplier":
        n2(s.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + s.type);
    }
    i.call(r, s);
  }
  let o = pt, i = pt;
  if (typeof t == "function" ? o = t : t && (o = Xi(t.enter), i = Xi(t.leave)), o === pt && i === pt)
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  n2(e, r);
}
var Kl = { decorator(e) {
  let t = [], r = null;
  return { ...e, node(n2) {
    let o = r;
    r = n2, e.node.call(this, n2), r = o;
  }, emit(n2, o, i) {
    t.push({ type: o, value: n2, node: i ? null : r });
  }, result() {
    return t;
  } };
} };
function Ql(e) {
  let t = [];
  return ve(e, (r, n2, o) => t.push({ type: r, value: e.slice(n2, o), node: null })), t;
}
function Zi(e, t) {
  return typeof e == "string" ? Ql(e) : t.generate(e, Kl);
}
var C = { type: "Match" };
var L = { type: "Mismatch" };
var Kt = { type: "DisallowEmpty" };
var Xl = 40;
var $l = 41;
function Z(e, t, r) {
  return t === C && r === L || e === C && t === C && r === C ? e : (e.type === "If" && e.else === L && t === C && (t = e.then, e = e.match), { type: "If", match: e, then: t, else: r });
}
function ea(e) {
  return e.length > 2 && e.charCodeAt(e.length - 2) === Xl && e.charCodeAt(e.length - 1) === $l;
}
function Ji(e) {
  return e.type === "Keyword" || e.type === "AtKeyword" || e.type === "Function" || e.type === "Type" && ea(e.name);
}
function Rr(e, t, r) {
  switch (e) {
    case " ": {
      let n2 = C;
      for (let o = t.length - 1; o >= 0; o--) {
        let i = t[o];
        n2 = Z(i, n2, L);
      }
      return n2;
    }
    case "|": {
      let n2 = L, o = null;
      for (let i = t.length - 1; i >= 0; i--) {
        let s = t[i];
        if (Ji(s) && (o === null && i > 0 && Ji(t[i - 1]) && (o = /* @__PURE__ */ Object.create(null), n2 = Z({ type: "Enum", map: o }, C, n2)), o !== null)) {
          let u = (ea(s.name) ? s.name.slice(0, -1) : s.name).toLowerCase();
          if (!(u in o)) {
            o[u] = s;
            continue;
          }
        }
        o = null, n2 = Z(s, C, n2);
      }
      return n2;
    }
    case "&&": {
      if (t.length > 5)
        return { type: "MatchOnce", terms: t, all: true };
      let n2 = L;
      for (let o = t.length - 1; o >= 0; o--) {
        let i = t[o], s;
        t.length > 1 ? s = Rr(e, t.filter(function(u) {
          return u !== i;
        }), false) : s = C, n2 = Z(i, s, n2);
      }
      return n2;
    }
    case "||": {
      if (t.length > 5)
        return { type: "MatchOnce", terms: t, all: false };
      let n2 = r ? C : L;
      for (let o = t.length - 1; o >= 0; o--) {
        let i = t[o], s;
        t.length > 1 ? s = Rr(e, t.filter(function(u) {
          return u !== i;
        }), true) : s = C, n2 = Z(i, s, n2);
      }
      return n2;
    }
  }
}
function Zl(e) {
  let t = C, r = Fr(e.term);
  if (e.max === 0)
    r = Z(r, Kt, L), t = Z(r, null, L), t.then = Z(C, C, t), e.comma && (t.then.else = Z({ type: "Comma", syntax: e }, t, L));
  else
    for (let n2 = e.min || 1; n2 <= e.max; n2++)
      e.comma && t !== C && (t = Z({ type: "Comma", syntax: e }, t, L)), t = Z(r, Z(C, C, t), L);
  if (e.min === 0)
    t = Z(C, C, t);
  else
    for (let n2 = 0; n2 < e.min - 1; n2++)
      e.comma && t !== C && (t = Z({ type: "Comma", syntax: e }, t, L)), t = Z(r, t, L);
  return t;
}
function Fr(e) {
  if (typeof e == "function")
    return { type: "Generic", fn: e };
  switch (e.type) {
    case "Group": {
      let t = Rr(e.combinator, e.terms.map(Fr), false);
      return e.disallowEmpty && (t = Z(t, Kt, L)), t;
    }
    case "Multiplier":
      return Zl(e);
    case "Type":
    case "Property":
      return { type: e.type, name: e.name, syntax: e };
    case "Keyword":
      return { type: e.type, name: e.name.toLowerCase(), syntax: e };
    case "AtKeyword":
      return { type: e.type, name: "@" + e.name.toLowerCase(), syntax: e };
    case "Function":
      return { type: e.type, name: e.name.toLowerCase() + "(", syntax: e };
    case "String":
      return e.value.length === 3 ? { type: "Token", value: e.value.charAt(1), syntax: e } : { type: e.type, value: e.value.substr(1, e.value.length - 2).replace(/\\'/g, "'"), syntax: e };
    case "Token":
      return { type: e.type, value: e.value, syntax: e };
    case "Comma":
      return { type: e.type, syntax: e };
    default:
      throw new Error("Unknown node type:", e.type);
  }
}
function Qt(e, t) {
  return typeof e == "string" && (e = Ge(e)), { type: "MatchGraph", match: Fr(e), syntax: t || null, source: e };
}
var { hasOwnProperty: ta } = Object.prototype;
var Jl = 0;
var ec = 1;
var _r = 2;
var aa = 3;
var ra = "Match";
var tc = "Mismatch";
var rc = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
var na = 15e3;
var nc = 0;
function oc(e) {
  let t = null, r = null, n2 = e;
  for (; n2 !== null; )
    r = n2.prev, n2.prev = t, t = n2, n2 = r;
  return t;
}
function Br(e, t) {
  if (e.length !== t.length)
    return false;
  for (let r = 0; r < e.length; r++) {
    let n2 = t.charCodeAt(r), o = e.charCodeAt(r);
    if (o >= 65 && o <= 90 && (o = o | 32), o !== n2)
      return false;
  }
  return true;
}
function ic(e) {
  return e.type !== 9 ? false : e.value !== "?";
}
function oa(e) {
  return e === null ? true : e.type === 18 || e.type === 2 || e.type === 21 || e.type === 19 || e.type === 23 || ic(e);
}
function ia(e) {
  return e === null ? true : e.type === 22 || e.type === 20 || e.type === 24 || e.type === 9 && e.value === "/";
}
function ac(e, t, r) {
  function n2() {
    do
      R++, S = R < e.length ? e[R] : null;
    while (S !== null && (S.type === 13 || S.type === 25));
  }
  function o(ae) {
    let fe = R + ae;
    return fe < e.length ? e[fe] : null;
  }
  function i(ae, fe) {
    return { nextState: ae, matchStack: z, syntaxStack: p, thenStack: m, tokenIndex: R, prev: fe };
  }
  function s(ae) {
    m = { nextState: ae, matchStack: z, syntaxStack: p, prev: m };
  }
  function u(ae) {
    f = i(ae, f);
  }
  function c2() {
    z = { type: ec, syntax: t.syntax, token: S, prev: z }, n2(), P = null, R > ke && (ke = R);
  }
  function a() {
    p = { syntax: t.syntax, opts: t.syntax.opts || p !== null && p.opts || null, prev: p }, z = { type: _r, syntax: t.syntax, token: z.token, prev: z };
  }
  function l() {
    z.type === _r ? z = z.prev : z = { type: aa, syntax: p.syntax, token: z.token, prev: z }, p = p.prev;
  }
  let p = null, m = null, f = null, P = null, te = 0, X = null, S = null, R = -1, ke = 0, z = { type: Jl, syntax: null, token: null, prev: null };
  for (n2(); X === null && ++te < na; )
    switch (t.type) {
      case "Match":
        if (m === null) {
          if (S !== null && (R !== e.length - 1 || S.value !== "\\0" && S.value !== "\\9")) {
            t = L;
            break;
          }
          X = ra;
          break;
        }
        if (t = m.nextState, t === Kt)
          if (m.matchStack === z) {
            t = L;
            break;
          } else
            t = C;
        for (; m.syntaxStack !== p; )
          l();
        m = m.prev;
        break;
      case "Mismatch":
        if (P !== null && P !== false)
          (f === null || R > f.tokenIndex) && (f = P, P = false);
        else if (f === null) {
          X = tc;
          break;
        }
        t = f.nextState, m = f.thenStack, p = f.syntaxStack, z = f.matchStack, R = f.tokenIndex, S = R < e.length ? e[R] : null, f = f.prev;
        break;
      case "MatchGraph":
        t = t.match;
        break;
      case "If":
        t.else !== L && u(t.else), t.then !== C && s(t.then), t = t.match;
        break;
      case "MatchOnce":
        t = { type: "MatchOnceBuffer", syntax: t, index: 0, mask: 0 };
        break;
      case "MatchOnceBuffer": {
        let Q = t.syntax.terms;
        if (t.index === Q.length) {
          if (t.mask === 0 || t.syntax.all) {
            t = L;
            break;
          }
          t = C;
          break;
        }
        if (t.mask === (1 << Q.length) - 1) {
          t = C;
          break;
        }
        for (; t.index < Q.length; t.index++) {
          let J = 1 << t.index;
          if ((t.mask & J) === 0) {
            u(t), s({ type: "AddMatchOnce", syntax: t.syntax, mask: t.mask | J }), t = Q[t.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        t = { type: "MatchOnceBuffer", syntax: t.syntax, index: 0, mask: t.mask };
        break;
      case "Enum":
        if (S !== null) {
          let Q = S.value.toLowerCase();
          if (Q.indexOf("\\") !== -1 && (Q = Q.replace(/\\[09].*$/, "")), ta.call(t.map, Q)) {
            t = t.map[Q];
            break;
          }
        }
        t = L;
        break;
      case "Generic": {
        let Q = p !== null ? p.opts : null, J = R + Math.floor(t.fn(S, o, Q));
        if (!isNaN(J) && J > R) {
          for (; R < J; )
            c2();
          t = C;
        } else
          t = L;
        break;
      }
      case "Type":
      case "Property": {
        let Q = t.type === "Type" ? "types" : "properties", J = ta.call(r, Q) ? r[Q][t.name] : null;
        if (!J || !J.match)
          throw new Error("Bad syntax reference: " + (t.type === "Type" ? "<" + t.name + ">" : "<'" + t.name + "'>"));
        if (P !== false && S !== null && t.type === "Type" && (t.name === "custom-ident" && S.type === 1 || t.name === "length" && S.value === "0")) {
          P === null && (P = i(t, f)), t = L;
          break;
        }
        a(), t = J.match;
        break;
      }
      case "Keyword": {
        let Q = t.name;
        if (S !== null) {
          let J = S.value;
          if (J.indexOf("\\") !== -1 && (J = J.replace(/\\[09].*$/, "")), Br(J, Q)) {
            c2(), t = C;
            break;
          }
        }
        t = L;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (S !== null && Br(S.value, t.name)) {
          c2(), t = C;
          break;
        }
        t = L;
        break;
      case "Token":
        if (S !== null && S.value === t.value) {
          c2(), t = C;
          break;
        }
        t = L;
        break;
      case "Comma":
        S !== null && S.type === 18 ? oa(z.token) ? t = L : (c2(), t = ia(S) ? L : C) : t = oa(z.token) || ia(S) ? C : L;
        break;
      case "String":
        let ae = "", fe = R;
        for (; fe < e.length && ae.length < t.value.length; fe++)
          ae += e[fe].value;
        if (Br(ae, t.value)) {
          for (; R < fe; )
            c2();
          t = C;
        } else
          t = L;
        break;
      default:
        throw new Error("Unknown node type: " + t.type);
    }
  switch (nc += te, X) {
    case null:
      console.warn("[csstree-match] BREAK after " + na + " iterations"), X = rc, z = null;
      break;
    case ra:
      for (; p !== null; )
        l();
      break;
    default:
      z = null;
  }
  return { tokens: e, reason: X, iterations: te, match: z, longestMatch: ke };
}
function qr(e, t, r) {
  let n2 = ac(e, t, r || {});
  if (n2.match === null)
    return n2;
  let o = n2.match, i = n2.match = { syntax: t.syntax || null, match: [] }, s = [i];
  for (o = oc(o).prev; o !== null; ) {
    switch (o.type) {
      case _r:
        i.match.push(i = { syntax: o.syntax, match: [] }), s.push(i);
        break;
      case aa:
        s.pop(), i = s[s.length - 1];
        break;
      default:
        i.match.push({ syntax: o.syntax || null, token: o.token.value, node: o.token.node });
    }
    o = o.prev;
  }
  return n2;
}
var jr = {};
b(jr, { getTrace: () => sa, isKeyword: () => cc, isProperty: () => lc, isType: () => sc });
function sa(e) {
  function t(o) {
    return o === null ? false : o.type === "Type" || o.type === "Property" || o.type === "Keyword";
  }
  function r(o) {
    if (Array.isArray(o.match)) {
      for (let i = 0; i < o.match.length; i++)
        if (r(o.match[i]))
          return t(o.syntax) && n2.unshift(o.syntax), true;
    } else if (o.node === e)
      return n2 = t(o.syntax) ? [o.syntax] : [], true;
    return false;
  }
  let n2 = null;
  return this.matched !== null && r(this.matched), n2;
}
function sc(e, t) {
  return Ur(this, e, (r) => r.type === "Type" && r.name === t);
}
function lc(e, t) {
  return Ur(this, e, (r) => r.type === "Property" && r.name === t);
}
function cc(e) {
  return Ur(this, e, (t) => t.type === "Keyword");
}
function Ur(e, t, r) {
  let n2 = sa.call(e, t);
  return n2 === null ? false : n2.some(r);
}
function la(e) {
  return "node" in e ? e.node : la(e.match[0]);
}
function ca(e) {
  return "node" in e ? e.node : ca(e.match[e.match.length - 1]);
}
function Wr(e, t, r, n2, o) {
  function i(u) {
    if (u.syntax !== null && u.syntax.type === n2 && u.syntax.name === o) {
      let c2 = la(u), a = ca(u);
      e.syntax.walk(t, function(l, p, m) {
        if (l === c2) {
          let f = new D();
          do {
            if (f.appendData(p.data), p.data === a)
              break;
            p = p.next;
          } while (p !== null);
          s.push({ parent: m, nodes: f });
        }
      });
    }
    Array.isArray(u.match) && u.match.forEach(i);
  }
  let s = [];
  return r.matched !== null && i(r.matched), s;
}
var { hasOwnProperty: ht } = Object.prototype;
function Hr(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e && e >= 0;
}
function ua(e) {
  return Boolean(e) && Hr(e.offset) && Hr(e.line) && Hr(e.column);
}
function uc(e, t) {
  return function(n2, o) {
    if (!n2 || n2.constructor !== Object)
      return o(n2, "Type of node should be an Object");
    for (let i in n2) {
      let s = true;
      if (ht.call(n2, i) !== false) {
        if (i === "type")
          n2.type !== e && o(n2, "Wrong node type `" + n2.type + "`, expected `" + e + "`");
        else if (i === "loc") {
          if (n2.loc === null)
            continue;
          if (n2.loc && n2.loc.constructor === Object)
            if (typeof n2.loc.source != "string")
              i += ".source";
            else if (!ua(n2.loc.start))
              i += ".start";
            else if (!ua(n2.loc.end))
              i += ".end";
            else
              continue;
          s = false;
        } else if (t.hasOwnProperty(i)) {
          s = false;
          for (let u = 0; !s && u < t[i].length; u++) {
            let c2 = t[i][u];
            switch (c2) {
              case String:
                s = typeof n2[i] == "string";
                break;
              case Boolean:
                s = typeof n2[i] == "boolean";
                break;
              case null:
                s = n2[i] === null;
                break;
              default:
                typeof c2 == "string" ? s = n2[i] && n2[i].type === c2 : Array.isArray(c2) && (s = n2[i] instanceof D);
            }
          }
        } else
          o(n2, "Unknown field `" + i + "` for " + e + " node type");
        s || o(n2, "Bad value for `" + e + "." + i + "`");
      }
    }
    for (let i in t)
      ht.call(t, i) && ht.call(n2, i) === false && o(n2, "Field `" + e + "." + i + "` is missed");
  };
}
function pc(e, t) {
  let r = t.structure, n2 = { type: String, loc: true }, o = { type: '"' + e + '"' };
  for (let i in r) {
    if (ht.call(r, i) === false)
      continue;
    let s = [], u = n2[i] = Array.isArray(r[i]) ? r[i].slice() : [r[i]];
    for (let c2 = 0; c2 < u.length; c2++) {
      let a = u[c2];
      if (a === String || a === Boolean)
        s.push(a.name);
      else if (a === null)
        s.push("null");
      else if (typeof a == "string")
        s.push("<" + a + ">");
      else if (Array.isArray(a))
        s.push("List");
      else
        throw new Error("Wrong value `" + a + "` in `" + e + "." + i + "` structure definition");
    }
    o[i] = s.join(" | ");
  }
  return { docs: o, check: uc(e, n2) };
}
function pa(e) {
  let t = {};
  if (e.node) {
    for (let r in e.node)
      if (ht.call(e.node, r)) {
        let n2 = e.node[r];
        if (n2.structure)
          t[r] = pc(r, n2);
        else
          throw new Error("Missed `structure` field in `" + r + "` node type definition");
      }
  }
  return t;
}
var hc = Qt(Rt.join(" | "));
function Yr(e, t, r) {
  let n2 = {};
  for (let o in e)
    e[o].syntax && (n2[o] = r ? e[o].syntax : Pe(e[o].syntax, { compact: t }));
  return n2;
}
function mc(e, t, r) {
  let n2 = {};
  for (let [o, i] of Object.entries(e))
    n2[o] = { prelude: i.prelude && (r ? i.prelude.syntax : Pe(i.prelude.syntax, { compact: t })), descriptors: i.descriptors && Yr(i.descriptors, t, r) };
  return n2;
}
function fc(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t].value.toLowerCase() === "var(")
      return true;
  return false;
}
function ce(e, t, r) {
  return { matched: e, iterations: r, error: t, ...jr };
}
function Ve(e, t, r, n2) {
  let o = Zi(r, e.syntax), i;
  return fc(o) ? ce(null, new Error("Matching for a tree with var() is not supported")) : (n2 && (i = qr(o, e.cssWideKeywordsSyntax, e)), (!n2 || !i.match) && (i = qr(o, t.match, e), !i.match) ? ce(null, new Ii(i.reason, t.syntax, r, i), i.iterations) : ce(i.match, null, i.iterations));
}
var Ke = class {
  constructor(t, r, n2) {
    if (this.cssWideKeywordsSyntax = hc, this.syntax = r, this.generic = false, this.units = { ..._t }, this.atrules = /* @__PURE__ */ Object.create(null), this.properties = /* @__PURE__ */ Object.create(null), this.types = /* @__PURE__ */ Object.create(null), this.structure = n2 || pa(t), t) {
      if (t.units)
        for (let o of Object.keys(_t))
          Array.isArray(t.units[o]) && (this.units[o] = t.units[o]);
      if (t.types)
        for (let o in t.types)
          this.addType_(o, t.types[o]);
      if (t.generic) {
        this.generic = true;
        for (let [o, i] of Object.entries(Fi(this.units)))
          this.addType_(o, i);
      }
      if (t.atrules)
        for (let o in t.atrules)
          this.addAtrule_(o, t.atrules[o]);
      if (t.properties)
        for (let o in t.properties)
          this.addProperty_(o, t.properties[o]);
    }
  }
  checkStructure(t) {
    function r(i, s) {
      o.push({ node: i, message: s });
    }
    let n2 = this.structure, o = [];
    return this.syntax.walk(t, function(i) {
      n2.hasOwnProperty(i.type) ? n2[i.type].check(i, r) : r(i, "Unknown node type `" + i.type + "`");
    }), o.length ? o : false;
  }
  createDescriptor(t, r, n2, o = null) {
    let i = { type: r, name: n2 }, s = { type: r, name: n2, parent: o, serializable: typeof t == "string" || t && typeof t.type == "string", syntax: null, match: null };
    return typeof t == "function" ? s.match = Qt(t, i) : (typeof t == "string" ? Object.defineProperty(s, "syntax", { get() {
      return Object.defineProperty(s, "syntax", { value: Ge(t) }), s.syntax;
    } }) : s.syntax = t, Object.defineProperty(s, "match", { get() {
      return Object.defineProperty(s, "match", { value: Qt(s.syntax, i) }), s.match;
    } })), s;
  }
  addAtrule_(t, r) {
    !r || (this.atrules[t] = { type: "Atrule", name: t, prelude: r.prelude ? this.createDescriptor(r.prelude, "AtrulePrelude", t) : null, descriptors: r.descriptors ? Object.keys(r.descriptors).reduce((n2, o) => (n2[o] = this.createDescriptor(r.descriptors[o], "AtruleDescriptor", o, t), n2), /* @__PURE__ */ Object.create(null)) : null });
  }
  addProperty_(t, r) {
    !r || (this.properties[t] = this.createDescriptor(r, "Property", t));
  }
  addType_(t, r) {
    !r || (this.types[t] = this.createDescriptor(r, "Type", t));
  }
  checkAtruleName(t) {
    if (!this.getAtrule(t))
      return new Ue("Unknown at-rule", "@" + t);
  }
  checkAtrulePrelude(t, r) {
    let n2 = this.checkAtruleName(t);
    if (n2)
      return n2;
    let o = this.getAtrule(t);
    if (!o.prelude && r)
      return new SyntaxError("At-rule `@" + t + "` should not contain a prelude");
    if (o.prelude && !r && !Ve(this, o.prelude, "", false).matched)
      return new SyntaxError("At-rule `@" + t + "` should contain a prelude");
  }
  checkAtruleDescriptorName(t, r) {
    let n2 = this.checkAtruleName(t);
    if (n2)
      return n2;
    let o = this.getAtrule(t), i = zt(r);
    if (!o.descriptors)
      return new SyntaxError("At-rule `@" + t + "` has no known descriptors");
    if (!o.descriptors[i.name] && !o.descriptors[i.basename])
      return new Ue("Unknown at-rule descriptor", r);
  }
  checkPropertyName(t) {
    if (!this.getProperty(t))
      return new Ue("Unknown property", t);
  }
  matchAtrulePrelude(t, r) {
    let n2 = this.checkAtrulePrelude(t, r);
    if (n2)
      return ce(null, n2);
    let o = this.getAtrule(t);
    return o.prelude ? Ve(this, o.prelude, r || "", false) : ce(null, null);
  }
  matchAtruleDescriptor(t, r, n2) {
    let o = this.checkAtruleDescriptorName(t, r);
    if (o)
      return ce(null, o);
    let i = this.getAtrule(t), s = zt(r);
    return Ve(this, i.descriptors[s.name] || i.descriptors[s.basename], n2, false);
  }
  matchDeclaration(t) {
    return t.type !== "Declaration" ? ce(null, new Error("Not a Declaration node")) : this.matchProperty(t.property, t.value);
  }
  matchProperty(t, r) {
    if (kr(t).custom)
      return ce(null, new Error("Lexer matching doesn't applicable for custom properties"));
    let n2 = this.checkPropertyName(t);
    return n2 ? ce(null, n2) : Ve(this, this.getProperty(t), r, true);
  }
  matchType(t, r) {
    let n2 = this.getType(t);
    return n2 ? Ve(this, n2, r, false) : ce(null, new Ue("Unknown type", t));
  }
  match(t, r) {
    return typeof t != "string" && (!t || !t.type) ? ce(null, new Ue("Bad syntax")) : ((typeof t == "string" || !t.match) && (t = this.createDescriptor(t, "Type", "anonymous")), Ve(this, t, r, false));
  }
  findValueFragments(t, r, n2, o) {
    return Wr(this, r, this.matchProperty(t, r), n2, o);
  }
  findDeclarationValueFragments(t, r, n2) {
    return Wr(this, t.value, this.matchDeclaration(t), r, n2);
  }
  findAllFragments(t, r, n2) {
    let o = [];
    return this.syntax.walk(t, { visit: "Declaration", enter: (i) => {
      o.push.apply(o, this.findDeclarationValueFragments(i, r, n2));
    } }), o;
  }
  getAtrule(t, r = true) {
    let n2 = zt(t);
    return (n2.vendor && r ? this.atrules[n2.name] || this.atrules[n2.basename] : this.atrules[n2.name]) || null;
  }
  getAtrulePrelude(t, r = true) {
    let n2 = this.getAtrule(t, r);
    return n2 && n2.prelude || null;
  }
  getAtruleDescriptor(t, r) {
    return this.atrules.hasOwnProperty(t) && this.atrules.declarators && this.atrules[t].declarators[r] || null;
  }
  getProperty(t, r = true) {
    let n2 = kr(t);
    return (n2.vendor && r ? this.properties[n2.name] || this.properties[n2.basename] : this.properties[n2.name]) || null;
  }
  getType(t) {
    return hasOwnProperty.call(this.types, t) ? this.types[t] : null;
  }
  validate() {
    function t(o, i, s, u) {
      if (s.has(i))
        return s.get(i);
      s.set(i, false), u.syntax !== null && Vt(u.syntax, function(c2) {
        if (c2.type !== "Type" && c2.type !== "Property")
          return;
        let a = c2.type === "Type" ? o.types : o.properties, l = c2.type === "Type" ? r : n2;
        (!hasOwnProperty.call(a, c2.name) || t(o, c2.name, l, a[c2.name])) && s.set(i, true);
      }, this);
    }
    let r = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map();
    for (let o in this.types)
      t(this, o, r, this.types[o]);
    for (let o in this.properties)
      t(this, o, n2, this.properties[o]);
    return r = [...r.keys()].filter((o) => r.get(o)), n2 = [...n2.keys()].filter((o) => n2.get(o)), r.length || n2.length ? { types: r, properties: n2 } : null;
  }
  dump(t, r) {
    return { generic: this.generic, units: this.units, types: Yr(this.types, !r, t), properties: Yr(this.properties, !r, t), atrules: mc(this.atrules, !r, t) };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
};
function Gr(e, t) {
  return typeof t == "string" && /^\s*\|/.test(t) ? typeof e == "string" ? e + t : t.replace(/^\s*\|\s*/, "") : t || null;
}
function ha(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let [n2, o] of Object.entries(e))
    if (o) {
      r[n2] = {};
      for (let i of Object.keys(o))
        t.includes(i) && (r[n2][i] = o[i]);
    }
  return r;
}
function mt(e, t) {
  let r = { ...e };
  for (let [n2, o] of Object.entries(t))
    switch (n2) {
      case "generic":
        r[n2] = Boolean(o);
        break;
      case "units":
        r[n2] = { ...e[n2] };
        for (let [i, s] of Object.entries(o))
          r[n2][i] = Array.isArray(s) ? s : [];
        break;
      case "atrules":
        r[n2] = { ...e[n2] };
        for (let [i, s] of Object.entries(o)) {
          let u = r[n2][i] || {}, c2 = r[n2][i] = { prelude: u.prelude || null, descriptors: { ...u.descriptors } };
          if (!!s) {
            c2.prelude = s.prelude ? Gr(c2.prelude, s.prelude) : c2.prelude || null;
            for (let [a, l] of Object.entries(s.descriptors || {}))
              c2.descriptors[a] = l ? Gr(c2.descriptors[a], l) : null;
            Object.keys(c2.descriptors).length || (c2.descriptors = null);
          }
        }
        break;
      case "types":
      case "properties":
        r[n2] = { ...e[n2] };
        for (let [i, s] of Object.entries(o))
          r[n2][i] = Gr(r[n2][i], s);
        break;
      case "scope":
        r[n2] = { ...e[n2] };
        for (let [i, s] of Object.entries(o))
          r[n2][i] = { ...r[n2][i], ...s };
        break;
      case "parseContext":
        r[n2] = { ...e[n2], ...o };
        break;
      case "atrule":
      case "pseudo":
        r[n2] = { ...e[n2], ...ha(o, ["parse"]) };
        break;
      case "node":
        r[n2] = { ...e[n2], ...ha(o, ["name", "structure", "parse", "generate", "walkContext"]) };
        break;
    }
  return r;
}
function ma(e) {
  let t = $o(e), r = Li(e), n2 = vi(e), { fromPlainObject: o, toPlainObject: i } = Si(r), s = { lexer: null, createLexer: (u) => new Ke(u, s, s.lexer.structure), tokenize: ve, parse: t, generate: n2, walk: r, find: r.find, findLast: r.findLast, findAll: r.findAll, fromPlainObject: o, toPlainObject: i, fork(u) {
    let c2 = mt({}, e);
    return ma(typeof u == "function" ? u(c2, Object.assign) : mt(c2, u));
  } };
  return s.lexer = new Ke({ generic: true, units: e.units, types: e.types, atrules: e.atrules, properties: e.properties, node: e.node }, s), s;
}
var Vr = (e) => ma(mt({}, e));
var fa = { generic: true, units: { angle: ["deg", "grad", "rad", "turn"], decibel: ["db"], flex: ["fr"], frequency: ["hz", "khz"], length: ["cm", "mm", "q", "in", "pt", "pc", "px", "em", "rem", "ex", "rex", "cap", "rcap", "ch", "rch", "ic", "ric", "lh", "rlh", "vw", "svw", "lvw", "dvw", "vh", "svh", "lvh", "dvh", "vi", "svi", "lvi", "dvi", "vb", "svb", "lvb", "dvb", "vmin", "svmin", "lvmin", "dvmin", "vmax", "svmax", "lvmax", "dvmax", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"], resolution: ["dpi", "dpcm", "dppx", "x"], semitones: ["st"], time: ["s", "ms"] }, types: { "abs()": "abs( <calc-sum> )", "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large", "acos()": "acos( <calc-sum> )", "alpha-value": "<number>|<percentage>", "angle-percentage": "<angle>|<percentage>", "angular-color-hint": "<angle-percentage>", "angular-color-stop": "<color>&&<color-stop-angle>?", "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>", "animateable-feature": "scroll-position|contents|<custom-ident>", "asin()": "asin( <calc-sum> )", "atan()": "atan( <calc-sum> )", "atan2()": "atan2( <calc-sum> , <calc-sum> )", attachment: "scroll|fixed|local", "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )", "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='", "attr-modifier": "i|s", "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'", "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )", "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?", axis: "block|inline|vertical|horizontal", "baseline-position": "[first|last]? baseline", "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>", "bg-image": "none|<image>", "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]", "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain", "blur()": "blur( <length> )", "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity", box: "border-box|padding-box|content-box", "brightness()": "brightness( <number-percentage> )", "calc()": "calc( <calc-sum> )", "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*", "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*", "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )", "calc-constant": "e|pi|infinity|-infinity|NaN", "cf-final-image": "<image>|<color>", "cf-mixing-image": "<percentage>?&&<image>", "circle()": "circle( [<shape-radius>]? [at <position>]? )", "clamp()": "clamp( <calc-sum>#{3} )", "class-selector": "'.' <ident-token>", "clip-source": "<url>", color: "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>", "color-stop": "<color-stop-length>|<color-stop-angle>", "color-stop-angle": "<angle-percentage>{1,2}", "color-stop-length": "<length-percentage>{1,2}", "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>", combinator: "'>'|'+'|'~'|['||']", "common-lig-values": "[common-ligatures|no-common-ligatures]", "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button", "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor", "compositing-operator": "add|subtract|intersect|exclude", "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!", "compound-selector-list": "<compound-selector>#", "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*", "complex-selector-list": "<complex-selector>#", "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "contextual-alt-values": "[contextual|no-contextual]", "content-distribution": "space-between|space-around|space-evenly|stretch", "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+", "content-position": "center|start|end|flex-start|flex-end", "content-replacement": "<image>", "contrast()": "contrast( [<number-percentage>] )", "cos()": "cos( <calc-sum> )", counter: "<counter()>|<counters()>", "counter()": "counter( <counter-name> , <counter-style>? )", "counter-name": "<custom-ident>", "counter-style": "<counter-style-name>|symbols( )", "counter-style-name": "<custom-ident>", "counters()": "counters( <counter-name> , <string> , <counter-style>? )", "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )", "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )", "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText", "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]", "display-box": "contents|none", "display-inside": "flow|flow-root|table|flex|grid|ruby", "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container", "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid", "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item", "display-outside": "block|inline|run-in", "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )", "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]", "east-asian-width-values": "[full-width|proportional-width]", "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )", "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )", "ending-shape": "circle|ellipse", "env()": "env( <custom-ident> , <declaration-value>? )", "exp()": "exp( <calc-sum> )", "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?", "family-name": "<string>|<custom-ident>+", "feature-tag-value": "<string> [<integer>|on|off]?", "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation", "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'", "feature-value-block-list": "<feature-value-block>+", "feature-value-declaration": "<custom-ident> : <integer>+ ;", "feature-value-declaration-list": "<feature-value-declaration>", "feature-value-name": "<custom-ident>", "fill-rule": "nonzero|evenodd", "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>", "filter-function-list": "[<filter-function>|<url>]+", "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>", "fixed-breadth": "<length-percentage>", "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )", "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )", "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>", "font-variant-css21": "[normal|small-caps]", "font-weight-absolute": "normal|bold|<number [1,1000]>", "frequency-percentage": "<frequency>|<percentage>", "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )", "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system", "generic-name": "serif|sans-serif|cursive|fantasy|monospace", "geometry-box": "<shape-box>|fill-box|stroke-box|view-box", gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>", "grayscale()": "grayscale( <number-percentage> )", "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]", "historical-lig-values": "[historical-ligatures|no-historical-ligatures]", "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )", "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )", hue: "<number>|<angle>", "hue-rotate()": "hue-rotate( <angle> )", "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )", "hypot()": "hypot( <calc-sum># )", image: "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>", "image()": "image( <image-tags>? [<image-src>? , <color>?]! )", "image-set()": "image-set( <image-set-option># )", "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]", "image-src": "<url>|<string>", "image-tags": "ltr|rtl", "inflexible-breadth": "<length-percentage>|min-content|max-content|auto", "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )", "invert()": "invert( <number-percentage> )", "keyframes-name": "<custom-ident>|<string>", "keyframe-block": "<keyframe-selector># { <declaration-list> }", "keyframe-block-list": "<keyframe-block>+", "keyframe-selector": "from|to|<percentage>", "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )", "layer()": "layer( <layer-name> )", "layer-name": "<ident> ['.' <ident>]*", "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )", "leader()": "leader( <leader-type> )", "leader-type": "dotted|solid|space|<string>", "length-percentage": "<length>|<percentage>", "line-names": "'[' <custom-ident>* ']'", "line-name-list": "[<line-names>|<name-repeat>]+", "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset", "line-width": "<length>|thin|medium|thick", "linear-color-hint": "<length-percentage>", "linear-color-stop": "<color> <color-stop-length>?", "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "log()": "log( <calc-sum> , <calc-sum>? )", "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>", "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?", "mask-reference": "none|<image>|<mask-source>", "mask-source": "<url>", "masking-mode": "alpha|luminance|match-source", "matrix()": "matrix( <number>#{6} )", "matrix3d()": "matrix3d( <number>#{16} )", "max()": "max( <calc-sum># )", "media-and": "<media-in-parens> [and <media-in-parens>]+", "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>", "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>", "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )", "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>", "media-not": "not <media-in-parens>", "media-or": "<media-in-parens> [or <media-in-parens>]+", "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?", "media-query-list": "<media-query>#", "media-type": "<ident>", "mf-boolean": "<mf-name>", "mf-name": "<ident>", "mf-plain": "<mf-name> : <mf-value>", "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>", "mf-value": "<number>|<dimension>|<ident>|<ratio>", "min()": "min( <calc-sum># )", "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )", "mod()": "mod( <calc-sum> , <calc-sum> )", "name-repeat": "repeat( [<integer [1,\u221E]>|auto-fill] , <line-names>+ )", "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>", "namespace-prefix": "<ident>", "ns-prefix": "[<ident-token>|'*']? '|'", "number-percentage": "<number>|<percentage>", "numeric-figure-values": "[lining-nums|oldstyle-nums]", "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]", "numeric-spacing-values": "[proportional-nums|tabular-nums]", nth: "<an-plus-b>|even|odd", "opacity()": "opacity( [<number-percentage>] )", "overflow-position": "unsafe|safe", "outline-radius": "<length>|<percentage>", "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>", "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'", "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom", "page-selector-list": "[<page-selector>#]?", "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*", "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger", "path()": "path( [<fill-rule> ,]? <string> )", "paint()": "paint( <ident> , <declaration-value>? )", "perspective()": "perspective( [<length [0,\u221E]>|none] )", "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )", position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]", "pow()": "pow( <calc-sum> , <calc-sum> )", "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'", "pseudo-element-selector": "':' <pseudo-class-selector>", "pseudo-page": ": [left|right|first|blank]", quote: "open-quote|close-quote|no-open-quote|no-close-quote", "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", ratio: "<number [0,\u221E]> [/ <number [0,\u221E]>]?", "relative-selector": "<combinator>? <complex-selector>", "relative-selector-list": "<relative-selector>#", "relative-size": "larger|smaller", "rem()": "rem( <calc-sum> , <calc-sum> )", "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}", "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )", "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )", "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )", "reversed-counter-name": "reversed( <counter-name> )", "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )", "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )", "rotate()": "rotate( [<angle>|<zero>] )", "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )", "rotateX()": "rotateX( [<angle>|<zero>] )", "rotateY()": "rotateY( [<angle>|<zero>] )", "rotateZ()": "rotateZ( [<angle>|<zero>] )", "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )", "rounding-strategy": "nearest|up|down|to-zero", "saturate()": "saturate( <number-percentage> )", "scale()": "scale( [<number>|<percentage>]#{1,2} )", "scale3d()": "scale3d( [<number>|<percentage>]#{3} )", "scaleX()": "scaleX( [<number>|<percentage>] )", "scaleY()": "scaleY( [<number>|<percentage>] )", "scaleZ()": "scaleZ( [<number>|<percentage>] )", scroller: "root|nearest", "self-position": "center|start|end|self-start|self-end|flex-start|flex-end", "shape-radius": "<length-percentage>|closest-side|farthest-side", "sign()": "sign( <calc-sum> )", "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )", "skewX()": "skewX( [<angle>|<zero>] )", "skewY()": "skewY( [<angle>|<zero>] )", "sepia()": "sepia( <number-percentage> )", shadow: "inset?&&<length>{2,4}&&<color>?", "shadow-t": "[<length>{2,3}&&<color>?]", shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )", "shape-box": "<box>|margin-box", "side-or-corner": "[left|right]||[top|bottom]", "sin()": "sin( <calc-sum> )", "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]", "single-animation-direction": "normal|reverse|alternate|alternate-reverse", "single-animation-fill-mode": "none|forwards|backwards|both", "single-animation-iteration-count": "infinite|<number>", "single-animation-play-state": "running|paused", "single-animation-timeline": "auto|none|<timeline-name>|scroll( <axis>? <scroller>? )", "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>", "single-transition-property": "all|<custom-ident>", size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}", "sqrt()": "sqrt( <calc-sum> )", "step-position": "jump-start|jump-end|jump-none|jump-both|start|end", "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )", "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>", "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*", "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>", "supports-feature": "<supports-decl>|<supports-selector-fn>", "supports-decl": "( <declaration> )", "supports-selector-fn": "selector( <complex-selector> )", symbol: "<string>|<image>|<custom-ident>", "tan()": "tan( <calc-sum> )", target: "<target-counter()>|<target-counters()>|<target-text()>", "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )", "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )", "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )", "time-percentage": "<time>|<percentage>", "timeline-name": "<custom-ident>|<string>", "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>", "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto", "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?", "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )", "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )", "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>", "transform-list": "<transform-function>+", "translate()": "translate( <length-percentage> , <length-percentage>? )", "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )", "translateX()": "translateX( <length-percentage> )", "translateY()": "translateY( <length-percentage> )", "translateZ()": "translateZ( <length> )", "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%", "type-selector": "<wq-name>|<ns-prefix>? '*'", "var()": "var( <custom-property-name> , <declaration-value>? )", "viewport-length": "auto|<length-percentage>", "visual-box": "content-box|padding-box|border-box", "wq-name": "<ns-prefix>? <ident-token>", "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>", "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )", "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>", "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )", "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>", "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover", "-legacy-radial-gradient-shape": "circle|ellipse", "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body", "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text", "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast", "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable", "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content", "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )", "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )", "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]", "-webkit-gradient-radius": "<length>|<percentage>", "-webkit-gradient-type": "linear|radial", "-webkit-mask-box-repeat": "repeat|stretch|round", "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text", "-ms-filter-function-list": "<-ms-filter-function>+", "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>", "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]", "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )", "-ms-filter": "<string>", age: "child|young|old", "attr-name": "<wq-name>", "attr-fallback": "<any-value>", "bg-clip": "<box>|border|text", bottom: "<length>|auto", "container-name": "<custom-ident>", "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]", "generic-voice": "[<age>? <gender> <integer>?]", gender: "male|female|neutral", left: "<length>|auto", "mask-image": "<mask-reference>#", paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke", right: "<length>|auto", "scroll-timeline-axis": "block|inline|vertical|horizontal", "scroll-timeline-name": "none|<custom-ident>", "single-animation-composition": "replace|add|accumulate", "svg-length": "<percentage>|<length>|<number>", "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb", top: "<length>|auto", x: "<number>", y: "<number>", declaration: "<ident-token> : <declaration-value>? ['!' important]?", "declaration-list": "[<declaration>? ';']* <declaration>?", url: "url( <string> <url-modifier>* )|<url-token>", "url-modifier": "<ident>|<function-token> <any-value> )", "number-zero-one": "<number [0,1]>", "number-one-or-greater": "<number [1,\u221E]>", "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>", "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>", "style-feature": "<declaration>", "style-query": "<style-condition>|<style-feature>", "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]", "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>", "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box" }, properties: { "--*": "<declaration-value>", "-ms-accelerator": "false|true", "-ms-block-progression": "tb|rl|bt|lr", "-ms-content-zoom-chaining": "none|chained", "-ms-content-zooming": "none|zoom", "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>", "-ms-content-zoom-limit-max": "<percentage>", "-ms-content-zoom-limit-min": "<percentage>", "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>", "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )", "-ms-content-zoom-snap-type": "none|proximity|mandatory", "-ms-filter": "<string>", "-ms-flow-from": "[none|<custom-ident>]#", "-ms-flow-into": "[none|<custom-ident>]#", "-ms-grid-columns": "none|<track-list>|<auto-track-list>", "-ms-grid-rows": "none|<track-list>|<auto-track-list>", "-ms-high-contrast-adjust": "auto|none", "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}", "-ms-hyphenate-limit-lines": "no-limit|<integer>", "-ms-hyphenate-limit-zone": "<percentage>|<length>", "-ms-ime-align": "auto|after", "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar", "-ms-scrollbar-3dlight-color": "<color>", "-ms-scrollbar-arrow-color": "<color>", "-ms-scrollbar-base-color": "<color>", "-ms-scrollbar-darkshadow-color": "<color>", "-ms-scrollbar-face-color": "<color>", "-ms-scrollbar-highlight-color": "<color>", "-ms-scrollbar-shadow-color": "<color>", "-ms-scrollbar-track-color": "<color>", "-ms-scroll-chaining": "chained|none", "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>", "-ms-scroll-limit-x-max": "auto|<length>", "-ms-scroll-limit-x-min": "<length>", "-ms-scroll-limit-y-max": "auto|<length>", "-ms-scroll-limit-y-min": "<length>", "-ms-scroll-rails": "none|railed", "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )", "-ms-scroll-snap-type": "none|proximity|mandatory", "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>", "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>", "-ms-scroll-translation": "none|vertical-to-horizontal", "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space", "-ms-touch-select": "grippers|none", "-ms-user-select": "none|element|text", "-ms-wrap-flow": "auto|both|start|end|maximum|clear", "-ms-wrap-margin": "<length>", "-ms-wrap-through": "wrap|none", "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized", "-moz-binding": "<url>|none", "-moz-border-bottom-colors": "<color>+|none", "-moz-border-left-colors": "<color>+|none", "-moz-border-right-colors": "<color>+|none", "-moz-border-top-colors": "<color>+|none", "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#", "-moz-float-edge": "border-box|content-box|margin-box|padding-box", "-moz-force-broken-image-icon": "0|1", "-moz-image-region": "<shape>|auto", "-moz-orient": "inline|block|horizontal|vertical", "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?", "-moz-outline-radius-bottomleft": "<outline-radius>", "-moz-outline-radius-bottomright": "<outline-radius>", "-moz-outline-radius-topleft": "<outline-radius>", "-moz-outline-radius-topright": "<outline-radius>", "-moz-stack-sizing": "ignore|stretch-to-fit", "-moz-text-blink": "none|blink", "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none", "-moz-user-input": "auto|none|enabled|disabled", "-moz-user-modify": "read-only|read-write|write-only", "-moz-window-dragging": "drag|no-drag", "-moz-window-shadow": "default|menu|tooltip|sheet|none", "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button", "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>", "-webkit-border-before-color": "<color>", "-webkit-border-before-style": "<'border-style'>", "-webkit-border-before-width": "<'border-width'>", "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?", "-webkit-line-clamp": "none|<integer>", "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#", "-webkit-mask-attachment": "<attachment>#", "-webkit-mask-clip": "[<box>|border|padding|content|text]#", "-webkit-mask-composite": "<composite-style>#", "-webkit-mask-image": "<mask-reference>#", "-webkit-mask-origin": "[<box>|border|padding|content]#", "-webkit-mask-position": "<position>#", "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#", "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#", "-webkit-mask-repeat": "<repeat-style>#", "-webkit-mask-repeat-x": "repeat|no-repeat|space|round", "-webkit-mask-repeat-y": "repeat|no-repeat|space|round", "-webkit-mask-size": "<bg-size>#", "-webkit-overflow-scrolling": "auto|touch", "-webkit-tap-highlight-color": "<color>", "-webkit-text-fill-color": "<color>", "-webkit-text-stroke": "<length>||<color>", "-webkit-text-stroke-color": "<color>", "-webkit-text-stroke-width": "<length>", "-webkit-touch-callout": "default|none", "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only", "accent-color": "auto|<color>", "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>", "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]", "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>", "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#", all: "initial|inherit|unset|revert|revert-layer", animation: "<single-animation>#", "animation-composition": "<single-animation-composition>#", "animation-delay": "<time>#", "animation-direction": "<single-animation-direction>#", "animation-duration": "<time>#", "animation-fill-mode": "<single-animation-fill-mode>#", "animation-iteration-count": "<single-animation-iteration-count>#", "animation-name": "[none|<keyframes-name>]#", "animation-play-state": "<single-animation-play-state>#", "animation-timing-function": "<easing-function>#", "animation-timeline": "<single-animation-timeline>#", appearance: "none|auto|textfield|menulist-button|<compat-auto>", "aspect-ratio": "auto|<ratio>", azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards", "backdrop-filter": "none|<filter-function-list>", "backface-visibility": "visible|hidden", background: "[<bg-layer> ,]* <final-bg-layer>", "background-attachment": "<attachment>#", "background-blend-mode": "<blend-mode>#", "background-clip": "<bg-clip>#", "background-color": "<color>", "background-image": "<bg-image>#", "background-origin": "<box>#", "background-position": "<bg-position>#", "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#", "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#", "background-repeat": "<repeat-style>#", "background-size": "<bg-size>#", "block-overflow": "clip|ellipsis|<string>", "block-size": "<'width'>", border: "<line-width>||<line-style>||<color>", "border-block": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-color": "<'border-top-color'>{1,2}", "border-block-style": "<'border-top-style'>", "border-block-width": "<'border-top-width'>", "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-end-color": "<'border-top-color'>", "border-block-end-style": "<'border-top-style'>", "border-block-end-width": "<'border-top-width'>", "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-block-start-color": "<'border-top-color'>", "border-block-start-style": "<'border-top-style'>", "border-block-start-width": "<'border-top-width'>", "border-bottom": "<line-width>||<line-style>||<color>", "border-bottom-color": "<'border-top-color'>", "border-bottom-left-radius": "<length-percentage>{1,2}", "border-bottom-right-radius": "<length-percentage>{1,2}", "border-bottom-style": "<line-style>", "border-bottom-width": "<line-width>", "border-collapse": "collapse|separate", "border-color": "<color>{1,4}", "border-end-end-radius": "<length-percentage>{1,2}", "border-end-start-radius": "<length-percentage>{1,2}", "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>", "border-image-outset": "[<length>|<number>]{1,4}", "border-image-repeat": "[stretch|repeat|round|space]{1,2}", "border-image-slice": "<number-percentage>{1,4}&&fill?", "border-image-source": "none|<image>", "border-image-width": "[<length-percentage>|<number>|auto]{1,4}", "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-color": "<'border-top-color'>{1,2}", "border-inline-style": "<'border-top-style'>", "border-inline-width": "<'border-top-width'>", "border-inline-end-color": "<'border-top-color'>", "border-inline-end-style": "<'border-top-style'>", "border-inline-end-width": "<'border-top-width'>", "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>", "border-inline-start-color": "<'border-top-color'>", "border-inline-start-style": "<'border-top-style'>", "border-inline-start-width": "<'border-top-width'>", "border-left": "<line-width>||<line-style>||<color>", "border-left-color": "<color>", "border-left-style": "<line-style>", "border-left-width": "<line-width>", "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?", "border-right": "<line-width>||<line-style>||<color>", "border-right-color": "<color>", "border-right-style": "<line-style>", "border-right-width": "<line-width>", "border-spacing": "<length> <length>?", "border-start-end-radius": "<length-percentage>{1,2}", "border-start-start-radius": "<length-percentage>{1,2}", "border-style": "<line-style>{1,4}", "border-top": "<line-width>||<line-style>||<color>", "border-top-color": "<color>", "border-top-left-radius": "<length-percentage>{1,2}", "border-top-right-radius": "<length-percentage>{1,2}", "border-top-style": "<line-style>", "border-top-width": "<line-width>", "border-width": "<line-width>{1,4}", bottom: "<length>|<percentage>|auto", "box-align": "start|center|end|baseline|stretch", "box-decoration-break": "slice|clone", "box-direction": "normal|reverse|inherit", "box-flex": "<number>", "box-flex-group": "<integer>", "box-lines": "single|multiple", "box-ordinal-group": "<integer>", "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit", "box-pack": "start|center|end|justify", "box-shadow": "none|<shadow>#", "box-sizing": "content-box|border-box", "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region", "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region", "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end", caret: "<'caret-color'>||<'caret-shape'>", "caret-color": "auto|<color>", "caret-shape": "auto|bar|block|underscore", clear: "none|left|right|both|inline-start|inline-end", clip: "<shape>|auto", "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none", color: "<color>", "print-color-adjust": "economy|exact", "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?", "column-count": "<integer>|auto", "column-fill": "auto|balance|balance-all", "column-gap": "normal|<length-percentage>", "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>", "column-rule-color": "<color>", "column-rule-style": "<'border-style'>", "column-rule-width": "<'border-width'>", "column-span": "none|all", "column-width": "<length>|auto", columns: "<'column-width'>||<'column-count'>", contain: "none|strict|content|[[size||inline-size]||layout||style||paint]", "contain-intrinsic-size": "[none|<length>|auto <length>]{1,2}", "contain-intrinsic-block-size": "none|<length>|auto <length>", "contain-intrinsic-height": "none|<length>|auto <length>", "contain-intrinsic-inline-size": "none|<length>|auto <length>", "contain-intrinsic-width": "none|<length>|auto <length>", content: "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?", "content-visibility": "visible|auto|hidden", "counter-increment": "[<counter-name> <integer>?]+|none", "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none", "counter-set": "[<counter-name> <integer>?]+|none", cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]", direction: "ltr|rtl", display: "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>", "empty-cells": "show|hide", filter: "none|<filter-function-list>|<-ms-filter-function-list>", flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]", "flex-basis": "content|<'width'>", "flex-direction": "row|row-reverse|column|column-reverse", "flex-flow": "<'flex-direction'>||<'flex-wrap'>", "flex-grow": "<number>", "flex-shrink": "<number>", "flex-wrap": "nowrap|wrap|wrap-reverse", float: "left|right|none|inline-start|inline-end", font: "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar", "font-family": "[<family-name>|<generic-family>]#", "font-feature-settings": "normal|<feature-tag-value>#", "font-kerning": "auto|normal|none", "font-language-override": "normal|<string>", "font-optical-sizing": "auto|none", "font-variation-settings": "normal|[<string> <number>]#", "font-size": "<absolute-size>|<relative-size>|<length-percentage>", "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]", "font-smooth": "auto|never|always|<absolute-size>|<length>", "font-stretch": "<font-stretch-absolute>", "font-style": "normal|italic|oblique <angle>?", "font-synthesis": "none|[weight||style||small-caps]", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]", "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps", "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]", "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]", "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]", "font-variant-position": "normal|sub|super", "font-weight": "<font-weight-absolute>|bolder|lighter", "forced-color-adjust": "auto|none", gap: "<'row-gap'> <'column-gap'>?", grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>", "grid-area": "<grid-line> [/ <grid-line>]{0,3}", "grid-auto-columns": "<track-size>+", "grid-auto-flow": "[row|column]||dense", "grid-auto-rows": "<track-size>+", "grid-column": "<grid-line> [/ <grid-line>]?", "grid-column-end": "<grid-line>", "grid-column-gap": "<length-percentage>", "grid-column-start": "<grid-line>", "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?", "grid-row": "<grid-line> [/ <grid-line>]?", "grid-row-end": "<grid-line>", "grid-row-gap": "<length-percentage>", "grid-row-start": "<grid-line>", "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?", "grid-template-areas": "none|<string>+", "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?", "hanging-punctuation": "none|[first||[force-end|allow-end]||last]", height: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "hyphenate-character": "auto|<string>", hyphens: "none|manual|auto", "image-orientation": "from-image|<angle>|[<angle>? flip]", "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>", "image-resolution": "[from-image||<resolution>]&&snap?", "ime-mode": "auto|normal|active|inactive|disabled", "initial-letter": "normal|[<number> <integer>?]", "initial-letter-align": "[auto|alphabetic|hanging|ideographic]", "inline-size": "<'width'>", "input-security": "auto|none", inset: "<'top'>{1,4}", "inset-block": "<'top'>{1,2}", "inset-block-end": "<'top'>", "inset-block-start": "<'top'>", "inset-inline": "<'top'>{1,2}", "inset-inline-end": "<'top'>", "inset-inline-start": "<'top'>", isolation: "auto|isolate", "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]", "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]", "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]", "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#", left: "<length>|<percentage>|auto", "letter-spacing": "normal|<length-percentage>", "line-break": "auto|loose|normal|strict|anywhere", "line-clamp": "none|<integer>", "line-height": "normal|<number>|<length>|<percentage>", "line-height-step": "<length>", "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>", "list-style-image": "<image>|none", "list-style-position": "inside|outside", "list-style-type": "<counter-style>|<string>|none", margin: "[<length>|<percentage>|auto]{1,4}", "margin-block": "<'margin-left'>{1,2}", "margin-block-end": "<'margin-left'>", "margin-block-start": "<'margin-left'>", "margin-bottom": "<length>|<percentage>|auto", "margin-inline": "<'margin-left'>{1,2}", "margin-inline-end": "<'margin-left'>", "margin-inline-start": "<'margin-left'>", "margin-left": "<length>|<percentage>|auto", "margin-right": "<length>|<percentage>|auto", "margin-top": "<length>|<percentage>|auto", "margin-trim": "none|in-flow|all", mask: "<mask-layer>#", "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>", "mask-border-mode": "luminance|alpha", "mask-border-outset": "[<length>|<number>]{1,4}", "mask-border-repeat": "[stretch|repeat|round|space]{1,2}", "mask-border-slice": "<number-percentage>{1,4} fill?", "mask-border-source": "none|<image>", "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}", "mask-clip": "[<geometry-box>|no-clip]#", "mask-composite": "<compositing-operator>#", "mask-image": "<mask-reference>#", "mask-mode": "<masking-mode>#", "mask-origin": "<geometry-box>#", "mask-position": "<position>#", "mask-repeat": "<repeat-style>#", "mask-size": "<bg-size>#", "mask-type": "luminance|alpha", "masonry-auto-flow": "[pack|next]||[definite-first|ordered]", "math-depth": "auto-add|add( <integer> )|<integer>", "math-shift": "normal|compact", "math-style": "normal|compact", "max-block-size": "<'max-width'>", "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "max-inline-size": "<'max-width'>", "max-lines": "none|<integer>", "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>", "min-block-size": "<'min-width'>", "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )", "min-inline-size": "<'min-width'>", "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>", "mix-blend-mode": "<blend-mode>|plus-lighter", "object-fit": "fill|contain|cover|none|scale-down", "object-position": "<position>", offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?", "offset-anchor": "auto|<position>", "offset-distance": "<length-percentage>", "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]", "offset-position": "auto|<position>", "offset-rotate": "[auto|reverse]||<angle>", opacity: "<alpha-value>", order: "<integer>", orphans: "<integer>", outline: "[<'outline-color'>||<'outline-style'>||<'outline-width'>]", "outline-color": "<color>|invert", "outline-offset": "<length>", "outline-style": "auto|<'border-style'>", "outline-width": "<line-width>", overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>", "overflow-anchor": "auto|none", "overflow-block": "visible|hidden|clip|scroll|auto", "overflow-clip-box": "padding-box|content-box", "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>", "overflow-inline": "visible|hidden|clip|scroll|auto", "overflow-wrap": "normal|break-word|anywhere", "overflow-x": "visible|hidden|clip|scroll|auto", "overflow-y": "visible|hidden|clip|scroll|auto", "overscroll-behavior": "[contain|none|auto]{1,2}", "overscroll-behavior-block": "contain|none|auto", "overscroll-behavior-inline": "contain|none|auto", "overscroll-behavior-x": "contain|none|auto", "overscroll-behavior-y": "contain|none|auto", padding: "[<length>|<percentage>]{1,4}", "padding-block": "<'padding-left'>{1,2}", "padding-block-end": "<'padding-left'>", "padding-block-start": "<'padding-left'>", "padding-bottom": "<length>|<percentage>", "padding-inline": "<'padding-left'>{1,2}", "padding-inline-end": "<'padding-left'>", "padding-inline-start": "<'padding-left'>", "padding-left": "<length>|<percentage>", "padding-right": "<length>|<percentage>", "padding-top": "<length>|<percentage>", "page-break-after": "auto|always|avoid|left|right|recto|verso", "page-break-before": "auto|always|avoid|left|right|recto|verso", "page-break-inside": "auto|avoid", "paint-order": "normal|[fill||stroke||markers]", perspective: "none|<length>", "perspective-origin": "<position>", "place-content": "<'align-content'> <'justify-content'>?", "place-items": "<'align-items'> <'justify-items'>?", "place-self": "<'align-self'> <'justify-self'>?", "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit", position: "static|relative|absolute|sticky|fixed|-webkit-sticky", quotes: "none|auto|[<string> <string>]+", resize: "none|both|horizontal|vertical|block|inline", right: "<length>|<percentage>|auto", rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>", "row-gap": "normal|<length-percentage>", "ruby-align": "start|center|space-between|space-around", "ruby-merge": "separate|collapse|auto", "ruby-position": "[alternate||[over|under]]|inter-character", scale: "none|<number>{1,3}", "scrollbar-color": "auto|<color>{2}", "scrollbar-gutter": "auto|stable&&both-edges?", "scrollbar-width": "auto|thin|none", "scroll-behavior": "auto|smooth", "scroll-margin": "<length>{1,4}", "scroll-margin-block": "<length>{1,2}", "scroll-margin-block-start": "<length>", "scroll-margin-block-end": "<length>", "scroll-margin-bottom": "<length>", "scroll-margin-inline": "<length>{1,2}", "scroll-margin-inline-start": "<length>", "scroll-margin-inline-end": "<length>", "scroll-margin-left": "<length>", "scroll-margin-right": "<length>", "scroll-margin-top": "<length>", "scroll-padding": "[auto|<length-percentage>]{1,4}", "scroll-padding-block": "[auto|<length-percentage>]{1,2}", "scroll-padding-block-start": "auto|<length-percentage>", "scroll-padding-block-end": "auto|<length-percentage>", "scroll-padding-bottom": "auto|<length-percentage>", "scroll-padding-inline": "[auto|<length-percentage>]{1,2}", "scroll-padding-inline-start": "auto|<length-percentage>", "scroll-padding-inline-end": "auto|<length-percentage>", "scroll-padding-left": "auto|<length-percentage>", "scroll-padding-right": "auto|<length-percentage>", "scroll-padding-top": "auto|<length-percentage>", "scroll-snap-align": "[none|start|end|center]{1,2}", "scroll-snap-coordinate": "none|<position>#", "scroll-snap-destination": "<position>", "scroll-snap-points-x": "none|repeat( <length-percentage> )", "scroll-snap-points-y": "none|repeat( <length-percentage> )", "scroll-snap-stop": "normal|always", "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?", "scroll-snap-type-x": "none|mandatory|proximity", "scroll-snap-type-y": "none|mandatory|proximity", "scroll-timeline": "<scroll-timeline-name>||<scroll-timeline-axis>", "scroll-timeline-axis": "block|inline|vertical|horizontal", "scroll-timeline-name": "none|<custom-ident>", "shape-image-threshold": "<alpha-value>", "shape-margin": "<length-percentage>", "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>", "tab-size": "<integer>|<length>", "table-layout": "auto|fixed", "text-align": "start|end|left|right|center|justify|match-parent", "text-align-last": "auto|start|end|left|right|center|justify", "text-combine-upright": "none|all|[digits <integer>?]", "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>", "text-decoration-color": "<color>", "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error", "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]", "text-decoration-skip-ink": "auto|all|none", "text-decoration-style": "solid|double|dotted|dashed|wavy", "text-decoration-thickness": "auto|from-font|<length>|<percentage>", "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>", "text-emphasis-color": "<color>", "text-emphasis-position": "[over|under]&&[right|left]", "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>", "text-indent": "<length-percentage>&&hanging?&&each-line?", "text-justify": "auto|inter-character|inter-word|none", "text-orientation": "mixed|upright|sideways", "text-overflow": "[clip|ellipsis|<string>]{1,2}", "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision", "text-shadow": "none|<shadow-t>#", "text-size-adjust": "none|auto|<percentage>", "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana", "text-underline-offset": "auto|<length>|<percentage>", "text-underline-position": "auto|from-font|[under||[left|right]]", top: "<length>|<percentage>|auto", "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation", transform: "none|<transform-list>", "transform-box": "content-box|border-box|fill-box|stroke-box|view-box", "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?", "transform-style": "flat|preserve-3d", transition: "<single-transition>#", "transition-delay": "<time>#", "transition-duration": "<time>#", "transition-property": "none|<single-transition-property>#", "transition-timing-function": "<easing-function>#", translate: "none|<length-percentage> [<length-percentage> <length>?]?", "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext", "user-select": "auto|text|none|contain|all", "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>", visibility: "visible|hidden|collapse", "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces", widows: "<integer>", width: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content", "will-change": "auto|<animateable-feature>#", "word-break": "normal|break-all|keep-all|break-word", "word-spacing": "normal|<length>", "word-wrap": "normal|break-word", "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>", "z-index": "auto|<integer>", zoom: "normal|reset|<number>|<percentage>", "-moz-background-clip": "padding|border", "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>", "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>", "-moz-border-radius-topleft": "<'border-top-left-radius'>", "-moz-border-radius-topright": "<'border-bottom-right-radius'>", "-moz-control-character-visibility": "visible|hidden", "-moz-osx-font-smoothing": "auto|grayscale", "-moz-user-select": "none|text|all|-moz-none", "-ms-flex-align": "start|end|center|baseline|stretch", "-ms-flex-item-align": "auto|start|end|center|baseline|stretch", "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch", "-ms-flex-negative": "<'flex-shrink'>", "-ms-flex-pack": "start|end|center|justify|distribute", "-ms-flex-order": "<integer>", "-ms-flex-positive": "<'flex-grow'>", "-ms-flex-preferred-size": "<'flex-basis'>", "-ms-interpolation-mode": "nearest-neighbor|bicubic", "-ms-grid-column-align": "start|end|center|stretch", "-ms-grid-row-align": "start|end|center|stretch", "-ms-hyphenate-limit-last": "none|always|column|page|spread", "-webkit-background-clip": "[<box>|border|padding|content|text]#", "-webkit-column-break-after": "always|auto|avoid", "-webkit-column-break-before": "always|auto|avoid", "-webkit-column-break-inside": "always|auto|avoid", "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased", "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?", "-webkit-print-color-adjust": "economy|exact", "-webkit-text-security": "none|circle|disc|square", "-webkit-user-drag": "none|element|auto", "-webkit-user-select": "auto|none|text|all", "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical", "baseline-shift": "baseline|sub|super|<svg-length>", behavior: "<url>+", "clip-rule": "nonzero|evenodd", container: "<'container-name'> [/ <'container-type'>]?", "container-name": "none|<custom-ident>+", "container-type": "normal||[size|inline-size]", cue: "<'cue-before'> <'cue-after'>?", "cue-after": "<url> <decibel>?|none", "cue-before": "<url> <decibel>?|none", "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge", fill: "<paint>", "fill-opacity": "<number-zero-one>", "fill-rule": "nonzero|evenodd", "glyph-orientation-horizontal": "<angle>", "glyph-orientation-vertical": "<angle>", kerning: "auto|<svg-length>", marker: "none|<url>", "marker-end": "none|<url>", "marker-mid": "none|<url>", "marker-start": "none|<url>", pause: "<'pause-before'> <'pause-after'>?", "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong", rest: "<'rest-before'> <'rest-after'>?", "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong", "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong", "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision", src: "[<url> [format( <string># )]?|local( <family-name> )]#", speak: "auto|none|normal", "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]", stroke: "<paint>", "stroke-dasharray": "none|[<svg-length>+]#", "stroke-dashoffset": "<svg-length>", "stroke-linecap": "butt|round|square", "stroke-linejoin": "miter|round|bevel", "stroke-miterlimit": "<number-one-or-greater>", "stroke-opacity": "<number-zero-one>", "stroke-width": "<svg-length>", "text-anchor": "start|middle|end", "unicode-range": "<urange>#", "voice-balance": "<number>|left|center|right|leftwards|rightwards", "voice-duration": "auto|<time>", "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve", "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]", "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>", "voice-stress": "normal|strong|moderate|none|reduced", "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]" }, atrules: { charset: { prelude: "<string>", descriptors: null }, "counter-style": { prelude: "<counter-style-name>", descriptors: { "additive-symbols": "[<integer>&&<symbol>]#", fallback: "<counter-style-name>", negative: "<symbol> <symbol>?", pad: "<integer>&&<symbol>", prefix: "<symbol>", range: "[[<integer>|infinite]{2}]#|auto", "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>", suffix: "<symbol>", symbols: "<symbol>+", system: "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]" } }, document: { prelude: "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#", descriptors: null }, "font-face": { prelude: null, descriptors: { "ascent-override": "normal|<percentage>", "descent-override": "normal|<percentage>", "font-display": "[auto|block|swap|fallback|optional]", "font-family": "<family-name>", "font-feature-settings": "normal|<feature-tag-value>#", "font-variation-settings": "normal|[<string> <number>]#", "font-stretch": "<font-stretch-absolute>{1,2}", "font-style": "normal|italic|oblique <angle>{0,2}", "font-weight": "<font-weight-absolute>{1,2}", "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]", "line-gap-override": "normal|<percentage>", "size-adjust": "<percentage>", src: "[<url> [format( <string># )]?|local( <family-name> )]#", "unicode-range": "<urange>#" } }, "font-feature-values": { prelude: "<family-name>#", descriptors: null }, import: { prelude: "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?", descriptors: null }, keyframes: { prelude: "<keyframes-name>", descriptors: null }, layer: { prelude: "[<layer-name>#|<layer-name>?]", descriptors: null }, media: { prelude: "<media-query-list>", descriptors: null }, namespace: { prelude: "<namespace-prefix>? [<string>|<url>]", descriptors: null }, page: { prelude: "<page-selector-list>", descriptors: { bleed: "auto|<length>", marks: "none|[crop||cross]", size: "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]" } }, property: { prelude: "<custom-property-name>", descriptors: { syntax: "<string>", inherits: "true|false", "initial-value": "<string>" } }, "scroll-timeline": { prelude: "<timeline-name>", descriptors: null }, supports: { prelude: "<supports-condition>", descriptors: null }, viewport: { prelude: null, descriptors: { height: "<viewport-length>{1,2}", "max-height": "<viewport-length>", "max-width": "<viewport-length>", "max-zoom": "auto|<number>|<percentage>", "min-height": "<viewport-length>", "min-width": "<viewport-length>", "min-zoom": "auto|<number>|<percentage>", orientation: "auto|portrait|landscape", "user-zoom": "zoom|fixed", "viewport-fit": "auto|contain|cover", width: "<viewport-length>{1,2}", zoom: "auto|<number>|<percentage>" } }, container: { prelude: "[<container-name>]? <container-condition>", descriptors: null }, nest: { prelude: "<complex-selector-list>", descriptors: null } } };
var gt = {};
b(gt, { AnPlusB: () => Xr, Atrule: () => Zr, AtrulePrelude: () => en, AttributeSelector: () => nn, Block: () => an, Brackets: () => ln, CDC: () => un, CDO: () => hn, ClassSelector: () => fn, Combinator: () => gn, Comment: () => xn, Declaration: () => kn, DeclarationList: () => Sn, Dimension: () => An, Function: () => En, Hash: () => Pn, IdSelector: () => Nn, Identifier: () => Dn, MediaFeature: () => Mn, MediaQuery: () => Fn, MediaQueryList: () => _n, NestingSelector: () => Un, Nth: () => Wn, Number: () => Yn, Operator: () => Vn, Parentheses: () => Qn, Percentage: () => $n, PseudoClassSelector: () => Jn, PseudoElementSelector: () => to, Ratio: () => no, Raw: () => io, Rule: () => so, Selector: () => co, SelectorList: () => po, String: () => bo, StyleSheet: () => yo, TypeSelector: () => vo, UnicodeRange: () => Ao, Url: () => Do, Value: () => No, WhiteSpace: () => Mo });
var Xr = {};
b(Xr, { generate: () => xc, name: () => gc, parse: () => Qr, structure: () => bc });
var me = 43;
var re = 45;
var Xt = 110;
var Ie = true;
var dc = false;
function $t(e, t) {
  let r = this.tokenStart + e, n2 = this.charCodeAt(r);
  for ((n2 === me || n2 === re) && (t && this.error("Number sign is not allowed"), r++); r < this.tokenEnd; r++)
    B(this.charCodeAt(r)) || this.error("Integer is expected", r);
}
function Qe(e) {
  return $t.call(this, 0, e);
}
function Ce(e, t) {
  if (!this.cmpChar(this.tokenStart + e, t)) {
    let r = "";
    switch (t) {
      case Xt:
        r = "N is expected";
        break;
      case re:
        r = "HyphenMinus is expected";
        break;
    }
    this.error(r, this.tokenStart + e);
  }
}
function Kr() {
  let e = 0, t = 0, r = this.tokenType;
  for (; r === 13 || r === 25; )
    r = this.lookupType(++e);
  if (r !== 10)
    if (this.isDelim(me, e) || this.isDelim(re, e)) {
      t = this.isDelim(me, e) ? me : re;
      do
        r = this.lookupType(++e);
      while (r === 13 || r === 25);
      r !== 10 && (this.skip(e), Qe.call(this, Ie));
    } else
      return null;
  return e > 0 && this.skip(e), t === 0 && (r = this.charCodeAt(this.tokenStart), r !== me && r !== re && this.error("Number sign is expected")), Qe.call(this, t !== 0), t === re ? "-" + this.consume(10) : this.consume(10);
}
var gc = "AnPlusB";
var bc = { a: [String, null], b: [String, null] };
function Qr() {
  let e = this.tokenStart, t = null, r = null;
  if (this.tokenType === 10)
    Qe.call(this, dc), r = this.consume(10);
  else if (this.tokenType === 1 && this.cmpChar(this.tokenStart, re))
    switch (t = "-1", Ce.call(this, 1, Xt), this.tokenEnd - this.tokenStart) {
      case 2:
        this.next(), r = Kr.call(this);
        break;
      case 3:
        Ce.call(this, 2, re), this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10);
        break;
      default:
        Ce.call(this, 2, re), $t.call(this, 3, Ie), this.next(), r = this.substrToCursor(e + 2);
    }
  else if (this.tokenType === 1 || this.isDelim(me) && this.lookupType(1) === 1) {
    let n2 = 0;
    switch (t = "1", this.isDelim(me) && (n2 = 1, this.next()), Ce.call(this, 0, Xt), this.tokenEnd - this.tokenStart) {
      case 1:
        this.next(), r = Kr.call(this);
        break;
      case 2:
        Ce.call(this, 1, re), this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10);
        break;
      default:
        Ce.call(this, 1, re), $t.call(this, 2, Ie), this.next(), r = this.substrToCursor(e + n2 + 1);
    }
  } else if (this.tokenType === 12) {
    let n2 = this.charCodeAt(this.tokenStart), o = n2 === me || n2 === re, i = this.tokenStart + o;
    for (; i < this.tokenEnd && B(this.charCodeAt(i)); i++)
      ;
    i === this.tokenStart + o && this.error("Integer is expected", this.tokenStart + o), Ce.call(this, i - this.tokenStart, Xt), t = this.substring(e, i), i + 1 === this.tokenEnd ? (this.next(), r = Kr.call(this)) : (Ce.call(this, i - this.tokenStart + 1, re), i + 2 === this.tokenEnd ? (this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10)) : ($t.call(this, i - this.tokenStart + 2, Ie), this.next(), r = this.substrToCursor(i + 1)));
  } else
    this.error();
  return t !== null && t.charCodeAt(0) === me && (t = t.substr(1)), r !== null && r.charCodeAt(0) === me && (r = r.substr(1)), { type: "AnPlusB", loc: this.getLocation(e, this.tokenStart), a: t, b: r };
}
function xc(e) {
  if (e.a) {
    let t = e.a === "+1" && "n" || e.a === "1" && "n" || e.a === "-1" && "-n" || e.a + "n";
    if (e.b) {
      let r = e.b[0] === "-" || e.b[0] === "+" ? e.b : "+" + e.b;
      this.tokenize(t + r);
    } else
      this.tokenize(t);
  } else
    this.tokenize(e.b);
}
var Zr = {};
b(Zr, { generate: () => Sc, name: () => kc, parse: () => $r, structure: () => vc, walkContext: () => wc });
function da(e) {
  return this.Raw(e, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function yc() {
  for (let e = 1, t; t = this.lookupType(e); e++) {
    if (t === 24)
      return true;
    if (t === 23 || t === 3)
      return false;
  }
  return false;
}
var kc = "Atrule";
var wc = "atrule";
var vc = { name: String, prelude: ["AtrulePrelude", "Raw", null], block: ["Block", null] };
function $r(e = false) {
  let t = this.tokenStart, r, n2, o = null, i = null;
  switch (this.eat(3), r = this.substrToCursor(t + 1), n2 = r.toLowerCase(), this.skipSC(), this.eof === false && this.tokenType !== 23 && this.tokenType !== 17 && (this.parseAtrulePrelude ? o = this.parseWithFallback(this.AtrulePrelude.bind(this, r, e), da) : o = da.call(this, this.tokenIndex), this.skipSC()), this.tokenType) {
    case 17:
      this.next();
      break;
    case 23:
      hasOwnProperty.call(this.atrule, n2) && typeof this.atrule[n2].block == "function" ? i = this.atrule[n2].block.call(this, e) : i = this.Block(yc.call(this));
      break;
  }
  return { type: "Atrule", loc: this.getLocation(t, this.tokenStart), name: r, prelude: o, block: i };
}
function Sc(e) {
  this.token(3, "@" + e.name), e.prelude !== null && this.node(e.prelude), e.block ? this.node(e.block) : this.token(17, ";");
}
var en = {};
b(en, { generate: () => Ec, name: () => Cc, parse: () => Jr, structure: () => Tc, walkContext: () => Ac });
var Cc = "AtrulePrelude";
var Ac = "atrulePrelude";
var Tc = { children: [[]] };
function Jr(e) {
  let t = null;
  return e !== null && (e = e.toLowerCase()), this.skipSC(), hasOwnProperty.call(this.atrule, e) && typeof this.atrule[e].prelude == "function" ? t = this.atrule[e].prelude.call(this) : t = this.readSequence(this.scope.AtrulePrelude), this.skipSC(), this.eof !== true && this.tokenType !== 23 && this.tokenType !== 17 && this.error("Semicolon or block is expected"), { type: "AtrulePrelude", loc: this.getLocationFromList(t), children: t };
}
function Ec(e) {
  this.children(e);
}
var nn = {};
b(nn, { generate: () => Mc, name: () => Nc, parse: () => rn, structure: () => zc });
var Lc = 36;
var ga = 42;
var Zt = 61;
var Pc = 94;
var tn = 124;
var Ic = 126;
function Dc() {
  this.eof && this.error("Unexpected end of input");
  let e = this.tokenStart, t = false;
  return this.isDelim(ga) ? (t = true, this.next()) : this.isDelim(tn) || this.eat(1), this.isDelim(tn) ? this.charCodeAt(this.tokenStart + 1) !== Zt ? (this.next(), this.eat(1)) : t && this.error("Identifier is expected", this.tokenEnd) : t && this.error("Vertical line is expected"), { type: "Identifier", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) };
}
function Oc() {
  let e = this.tokenStart, t = this.charCodeAt(e);
  return t !== Zt && t !== Ic && t !== Pc && t !== Lc && t !== ga && t !== tn && this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected"), this.next(), t !== Zt && (this.isDelim(Zt) || this.error("Equal sign is expected"), this.next()), this.substrToCursor(e);
}
var Nc = "AttributeSelector";
var zc = { name: "Identifier", matcher: [String, null], value: ["String", "Identifier", null], flags: [String, null] };
function rn() {
  let e = this.tokenStart, t, r = null, n2 = null, o = null;
  return this.eat(19), this.skipSC(), t = Dc.call(this), this.skipSC(), this.tokenType !== 20 && (this.tokenType !== 1 && (r = Oc.call(this), this.skipSC(), n2 = this.tokenType === 5 ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === 1 && (o = this.consume(1), this.skipSC())), this.eat(20), { type: "AttributeSelector", loc: this.getLocation(e, this.tokenStart), name: t, matcher: r, value: n2, flags: o };
}
function Mc(e) {
  this.token(9, "["), this.node(e.name), e.matcher !== null && (this.tokenize(e.matcher), this.node(e.value)), e.flags !== null && this.token(1, e.flags), this.token(9, "]");
}
var an = {};
b(an, { generate: () => Uc, name: () => Bc, parse: () => on, structure: () => qc, walkContext: () => _c });
var Rc = 38;
function ya(e) {
  return this.Raw(e, null, true);
}
function ba() {
  return this.parseWithFallback(this.Rule, ya);
}
function xa(e) {
  return this.Raw(e, this.consumeUntilSemicolonIncluded, true);
}
function Fc() {
  if (this.tokenType === 17)
    return xa.call(this, this.tokenIndex);
  let e = this.parseWithFallback(this.Declaration, xa);
  return this.tokenType === 17 && this.next(), e;
}
var Bc = "Block";
var _c = "block";
var qc = { children: [["Atrule", "Rule", "Declaration"]] };
function on(e) {
  let t = e ? Fc : ba, r = this.tokenStart, n2 = this.createList();
  this.eat(23);
  e:
    for (; !this.eof; )
      switch (this.tokenType) {
        case 24:
          break e;
        case 13:
        case 25:
          this.next();
          break;
        case 3:
          n2.push(this.parseWithFallback(this.Atrule.bind(this, e), ya));
          break;
        default:
          e && this.isDelim(Rc) ? n2.push(ba.call(this)) : n2.push(t.call(this));
      }
  return this.eof || this.eat(24), { type: "Block", loc: this.getLocation(r, this.tokenStart), children: n2 };
}
function Uc(e) {
  this.token(23, "{"), this.children(e, (t) => {
    t.type === "Declaration" && this.token(17, ";");
  }), this.token(24, "}");
}
var ln = {};
b(ln, { generate: () => Hc, name: () => jc, parse: () => sn, structure: () => Wc });
var jc = "Brackets";
var Wc = { children: [[]] };
function sn(e, t) {
  let r = this.tokenStart, n2 = null;
  return this.eat(19), n2 = e.call(this, t), this.eof || this.eat(20), { type: "Brackets", loc: this.getLocation(r, this.tokenStart), children: n2 };
}
function Hc(e) {
  this.token(9, "["), this.children(e), this.token(9, "]");
}
var un = {};
b(un, { generate: () => Vc, name: () => Yc, parse: () => cn, structure: () => Gc });
var Yc = "CDC";
var Gc = [];
function cn() {
  let e = this.tokenStart;
  return this.eat(15), { type: "CDC", loc: this.getLocation(e, this.tokenStart) };
}
function Vc() {
  this.token(15, "-->");
}
var hn = {};
b(hn, { generate: () => Xc, name: () => Kc, parse: () => pn, structure: () => Qc });
var Kc = "CDO";
var Qc = [];
function pn() {
  let e = this.tokenStart;
  return this.eat(14), { type: "CDO", loc: this.getLocation(e, this.tokenStart) };
}
function Xc() {
  this.token(14, "<!--");
}
var fn = {};
b(fn, { generate: () => eu, name: () => Zc, parse: () => mn, structure: () => Jc });
var $c = 46;
var Zc = "ClassSelector";
var Jc = { name: String };
function mn() {
  return this.eatDelim($c), { type: "ClassSelector", loc: this.getLocation(this.tokenStart - 1, this.tokenEnd), name: this.consume(1) };
}
function eu(e) {
  this.token(9, "."), this.token(1, e.name);
}
var gn = {};
b(gn, { generate: () => au, name: () => ou, parse: () => dn, structure: () => iu });
var tu = 43;
var ka = 47;
var ru = 62;
var nu = 126;
var ou = "Combinator";
var iu = { name: String };
function dn() {
  let e = this.tokenStart, t;
  switch (this.tokenType) {
    case 13:
      t = " ";
      break;
    case 9:
      switch (this.charCodeAt(this.tokenStart)) {
        case ru:
        case tu:
        case nu:
          this.next();
          break;
        case ka:
          this.next(), this.eatIdent("deep"), this.eatDelim(ka);
          break;
        default:
          this.error("Combinator is expected");
      }
      t = this.substrToCursor(e);
      break;
  }
  return { type: "Combinator", loc: this.getLocation(e, this.tokenStart), name: t };
}
function au(e) {
  this.tokenize(e.name);
}
var xn = {};
b(xn, { generate: () => pu, name: () => cu, parse: () => bn, structure: () => uu });
var su = 42;
var lu = 47;
var cu = "Comment";
var uu = { value: String };
function bn() {
  let e = this.tokenStart, t = this.tokenEnd;
  return this.eat(25), t - e + 2 >= 2 && this.charCodeAt(t - 2) === su && this.charCodeAt(t - 1) === lu && (t -= 2), { type: "Comment", loc: this.getLocation(e, this.tokenStart), value: this.substring(e + 2, t) };
}
function pu(e) {
  this.token(25, "/*" + e.value + "*/");
}
var kn = {};
b(kn, { generate: () => Su, name: () => ku, parse: () => yn, structure: () => vu, walkContext: () => wu });
var va = 33;
var hu = 35;
var mu = 36;
var fu = 38;
var du = 42;
var gu = 43;
var wa = 47;
function bu(e) {
  return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, true);
}
function xu(e) {
  return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, false);
}
function yu() {
  let e = this.tokenIndex, t = this.Value();
  return t.type !== "Raw" && this.eof === false && this.tokenType !== 17 && this.isDelim(va) === false && this.isBalanceEdge(e) === false && this.error(), t;
}
var ku = "Declaration";
var wu = "declaration";
var vu = { important: [Boolean, String], property: String, value: ["Value", "Raw"] };
function yn() {
  let e = this.tokenStart, t = this.tokenIndex, r = Cu.call(this), n2 = Mt(r), o = n2 ? this.parseCustomProperty : this.parseValue, i = n2 ? xu : bu, s = false, u;
  this.skipSC(), this.eat(16);
  let c2 = this.tokenIndex;
  if (n2 || this.skipSC(), o ? u = this.parseWithFallback(yu, i) : u = i.call(this, this.tokenIndex), n2 && u.type === "Value" && u.children.isEmpty) {
    for (let a = c2 - this.tokenIndex; a <= 0; a++)
      if (this.lookupType(a) === 13) {
        u.children.appendData({ type: "WhiteSpace", loc: null, value: " " });
        break;
      }
  }
  return this.isDelim(va) && (s = Au.call(this), this.skipSC()), this.eof === false && this.tokenType !== 17 && this.isBalanceEdge(t) === false && this.error(), { type: "Declaration", loc: this.getLocation(e, this.tokenStart), important: s, property: r, value: u };
}
function Su(e) {
  this.token(1, e.property), this.token(16, ":"), this.node(e.value), e.important && (this.token(9, "!"), this.token(1, e.important === true ? "important" : e.important));
}
function Cu() {
  let e = this.tokenStart;
  if (this.tokenType === 9)
    switch (this.charCodeAt(this.tokenStart)) {
      case du:
      case mu:
      case gu:
      case hu:
      case fu:
        this.next();
        break;
      case wa:
        this.next(), this.isDelim(wa) && this.next();
        break;
    }
  return this.tokenType === 4 ? this.eat(4) : this.eat(1), this.substrToCursor(e);
}
function Au() {
  this.eat(9), this.skipSC();
  let e = this.consume(1);
  return e === "important" ? true : e;
}
var Sn = {};
b(Sn, { generate: () => Pu, name: () => Eu, parse: () => vn, structure: () => Lu });
var Tu = 38;
function wn(e) {
  return this.Raw(e, this.consumeUntilSemicolonIncluded, true);
}
var Eu = "DeclarationList";
var Lu = { children: [["Declaration", "Atrule", "Rule"]] };
function vn() {
  let e = this.createList();
  e:
    for (; !this.eof; )
      switch (this.tokenType) {
        case 13:
        case 25:
        case 17:
          this.next();
          break;
        case 3:
          e.push(this.parseWithFallback(this.Atrule.bind(this, true), wn));
          break;
        default:
          this.isDelim(Tu) ? e.push(this.parseWithFallback(this.Rule, wn)) : e.push(this.parseWithFallback(this.Declaration, wn));
      }
  return { type: "DeclarationList", loc: this.getLocationFromList(e), children: e };
}
function Pu(e) {
  this.children(e, (t) => {
    t.type === "Declaration" && this.token(17, ";");
  });
}
var An = {};
b(An, { generate: () => Ou, name: () => Iu, parse: () => Cn, structure: () => Du });
var Iu = "Dimension";
var Du = { value: String, unit: String };
function Cn() {
  let e = this.tokenStart, t = this.consumeNumber(12);
  return { type: "Dimension", loc: this.getLocation(e, this.tokenStart), value: t, unit: this.substring(e + t.length, this.tokenStart) };
}
function Ou(e) {
  this.token(12, e.value + e.unit);
}
var En = {};
b(En, { generate: () => Ru, name: () => Nu, parse: () => Tn, structure: () => Mu, walkContext: () => zu });
var Nu = "Function";
var zu = "function";
var Mu = { name: String, children: [[]] };
function Tn(e, t) {
  let r = this.tokenStart, n2 = this.consumeFunctionName(), o = n2.toLowerCase(), i;
  return i = t.hasOwnProperty(o) ? t[o].call(this, t) : e.call(this, t), this.eof || this.eat(22), { type: "Function", loc: this.getLocation(r, this.tokenStart), name: n2, children: i };
}
function Ru(e) {
  this.token(2, e.name + "("), this.children(e), this.token(22, ")");
}
var Pn = {};
b(Pn, { generate: () => qu, name: () => Bu, parse: () => Ln, structure: () => _u, xxx: () => Fu });
var Fu = "XXX";
var Bu = "Hash";
var _u = { value: String };
function Ln() {
  let e = this.tokenStart;
  return this.eat(4), { type: "Hash", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e + 1) };
}
function qu(e) {
  this.token(4, "#" + e.value);
}
var Dn = {};
b(Dn, { generate: () => Wu, name: () => Uu, parse: () => In, structure: () => ju });
var Uu = "Identifier";
var ju = { name: String };
function In() {
  return { type: "Identifier", loc: this.getLocation(this.tokenStart, this.tokenEnd), name: this.consume(1) };
}
function Wu(e) {
  this.token(1, e.name);
}
var Nn = {};
b(Nn, { generate: () => Gu, name: () => Hu, parse: () => On, structure: () => Yu });
var Hu = "IdSelector";
var Yu = { name: String };
function On() {
  let e = this.tokenStart;
  return this.eat(4), { type: "IdSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e + 1) };
}
function Gu(e) {
  this.token(9, "#" + e.name);
}
var Mn = {};
b(Mn, { generate: () => Qu, name: () => Vu, parse: () => zn, structure: () => Ku });
var Vu = "MediaFeature";
var Ku = { name: String, value: ["Identifier", "Number", "Dimension", "Ratio", null] };
function zn() {
  let e = this.tokenStart, t, r = null;
  if (this.eat(21), this.skipSC(), t = this.consume(1), this.skipSC(), this.tokenType !== 22) {
    switch (this.eat(16), this.skipSC(), this.tokenType) {
      case 10:
        this.lookupNonWSType(1) === 9 ? r = this.Ratio() : r = this.Number();
        break;
      case 12:
        r = this.Dimension();
        break;
      case 1:
        r = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  return this.eat(22), { type: "MediaFeature", loc: this.getLocation(e, this.tokenStart), name: t, value: r };
}
function Qu(e) {
  this.token(21, "("), this.token(1, e.name), e.value !== null && (this.token(16, ":"), this.node(e.value)), this.token(22, ")");
}
var Fn = {};
b(Fn, { generate: () => Zu, name: () => Xu, parse: () => Rn, structure: () => $u });
var Xu = "MediaQuery";
var $u = { children: [["Identifier", "MediaFeature", "WhiteSpace"]] };
function Rn() {
  let e = this.createList(), t = null;
  this.skipSC();
  e:
    for (; !this.eof; ) {
      switch (this.tokenType) {
        case 25:
        case 13:
          this.next();
          continue;
        case 1:
          t = this.Identifier();
          break;
        case 21:
          t = this.MediaFeature();
          break;
        default:
          break e;
      }
      e.push(t);
    }
  return t === null && this.error("Identifier or parenthesis is expected"), { type: "MediaQuery", loc: this.getLocationFromList(e), children: e };
}
function Zu(e) {
  this.children(e);
}
var _n = {};
b(_n, { generate: () => tp, name: () => Ju, parse: () => Bn, structure: () => ep });
var Ju = "MediaQueryList";
var ep = { children: [["MediaQuery"]] };
function Bn() {
  let e = this.createList();
  for (this.skipSC(); !this.eof && (e.push(this.MediaQuery()), this.tokenType === 18); )
    this.next();
  return { type: "MediaQueryList", loc: this.getLocationFromList(e), children: e };
}
function tp(e) {
  this.children(e, () => this.token(18, ","));
}
var Un = {};
b(Un, { generate: () => ip, name: () => np, parse: () => qn, structure: () => op });
var rp = 38;
var np = "NestingSelector";
var op = {};
function qn() {
  let e = this.tokenStart;
  return this.eatDelim(rp), { type: "NestingSelector", loc: this.getLocation(e, this.tokenStart) };
}
function ip() {
  this.token(9, "&");
}
var Wn = {};
b(Wn, { generate: () => lp, name: () => ap, parse: () => jn, structure: () => sp });
var ap = "Nth";
var sp = { nth: ["AnPlusB", "Identifier"], selector: ["SelectorList", null] };
function jn() {
  this.skipSC();
  let e = this.tokenStart, t = e, r = null, n2;
  return this.lookupValue(0, "odd") || this.lookupValue(0, "even") ? n2 = this.Identifier() : n2 = this.AnPlusB(), t = this.tokenStart, this.skipSC(), this.lookupValue(0, "of") && (this.next(), r = this.SelectorList(), t = this.tokenStart), { type: "Nth", loc: this.getLocation(e, t), nth: n2, selector: r };
}
function lp(e) {
  this.node(e.nth), e.selector !== null && (this.token(1, "of"), this.node(e.selector));
}
var Yn = {};
b(Yn, { generate: () => pp2, name: () => cp, parse: () => Hn, structure: () => up });
var cp = "Number";
var up = { value: String };
function Hn() {
  return { type: "Number", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consume(10) };
}
function pp2(e) {
  this.token(10, e.value);
}
var Vn = {};
b(Vn, { generate: () => fp, name: () => hp, parse: () => Gn, structure: () => mp });
var hp = "Operator";
var mp = { value: String };
function Gn() {
  let e = this.tokenStart;
  return this.next(), { type: "Operator", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) };
}
function fp(e) {
  this.tokenize(e.value);
}
var Qn = {};
b(Qn, { generate: () => bp, name: () => dp, parse: () => Kn, structure: () => gp });
var dp = "Parentheses";
var gp = { children: [[]] };
function Kn(e, t) {
  let r = this.tokenStart, n2 = null;
  return this.eat(21), n2 = e.call(this, t), this.eof || this.eat(22), { type: "Parentheses", loc: this.getLocation(r, this.tokenStart), children: n2 };
}
function bp(e) {
  this.token(21, "("), this.children(e), this.token(22, ")");
}
var $n = {};
b($n, { generate: () => kp, name: () => xp, parse: () => Xn, structure: () => yp });
var xp = "Percentage";
var yp = { value: String };
function Xn() {
  return { type: "Percentage", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: this.consumeNumber(11) };
}
function kp(e) {
  this.token(11, e.value + "%");
}
var Jn = {};
b(Jn, { generate: () => Cp, name: () => wp, parse: () => Zn, structure: () => Sp, walkContext: () => vp });
var wp = "PseudoClassSelector";
var vp = "function";
var Sp = { name: String, children: [["Raw"], null] };
function Zn() {
  let e = this.tokenStart, t = null, r, n2;
  return this.eat(16), this.tokenType === 2 ? (r = this.consumeFunctionName(), n2 = r.toLowerCase(), hasOwnProperty.call(this.pseudo, n2) ? (this.skipSC(), t = this.pseudo[n2].call(this), this.skipSC()) : (t = this.createList(), t.push(this.Raw(this.tokenIndex, null, false))), this.eat(22)) : r = this.consume(1), { type: "PseudoClassSelector", loc: this.getLocation(e, this.tokenStart), name: r, children: t };
}
function Cp(e) {
  this.token(16, ":"), e.children === null ? this.token(1, e.name) : (this.token(2, e.name + "("), this.children(e), this.token(22, ")"));
}
var to = {};
b(to, { generate: () => Lp, name: () => Ap, parse: () => eo, structure: () => Ep, walkContext: () => Tp });
var Ap = "PseudoElementSelector";
var Tp = "function";
var Ep = { name: String, children: [["Raw"], null] };
function eo() {
  let e = this.tokenStart, t = null, r, n2;
  return this.eat(16), this.eat(16), this.tokenType === 2 ? (r = this.consumeFunctionName(), n2 = r.toLowerCase(), hasOwnProperty.call(this.pseudo, n2) ? (this.skipSC(), t = this.pseudo[n2].call(this), this.skipSC()) : (t = this.createList(), t.push(this.Raw(this.tokenIndex, null, false))), this.eat(22)) : r = this.consume(1), { type: "PseudoElementSelector", loc: this.getLocation(e, this.tokenStart), name: r, children: t };
}
function Lp(e) {
  this.token(16, ":"), this.token(16, ":"), e.children === null ? this.token(1, e.name) : (this.token(2, e.name + "("), this.children(e), this.token(22, ")"));
}
var no = {};
b(no, { generate: () => Np, name: () => Dp, parse: () => ro, structure: () => Op });
var Pp = 47;
var Ip = 46;
function Sa() {
  this.skipSC();
  let e = this.consume(10);
  for (let t = 0; t < e.length; t++) {
    let r = e.charCodeAt(t);
    !B(r) && r !== Ip && this.error("Unsigned number is expected", this.tokenStart - e.length + t);
  }
  return Number(e) === 0 && this.error("Zero number is not allowed", this.tokenStart - e.length), e;
}
var Dp = "Ratio";
var Op = { left: String, right: String };
function ro() {
  let e = this.tokenStart, t = Sa.call(this), r;
  return this.skipSC(), this.eatDelim(Pp), r = Sa.call(this), { type: "Ratio", loc: this.getLocation(e, this.tokenStart), left: t, right: r };
}
function Np(e) {
  this.token(10, e.left), this.token(9, "/"), this.token(10, e.right);
}
var io = {};
b(io, { generate: () => Fp, name: () => Mp, parse: () => oo, structure: () => Rp });
function zp() {
  return this.tokenIndex > 0 && this.lookupType(-1) === 13 ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart;
}
var Mp = "Raw";
var Rp = { value: String };
function oo(e, t, r) {
  let n2 = this.getTokenStart(e), o;
  return this.skipUntilBalanced(e, t || this.consumeUntilBalanceEnd), r && this.tokenStart > n2 ? o = zp.call(this) : o = this.tokenStart, { type: "Raw", loc: this.getLocation(n2, o), value: this.substring(n2, o) };
}
function Fp(e) {
  this.tokenize(e.value);
}
var so = {};
b(so, { generate: () => jp, name: () => _p, parse: () => ao, structure: () => Up, walkContext: () => qp });
function Ca(e) {
  return this.Raw(e, this.consumeUntilLeftCurlyBracket, true);
}
function Bp() {
  let e = this.SelectorList();
  return e.type !== "Raw" && this.eof === false && this.tokenType !== 23 && this.error(), e;
}
var _p = "Rule";
var qp = "rule";
var Up = { prelude: ["SelectorList", "Raw"], block: ["Block"] };
function ao() {
  let e = this.tokenIndex, t = this.tokenStart, r, n2;
  return this.parseRulePrelude ? r = this.parseWithFallback(Bp, Ca) : r = Ca.call(this, e), n2 = this.Block(true), { type: "Rule", loc: this.getLocation(t, this.tokenStart), prelude: r, block: n2 };
}
function jp(e) {
  this.node(e.prelude), this.node(e.block);
}
var co = {};
b(co, { generate: () => Yp, name: () => Wp, parse: () => lo, structure: () => Hp });
var Wp = "Selector";
var Hp = { children: [["TypeSelector", "IdSelector", "ClassSelector", "AttributeSelector", "PseudoClassSelector", "PseudoElementSelector", "Combinator", "WhiteSpace"]] };
function lo() {
  let e = this.readSequence(this.scope.Selector);
  return this.getFirstListNode(e) === null && this.error("Selector is expected"), { type: "Selector", loc: this.getLocationFromList(e), children: e };
}
function Yp(e) {
  this.children(e);
}
var po = {};
b(po, { generate: () => Qp, name: () => Gp, parse: () => uo, structure: () => Kp, walkContext: () => Vp });
var Gp = "SelectorList";
var Vp = "selector";
var Kp = { children: [["Selector", "Raw"]] };
function uo() {
  let e = this.createList();
  for (; !this.eof; ) {
    if (e.push(this.Selector()), this.tokenType === 18) {
      this.next();
      continue;
    }
    break;
  }
  return { type: "SelectorList", loc: this.getLocationFromList(e), children: e };
}
function Qp(e) {
  this.children(e, () => this.token(18, ","));
}
var bo = {};
b(bo, { generate: () => Zp, name: () => Xp, parse: () => go, structure: () => $p });
var fo = {};
b(fo, { decode: () => ft, encode: () => mo });
var ho = 92;
var Aa = 34;
var Ta = 39;
function ft(e) {
  let t = e.length, r = e.charCodeAt(0), n2 = r === Aa || r === Ta ? 1 : 0, o = n2 === 1 && t > 1 && e.charCodeAt(t - 1) === r ? t - 2 : t - 1, i = "";
  for (let s = n2; s <= o; s++) {
    let u = e.charCodeAt(s);
    if (u === ho) {
      if (s === o) {
        s !== t - 1 && (i = e.substr(s + 1));
        break;
      }
      if (u = e.charCodeAt(++s), $(ho, u)) {
        let c2 = s - 1, a = se(e, c2);
        s = a - 1, i += Re(e.substring(c2 + 1, a));
      } else
        u === 13 && e.charCodeAt(s + 1) === 10 && s++;
    } else
      i += e[s];
  }
  return i;
}
function mo(e, t) {
  let r = t ? "'" : '"', n2 = t ? Ta : Aa, o = "", i = false;
  for (let s = 0; s < e.length; s++) {
    let u = e.charCodeAt(s);
    if (u === 0) {
      o += "\uFFFD";
      continue;
    }
    if (u <= 31 || u === 127) {
      o += "\\" + u.toString(16), i = true;
      continue;
    }
    u === n2 || u === ho ? (o += "\\" + e.charAt(s), i = false) : (i && (ee(u) || pe(u)) && (o += " "), o += e.charAt(s), i = false);
  }
  return r + o + r;
}
var Xp = "String";
var $p = { value: String };
function go() {
  return { type: "String", loc: this.getLocation(this.tokenStart, this.tokenEnd), value: ft(this.consume(5)) };
}
function Zp(e) {
  this.token(5, mo(e.value));
}
var yo = {};
b(yo, { generate: () => nh, name: () => eh, parse: () => xo, structure: () => rh, walkContext: () => th });
var Jp = 33;
function Ea(e) {
  return this.Raw(e, null, false);
}
var eh = "StyleSheet";
var th = "stylesheet";
var rh = { children: [["Comment", "CDO", "CDC", "Atrule", "Rule", "Raw"]] };
function xo() {
  let e = this.tokenStart, t = this.createList(), r;
  e:
    for (; !this.eof; ) {
      switch (this.tokenType) {
        case 13:
          this.next();
          continue;
        case 25:
          if (this.charCodeAt(this.tokenStart + 2) !== Jp) {
            this.next();
            continue;
          }
          r = this.Comment();
          break;
        case 14:
          r = this.CDO();
          break;
        case 15:
          r = this.CDC();
          break;
        case 3:
          r = this.parseWithFallback(this.Atrule, Ea);
          break;
        default:
          r = this.parseWithFallback(this.Rule, Ea);
      }
      t.push(r);
    }
  return { type: "StyleSheet", loc: this.getLocation(e, this.tokenStart), children: t };
}
function nh(e) {
  this.children(e);
}
var vo = {};
b(vo, { generate: () => sh, name: () => ih, parse: () => wo, structure: () => ah });
var oh = 42;
var La = 124;
function ko() {
  this.tokenType !== 1 && this.isDelim(oh) === false && this.error("Identifier or asterisk is expected"), this.next();
}
var ih = "TypeSelector";
var ah = { name: String };
function wo() {
  let e = this.tokenStart;
  return this.isDelim(La) ? (this.next(), ko.call(this)) : (ko.call(this), this.isDelim(La) && (this.next(), ko.call(this))), { type: "TypeSelector", loc: this.getLocation(e, this.tokenStart), name: this.substrToCursor(e) };
}
function sh(e) {
  this.tokenize(e.name);
}
var Ao = {};
b(Ao, { generate: () => hh, name: () => uh, parse: () => Co, structure: () => ph });
var Pa = 43;
var Ia = 45;
var So = 63;
function dt(e, t) {
  let r = 0;
  for (let n2 = this.tokenStart + e; n2 < this.tokenEnd; n2++) {
    let o = this.charCodeAt(n2);
    if (o === Ia && t && r !== 0)
      return dt.call(this, e + r + 1, false), -1;
    ee(o) || this.error(t && r !== 0 ? "Hyphen minus" + (r < 6 ? " or hex digit" : "") + " is expected" : r < 6 ? "Hex digit is expected" : "Unexpected input", n2), ++r > 6 && this.error("Too many hex digits", n2);
  }
  return this.next(), r;
}
function Jt(e) {
  let t = 0;
  for (; this.isDelim(So); )
    ++t > e && this.error("Too many question marks"), this.next();
}
function lh(e) {
  this.charCodeAt(this.tokenStart) !== e && this.error((e === Pa ? "Plus sign" : "Hyphen minus") + " is expected");
}
function ch() {
  let e = 0;
  switch (this.tokenType) {
    case 10:
      if (e = dt.call(this, 1, true), this.isDelim(So)) {
        Jt.call(this, 6 - e);
        break;
      }
      if (this.tokenType === 12 || this.tokenType === 10) {
        lh.call(this, Ia), dt.call(this, 1, false);
        break;
      }
      break;
    case 12:
      e = dt.call(this, 1, true), e > 0 && Jt.call(this, 6 - e);
      break;
    default:
      if (this.eatDelim(Pa), this.tokenType === 1) {
        e = dt.call(this, 0, true), e > 0 && Jt.call(this, 6 - e);
        break;
      }
      if (this.isDelim(So)) {
        this.next(), Jt.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
var uh = "UnicodeRange";
var ph = { value: String };
function Co() {
  let e = this.tokenStart;
  return this.eatIdent("u"), ch.call(this), { type: "UnicodeRange", loc: this.getLocation(e, this.tokenStart), value: this.substrToCursor(e) };
}
function hh(e) {
  this.tokenize(e.value);
}
var Do = {};
b(Do, { generate: () => yh, name: () => bh, parse: () => Io, structure: () => xh });
var Po = {};
b(Po, { decode: () => Eo, encode: () => Lo });
var mh = 32;
var To = 92;
var fh = 34;
var dh = 39;
var gh = 40;
var Da = 41;
function Eo(e) {
  let t = e.length, r = 4, n2 = e.charCodeAt(t - 1) === Da ? t - 2 : t - 1, o = "";
  for (; r < n2 && pe(e.charCodeAt(r)); )
    r++;
  for (; r < n2 && pe(e.charCodeAt(n2)); )
    n2--;
  for (let i = r; i <= n2; i++) {
    let s = e.charCodeAt(i);
    if (s === To) {
      if (i === n2) {
        i !== t - 1 && (o = e.substr(i + 1));
        break;
      }
      if (s = e.charCodeAt(++i), $(To, s)) {
        let u = i - 1, c2 = se(e, u);
        i = c2 - 1, o += Re(e.substring(u + 1, c2));
      } else
        s === 13 && e.charCodeAt(i + 1) === 10 && i++;
    } else
      o += e[i];
  }
  return o;
}
function Lo(e) {
  let t = "", r = false;
  for (let n2 = 0; n2 < e.length; n2++) {
    let o = e.charCodeAt(n2);
    if (o === 0) {
      t += "\uFFFD";
      continue;
    }
    if (o <= 31 || o === 127) {
      t += "\\" + o.toString(16), r = true;
      continue;
    }
    o === mh || o === To || o === fh || o === dh || o === gh || o === Da ? (t += "\\" + e.charAt(n2), r = false) : (r && ee(o) && (t += " "), t += e.charAt(n2), r = false);
  }
  return "url(" + t + ")";
}
var bh = "Url";
var xh = { value: String };
function Io() {
  let e = this.tokenStart, t;
  switch (this.tokenType) {
    case 7:
      t = Eo(this.consume(7));
      break;
    case 2:
      this.cmpStr(this.tokenStart, this.tokenEnd, "url(") || this.error("Function name must be `url`"), this.eat(2), this.skipSC(), t = ft(this.consume(5)), this.skipSC(), this.eof || this.eat(22);
      break;
    default:
      this.error("Url or Function is expected");
  }
  return { type: "Url", loc: this.getLocation(e, this.tokenStart), value: t };
}
function yh(e) {
  this.token(7, Lo(e.value));
}
var No = {};
b(No, { generate: () => vh, name: () => kh, parse: () => Oo, structure: () => wh });
var kh = "Value";
var wh = { children: [[]] };
function Oo() {
  let e = this.tokenStart, t = this.readSequence(this.scope.Value);
  return { type: "Value", loc: this.getLocation(e, this.tokenStart), children: t };
}
function vh(e) {
  this.children(e);
}
var Mo = {};
b(Mo, { generate: () => Th, name: () => Ch, parse: () => zo, structure: () => Ah });
var Sh = Object.freeze({ type: "WhiteSpace", loc: null, value: " " });
var Ch = "WhiteSpace";
var Ah = { value: String };
function zo() {
  return this.eat(13), Sh;
}
function Th(e) {
  this.token(13, e.value);
}
var Oa = { generic: true, ...fa, node: gt };
var Ro = {};
b(Ro, { AtrulePrelude: () => za, Selector: () => Ra, Value: () => qa });
var Eh = 35;
var Lh = 42;
var Na = 43;
var Ph = 45;
var Ih = 47;
var Dh = 117;
function bt(e) {
  switch (this.tokenType) {
    case 4:
      return this.Hash();
    case 18:
      return this.Operator();
    case 21:
      return this.Parentheses(this.readSequence, e.recognizer);
    case 19:
      return this.Brackets(this.readSequence, e.recognizer);
    case 5:
      return this.String();
    case 12:
      return this.Dimension();
    case 11:
      return this.Percentage();
    case 10:
      return this.Number();
    case 2:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, e.recognizer);
    case 7:
      return this.Url();
    case 1:
      return this.cmpChar(this.tokenStart, Dh) && this.cmpChar(this.tokenStart + 1, Na) ? this.UnicodeRange() : this.Identifier();
    case 9: {
      let t = this.charCodeAt(this.tokenStart);
      if (t === Ih || t === Lh || t === Na || t === Ph)
        return this.Operator();
      t === Eh && this.error("Hex or identifier is expected", this.tokenStart + 1);
      break;
    }
  }
}
var za = { getNode: bt };
var Oh = 35;
var Nh = 38;
var zh = 42;
var Mh = 43;
var Rh = 47;
var Ma = 46;
var Fh = 62;
var Bh = 124;
var _h = 126;
function qh(e, t) {
  t.last !== null && t.last.type !== "Combinator" && e !== null && e.type !== "Combinator" && t.push({ type: "Combinator", loc: null, name: " " });
}
function Uh() {
  switch (this.tokenType) {
    case 19:
      return this.AttributeSelector();
    case 4:
      return this.IdSelector();
    case 16:
      return this.lookupType(1) === 16 ? this.PseudoElementSelector() : this.PseudoClassSelector();
    case 1:
      return this.TypeSelector();
    case 10:
    case 11:
      return this.Percentage();
    case 12:
      this.charCodeAt(this.tokenStart) === Ma && this.error("Identifier is expected", this.tokenStart + 1);
      break;
    case 9: {
      switch (this.charCodeAt(this.tokenStart)) {
        case Mh:
        case Fh:
        case _h:
        case Rh:
          return this.Combinator();
        case Ma:
          return this.ClassSelector();
        case zh:
        case Bh:
          return this.TypeSelector();
        case Oh:
          return this.IdSelector();
        case Nh:
          return this.NestingSelector();
      }
      break;
    }
  }
}
var Ra = { onWhiteSpace: qh, getNode: Uh };
function Fa() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}
function Ba() {
  let e = this.createList();
  if (this.skipSC(), e.push(this.Identifier()), this.skipSC(), this.tokenType === 18) {
    e.push(this.Operator());
    let t = this.tokenIndex, r = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
    if (r.type === "Value" && r.children.isEmpty) {
      for (let n2 = t - this.tokenIndex; n2 <= 0; n2++)
        if (this.lookupType(n2) === 13) {
          r.children.appendData({ type: "WhiteSpace", loc: null, value: " " });
          break;
        }
    }
    e.push(r);
  }
  return e;
}
function _a(e) {
  return e !== null && e.type === "Operator" && (e.value[e.value.length - 1] === "-" || e.value[e.value.length - 1] === "+");
}
var qa = { getNode: bt, onWhiteSpace(e, t) {
  _a(e) && (e.value = " " + e.value), _a(t.last) && (t.last.value += " ");
}, expression: Fa, var: Ba };
var Ua = { parse: { prelude: null, block() {
  return this.Block(true);
} } };
var ja = { parse: { prelude() {
  let e = this.createList();
  switch (this.skipSC(), this.tokenType) {
    case 5:
      e.push(this.String());
      break;
    case 7:
    case 2:
      e.push(this.Url());
      break;
    default:
      this.error("String or url() is expected");
  }
  return (this.lookupNonWSType(0) === 1 || this.lookupNonWSType(0) === 21) && e.push(this.MediaQueryList()), e;
}, block: null } };
var Wa = { parse: { prelude() {
  return this.createSingleNodeList(this.MediaQueryList());
}, block(e = false) {
  return this.Block(e);
} } };
var Ha = { parse: { prelude() {
  return this.createSingleNodeList(this.SelectorList());
}, block() {
  return this.Block(true);
} } };
var Ya = { parse: { prelude() {
  return this.createSingleNodeList(this.SelectorList());
}, block() {
  return this.Block(true);
} } };
function jh() {
  return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
}
function Wh() {
  return this.skipSC(), this.tokenType === 1 && this.lookupNonWSType(1) === 16 ? this.createSingleNodeList(this.Declaration()) : Ga.call(this);
}
function Ga() {
  let e = this.createList(), t;
  this.skipSC();
  e:
    for (; !this.eof; ) {
      switch (this.tokenType) {
        case 25:
        case 13:
          this.next();
          continue;
        case 2:
          t = this.Function(jh, this.scope.AtrulePrelude);
          break;
        case 1:
          t = this.Identifier();
          break;
        case 21:
          t = this.Parentheses(Wh, this.scope.AtrulePrelude);
          break;
        default:
          break e;
      }
      e.push(t);
    }
  return e;
}
var Va = { parse: { prelude() {
  let e = Ga.call(this);
  return this.getFirstListNode(e) === null && this.error("Condition is expected"), e;
}, block(e = false) {
  return this.Block(e);
} } };
var Ka = { "font-face": Ua, import: ja, media: Wa, nest: Ha, page: Ya, supports: Va };
var De = { parse() {
  return this.createSingleNodeList(this.SelectorList());
} };
var Fo = { parse() {
  return this.createSingleNodeList(this.Selector());
} };
var Qa = { parse() {
  return this.createSingleNodeList(this.Identifier());
} };
var er = { parse() {
  return this.createSingleNodeList(this.Nth());
} };
var Xa = { dir: Qa, has: De, lang: Qa, matches: De, is: De, "-moz-any": De, "-webkit-any": De, where: De, not: De, "nth-child": er, "nth-last-child": er, "nth-last-of-type": er, "nth-of-type": er, slotted: Fo, host: Fo, "host-context": Fo };
var Bo = {};
b(Bo, { AnPlusB: () => Qr, Atrule: () => $r, AtrulePrelude: () => Jr, AttributeSelector: () => rn, Block: () => on, Brackets: () => sn, CDC: () => cn, CDO: () => pn, ClassSelector: () => mn, Combinator: () => dn, Comment: () => bn, Declaration: () => yn, DeclarationList: () => vn, Dimension: () => Cn, Function: () => Tn, Hash: () => Ln, IdSelector: () => On, Identifier: () => In, MediaFeature: () => zn, MediaQuery: () => Rn, MediaQueryList: () => Bn, NestingSelector: () => qn, Nth: () => jn, Number: () => Hn, Operator: () => Gn, Parentheses: () => Kn, Percentage: () => Xn, PseudoClassSelector: () => Zn, PseudoElementSelector: () => eo, Ratio: () => ro, Raw: () => oo, Rule: () => ao, Selector: () => lo, SelectorList: () => uo, String: () => go, StyleSheet: () => xo, TypeSelector: () => wo, UnicodeRange: () => Co, Url: () => Io, Value: () => Oo, WhiteSpace: () => zo });
var $a = { parseContext: { default: "StyleSheet", stylesheet: "StyleSheet", atrule: "Atrule", atrulePrelude(e) {
  return this.AtrulePrelude(e.atrule ? String(e.atrule) : null);
}, mediaQueryList: "MediaQueryList", mediaQuery: "MediaQuery", rule: "Rule", selectorList: "SelectorList", selector: "Selector", block() {
  return this.Block(true);
}, declarationList: "DeclarationList", declaration: "Declaration", value: "Value" }, scope: Ro, atrule: Ka, pseudo: Xa, node: Bo };
var Za = { node: gt };
var Ja = Vr({ ...Oa, ...$a, ...Za });
var ts = {};
b(ts, { decode: () => Hh, encode: () => Yh });
var es = 92;
function Hh(e) {
  let t = e.length - 1, r = "";
  for (let n2 = 0; n2 < e.length; n2++) {
    let o = e.charCodeAt(n2);
    if (o === es) {
      if (n2 === t)
        break;
      if (o = e.charCodeAt(++n2), $(es, o)) {
        let i = n2 - 1, s = se(e, i);
        n2 = s - 1, r += Re(e.substring(i + 1, s));
      } else
        o === 13 && e.charCodeAt(n2 + 1) === 10 && n2++;
    } else
      r += e[n2];
  }
  return r;
}
function Yh(e) {
  let t = "";
  if (e.length === 1 && e.charCodeAt(0) === 45)
    return "\\-";
  for (let r = 0; r < e.length; r++) {
    let n2 = e.charCodeAt(r);
    if (n2 === 0) {
      t += "\uFFFD";
      continue;
    }
    if (n2 <= 31 || n2 === 127 || n2 >= 48 && n2 <= 57 && (r === 0 || r === 1 && e.charCodeAt(0) === 45)) {
      t += "\\" + n2.toString(16) + " ";
      continue;
    }
    Ne(n2) ? t += e.charAt(r) : t += "\\" + e.charAt(r);
  }
  return t;
}
var { tokenize: fb, parse: db, generate: gb, lexer: bb, createLexer: xb, walk: yb, find: kb, findLast: wb, findAll: vb, toPlainObject: Sb, fromPlainObject: Cb, fork: Ab } = Ja;

// src/compiler/phases/1-parse/read/css-tree-cq/node/index.ts
var node_exports = {};
__export(node_exports, {
  Comparison: () => comparison_exports,
  ContainerFeatureStyle: () => container_feature_style_exports,
  ContainerQuery: () => container_query_exports,
  MediaQuery: () => media_query_exports,
  QueryCSSFunction: () => query_css_function_exports,
  QueryFeature: () => query_feature_exports,
  QueryFeatureRange: () => query_feature_range_exports
});

// src/compiler/phases/1-parse/read/css-tree-cq/node/comparison.ts
var comparison_exports = {};
__export(comparison_exports, {
  generate: () => generate,
  name: () => name,
  parse: () => parse6,
  structure: () => structure
});

// ../../node_modules/.pnpm/css-tree@2.3.1/node_modules/css-tree/lib/tokenizer/types.js
var EOF = 0;
var Ident = 1;
var Function2 = 2;
var Delim = 9;
var Number2 = 10;
var Dimension = 12;
var WhiteSpace = 13;
var Colon = 16;
var LeftParenthesis = 21;
var RightParenthesis = 22;
var LeftCurlyBracket = 23;
var Comment = 25;

// ../../node_modules/.pnpm/css-tree@2.3.1/node_modules/css-tree/lib/tokenizer/char-code-definitions.js
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isUppercaseLetter(code) {
  return code >= 65 && code <= 90;
}
function isLowercaseLetter(code) {
  return code >= 97 && code <= 122;
}
function isLetter(code) {
  return isUppercaseLetter(code) || isLowercaseLetter(code);
}
function isNonAscii(code) {
  return code >= 128;
}
function isNameStart(code) {
  return isLetter(code) || isNonAscii(code) || code === 95;
}
function isNonPrintable(code) {
  return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
}
function isNewline(code) {
  return code === 10 || code === 13 || code === 12;
}
function isWhiteSpace(code) {
  return isNewline(code) || code === 32 || code === 9;
}
var CATEGORY = new Array(128);
var EofCategory = 128;
var WhiteSpaceCategory = 130;
var DigitCategory = 131;
var NameStartCategory = 132;
var NonPrintableCategory = 133;
for (let i = 0; i < CATEGORY.length; i++) {
  CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
}

// ../../node_modules/.pnpm/css-tree@2.3.1/node_modules/css-tree/lib/tokenizer/adopt-buffer.js
var MIN_SIZE = 16 * 1024;

// src/compiler/phases/1-parse/read/css-tree-cq/node/comparison.ts
var name = "Comparison";
var structure = {
  value: String
};
function parse6() {
  const start = this.tokenStart;
  const char1 = this.consume(Delim);
  if (char1 !== "<" && char1 !== ">" && char1 !== "=") {
    this.error("Malformed comparison operator");
  }
  let char2;
  if (this.tokenType === Delim) {
    char2 = this.consume(Delim);
    if (char2 !== "=") {
      this.error("Malformed comparison operator");
    }
  }
  if (this.tokenType === Delim) {
    this.error("Malformed comparison operator");
  }
  const value2 = char2 ? `${char1}${char2}` : char1;
  return {
    type: "Comparison",
    loc: this.getLocation(start, this.tokenStart),
    value: value2
  };
}
function generate(node2) {
  for (let index = 0; index < node2.value.length; index++) {
    this.token(Delim, node2.value.charAt(index));
  }
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/container_feature_style.ts
var container_feature_style_exports = {};
__export(container_feature_style_exports, {
  generate: () => generate2,
  name: () => name2,
  parse: () => parse7,
  structure: () => structure2
});
var name2 = "ContainerFeatureStyle";
var structure2 = {
  name: String,
  value: ["Function", "Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse7() {
  const start = this.tokenStart;
  let value2 = null;
  const function_name = this.consumeFunctionName();
  if (function_name !== "style") {
    this.error('Unknown container style query identifier; "style" is expected');
  }
  this.skipSC();
  const name8 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value2 = this.Ratio();
        } else {
          value2 = this.Number();
        }
        break;
      case Dimension:
        value2 = this.Dimension();
        break;
      case Function2:
        value2 = this.QueryCSSFunction();
        break;
      case Ident:
        value2 = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "ContainerFeatureStyle",
    loc: this.getLocation(start, this.tokenStart),
    name: name8,
    value: value2
  };
}
function generate2(node2) {
  this.token(Function2, "style(");
  this.token(Ident, node2.name);
  if (node2.value !== null) {
    this.token(Colon, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis, ")");
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/container_query.ts
var container_query_exports = {};
__export(container_query_exports, {
  generate: () => generate3,
  name: () => name3,
  parse: () => parse8,
  structure: () => structure3
});

// src/compiler/phases/1-parse/read/css-tree-cq/node/lookahead_is_range.ts
function lookahead_is_range() {
  let type;
  let offset2 = 0;
  let count = 0;
  let delim_found = false;
  let no_colon = true;
  do {
    type = this.lookupNonWSType(offset2++);
    if (type !== WhiteSpace) {
      count++;
    }
    if (type === Delim) {
      delim_found = true;
    }
    if (type === Colon) {
      no_colon = false;
    }
    if (type === LeftCurlyBracket || type === RightParenthesis) {
      break;
    }
  } while (type !== EOF && count <= 6);
  return delim_found && no_colon;
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/container_query.ts
var CONTAINER_QUERY_KEYWORDS = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
var name3 = "ContainerQuery";
var structure3 = {
  name: "Identifier",
  children: [
    ["Identifier", "QueryFeature", "QueryFeatureRange", "ContainerFeatureStyle", "WhiteSpace"]
  ]
};
function parse8() {
  const start = this.tokenStart;
  const children = this.createList();
  let child = null;
  let name8 = null;
  if (this.tokenType === Ident) {
    const container_name = this.substring(this.tokenStart, this.tokenEnd);
    if (!CONTAINER_QUERY_KEYWORDS.has(container_name.toLowerCase())) {
      name8 = container_name;
      this.eatIdent(container_name);
    }
  }
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case Function2:
          child = this.ContainerFeatureStyle();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "ContainerQuery",
    loc: this.getLocation(start, this.tokenStart - 1),
    name: name8,
    children
  };
}
function generate3(node2) {
  if (typeof node2.name === "string") {
    this.token(Ident, node2.name);
  }
  this.children(node2);
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/media_query.ts
var media_query_exports = {};
__export(media_query_exports, {
  generate: () => generate4,
  name: () => name4,
  parse: () => parse9,
  structure: () => structure4
});
var name4 = "MediaQuery";
var structure4 = {
  children: [["Identifier", "QueryFeature", "QueryFeatureRange", "WhiteSpace"]]
};
function parse9() {
  const children = this.createList();
  let child = null;
  this.skipSC();
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
        case WhiteSpace:
          this.next();
          continue;
        case Ident:
          child = this.Identifier();
          break;
        case LeftParenthesis:
          child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
          break;
        default:
          break scan;
      }
      children.push(child);
    }
  if (child === null) {
    this.error("Identifier or parenthesis is expected");
  }
  return {
    type: "MediaQuery",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate4(node2) {
  this.children(node2);
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/query_feature.ts
var query_feature_exports = {};
__export(query_feature_exports, {
  generate: () => generate5,
  name: () => name5,
  parse: () => parse10,
  structure: () => structure5
});
var name5 = "QueryFeature";
var structure5 = {
  name: String,
  value: ["Identifier", "Number", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function parse10() {
  const start = this.tokenStart;
  let value2 = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  const name8 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number2:
        if (this.lookupNonWSType(1) === Delim) {
          value2 = this.Ratio();
        } else {
          value2 = this.Number();
        }
        break;
      case Dimension:
        value2 = this.Dimension();
        break;
      case Function2:
        value2 = this.QueryCSSFunction();
        break;
      case Ident:
        value2 = this.Identifier();
        break;
      default:
        this.error("Number, dimension, ratio, function, or identifier is expected");
        break;
    }
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeature",
    loc: this.getLocation(start, this.tokenStart),
    name: name8,
    value: value2
  };
}
function generate5(node2) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node2.name);
  if (node2.value !== null) {
    this.token(Colon, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis, ")");
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/query_feature_range.ts
var query_feature_range_exports = {};
__export(query_feature_range_exports, {
  generate: () => generate6,
  name: () => name6,
  parse: () => parse11,
  structure: () => structure6
});
var name6 = "QueryFeatureRange";
var structure6 = {
  name: String,
  value: ["Identifier", "Number", "Comparison", "Dimension", "QueryCSSFunction", "Ratio", null]
};
function lookup_non_ws_type_and_value(offset2, type, reference_str) {
  let current_type;
  do {
    current_type = this.lookupType(offset2++);
    if (current_type !== WhiteSpace) {
      break;
    }
  } while (current_type !== 0);
  return current_type === type ? this.lookupValue(offset2 - 1, reference_str) : false;
}
function parse11() {
  const start = this.tokenStart;
  const children = this.createList();
  let child = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  while (!this.eof && this.tokenType !== RightParenthesis) {
    switch (this.tokenType) {
      case Number2:
        if (lookup_non_ws_type_and_value.call(this, 1, Delim, "/")) {
          child = this.Ratio();
        } else {
          child = this.Number();
        }
        break;
      case Delim:
        child = this.Comparison();
        break;
      case Dimension:
        child = this.Dimension();
        break;
      case Function2:
        child = this.QueryCSSFunction();
        break;
      case Ident:
        child = this.Identifier();
        break;
      default:
        this.error("Number, dimension, comparison, ratio, function, or identifier is expected");
        break;
    }
    children.push(child);
    this.skipSC();
  }
  this.eat(RightParenthesis);
  return {
    type: "QueryFeatureRange",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate6(node2) {
  this.children(node2);
}

// src/compiler/phases/1-parse/read/css-tree-cq/node/query_css_function.ts
var query_css_function_exports = {};
__export(query_css_function_exports, {
  generate: () => generate7,
  name: () => name7,
  parse: () => parse12,
  structure: () => structure7
});
var QUERY_CSS_FUNCTIONS = /* @__PURE__ */ new Set(["calc", "clamp", "min", "max"]);
var name7 = "QueryCSSFunction";
var structure7 = {
  name: String,
  expression: String
};
function parse12() {
  const start = this.tokenStart;
  const name8 = this.consumeFunctionName();
  if (!QUERY_CSS_FUNCTIONS.has(name8)) {
    this.error('Unknown query single value function; expected: "calc", "clamp", "max", min"');
  }
  const body = this.Raw(this.tokenIndex, null, false);
  this.eat(RightParenthesis);
  return {
    type: "QueryCSSFunction",
    loc: this.getLocation(start, this.tokenStart),
    name: name8,
    expression: body.value
  };
}
function generate7(node2) {
  this.token(Function, `${node2.name}(`);
  this.node(node2.expression);
  this.token(RightParenthesis, ")");
}

// src/compiler/phases/1-parse/read/css-tree-cq/css_tree_parse.ts
var cq_syntax = Ab({
  atrule: {
    // extend or override at-rule dictionary
    container: {
      parse: {
        prelude() {
          return this.createSingleNodeList(this.ContainerQuery());
        },
        block(is_style_block = false) {
          return this.Block(is_style_block);
        }
      }
    }
  },
  node: node_exports
});
var parse13 = cq_syntax.parse;

// ../../node_modules/.pnpm/zimmerframe@0.2.1/node_modules/zimmerframe/src/walk.js
function walk(node2, state, visitors) {
  const universal = visitors._;
  let stopped = false;
  function default_visitor(_2, { next: next2, state: state2 }) {
    next2(state2);
  }
  function visit(node3, path, state2) {
    if (stopped)
      return node3;
    if (!node3.type)
      return node3;
    let result;
    const mutations = {};
    const context = {
      path,
      state: state2,
      next: (next_state = state2) => {
        path.push(node3);
        for (const key2 in node3) {
          if (key2 === "type")
            continue;
          const child_node = node3[key2];
          if (child_node && typeof child_node === "object") {
            if (Array.isArray(child_node)) {
              const array_mutations = {};
              child_node.forEach((node4, i) => {
                if (node4 && typeof node4 === "object") {
                  const result2 = visit(node4, path, next_state);
                  if (result2)
                    array_mutations[i] = result2;
                }
              });
              if (Object.keys(array_mutations).length > 0) {
                mutations[key2] = child_node.map(
                  (node4, i) => array_mutations[i] ?? node4
                );
              }
            } else {
              const result2 = visit(
                /** @type {T} */
                child_node,
                path,
                next_state
              );
              if (result2) {
                mutations[key2] = result2;
              }
            }
          }
        }
        path.pop();
      },
      stop: () => {
        stopped = true;
      },
      visit: (next_node, next_state = state2) => {
        path.push(node3);
        const result2 = visit(next_node, path, next_state) ?? next_node;
        path.pop();
        return result2;
      }
    };
    let visitor = (
      /** @type {import('./types').Visitor<T, U, T>} */
      visitors[
        /** @type {T['type']} */
        node3.type
      ] ?? default_visitor
    );
    if (universal) {
      let inner_result;
      result = universal(node3, {
        ...context,
        /** @param {U} next_state */
        next: (next_state = state2) => {
          state2 = next_state;
          inner_result = visitor(node3, {
            ...context,
            state: next_state
          });
        }
      });
      if (!result && inner_result) {
        result = inner_result;
      }
    } else {
      result = visitor(node3, context);
    }
    if (!result) {
      if (Object.keys(mutations).length > 0) {
        result = { ...node3, ...mutations };
      }
    }
    if (result) {
      return result;
    }
  }
  return visit(node2, [], state) ?? node2;
}

// src/compiler/phases/1-parse/read/style.ts
var regex_closing_style_tag = /<\/style\s*>/;
var regex_starts_with_closing_style_tag = /^<\/style\s*>/;
function read_style(parser, start, attributes2) {
  const content_start = parser.index;
  const styles = parser.read_until(regex_closing_style_tag);
  if (parser.index >= parser.template.length) {
    error(parser.template.length, "unclosed-element", "style");
  }
  const content_end = parser.index;
  let ast;
  try {
    ast = parse13(styles, {
      positions: true,
      offset: content_start,
      onParseError(error2) {
        throw error2;
      }
    });
  } catch (err) {
    if (err.name === "SyntaxError") {
      error(err.offset, "css-parse-error", err.message);
    } else {
      throw err;
    }
  }
  ast = JSON.parse(JSON.stringify(ast));
  walk(ast, null, {
    _(node2) {
      if (node2.loc) {
        node2.start = node2.loc.start.offset;
        node2.end = node2.loc.end.offset;
        delete node2.loc;
      }
    },
    Declaration(node2) {
      if (node2.value.type === "Value" && node2.value.children.length === 0) {
        error(node2.start, "invalid-css-empty-declaration");
      }
    },
    PseudoClassSelector: (node2) => {
      if (node2.name === "global" && node2.children === null) {
        error(node2.start, "invalid-css-global-selector");
      }
    }
  });
  parser.read(regex_starts_with_closing_style_tag);
  const end = parser.index;
  return {
    type: "Style",
    start,
    end,
    attributes: attributes2,
    children: ast.children,
    content: {
      start: content_start,
      end: content_end,
      styles
    },
    parent: null
  };
}

// src/compiler/phases/1-parse/utils/entities.ts
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// src/compiler/phases/1-parse/utils/html.ts
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html.replace(entity_pattern, (match, entity) => {
    let code;
    if (entity[0] !== "#") {
      code = entities_default[entity];
    } else if (entity[1] === "x") {
      code = parseInt(entity.substring(2), 16);
    } else {
      code = parseInt(entity.substring(1), 10);
    }
    if (!code) {
      return match;
    }
    return String.fromCodePoint(validate_code(code));
  });
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  return NUL;
}
var disallowed_contents = {
  li: /* @__PURE__ */ new Set(["li"]),
  dt: /* @__PURE__ */ new Set(["dt", "dd"]),
  dd: /* @__PURE__ */ new Set(["dt", "dd"]),
  p: new Set(
    "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(
      " "
    )
  ),
  rt: /* @__PURE__ */ new Set(["rt", "rp"]),
  rp: /* @__PURE__ */ new Set(["rt", "rp"]),
  optgroup: /* @__PURE__ */ new Set(["optgroup"]),
  option: /* @__PURE__ */ new Set(["option", "optgroup"]),
  thead: /* @__PURE__ */ new Set(["tbody", "tfoot"]),
  tbody: /* @__PURE__ */ new Set(["tbody", "tfoot"]),
  tfoot: /* @__PURE__ */ new Set(["tbody"]),
  tr: /* @__PURE__ */ new Set(["tr", "tbody"]),
  td: /* @__PURE__ */ new Set(["td", "th", "tr"]),
  th: /* @__PURE__ */ new Set(["td", "th", "tr"])
};
function closing_tag_omitted(current2, next2) {
  if (disallowed_contents[current2]) {
    if (!next2 || disallowed_contents[current2].has(next2)) {
      return true;
    }
  }
  return false;
}

// src/compiler/phases/1-parse/utils/create.ts
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    transparent
  };
}

// src/compiler/phases/1-parse/state/tag.ts
var valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "Head"],
  ["svelte:options", "Options"],
  ["svelte:window", "Window"],
  ["svelte:document", "Document"],
  ["svelte:body", "Body"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "DynamicElement"],
  ["svelte:component", "DynamicComponent"],
  ["svelte:self", "SelfElement"],
  ["svelte:fragment", "SlotTemplate"]
]);
var valid_meta_tags = Array.from(meta_tags.keys());
var SELF = /^svelte:self(?=[\s/>])/;
var COMPONENT = /^svelte:component(?=[\s/>])/;
var SLOT = /^svelte:fragment(?=[\s/>])/;
var ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "Head")
      return true;
    if (type === "RegularElement" || type === "InlineComponent")
      return false;
  }
  return false;
}
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_capital_letter = /[A-Z]/;
function tag(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data2 = parser.read_until(regex_closing_comment);
    parser.eat("-->", true);
    parser.append({
      type: "Comment",
      start,
      end: parser.index,
      data: data2,
      ignores: extract_svelte_ignore(data2)
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name8 = read_tag_name(parser);
  if (root_only_meta_tags.has(name8)) {
    if (is_closing_tag) {
      if ((name8 === "svelte:window" || name8 === "svelte:body" || name8 === "svelte:document") && parent.fragment.nodes.length) {
        error(
          parent.fragment.nodes[0].start,
          "invalid-element-content",
          name8
        );
      }
    } else {
      if (name8 in parser.meta_tags) {
        error(start, "duplicate-svelte-element", name8);
      }
      if (parent.type !== "Root") {
        error(start, "invalid-svelte-element-placement", name8);
      }
      parser.meta_tags[name8] = true;
    }
  }
  const type = meta_tags.has(name8) ? meta_tags.get(name8) : regex_capital_letter.test(name8[0]) || name8 === "svelte:self" || name8 === "svelte:component" ? "InlineComponent" : name8 === "title" && parent_is_head(parser.stack) ? "Title" : name8 === "slot" && !parser.customElement ? "Slot" : "RegularElement";
  const element = {
    type,
    start,
    end: -1,
    name: name8,
    attributes: [],
    fragment: create_fragment(true),
    parent: null
  };
  parser.allow_whitespace();
  if (is_closing_tag) {
    if (is_void(name8)) {
      error(start, "invalid-void-content");
    }
    parser.eat(">", true);
    while (parent.name !== name8) {
      if (parent.type !== "RegularElement") {
        if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name8) {
          error(
            start,
            "invalid-closing-tag-after-autoclose",
            name8,
            parser.last_auto_closed_tag.reason
          );
        } else {
          error(start, "invalid-closing-tag", name8);
        }
      }
      parent.end = start;
      parser.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = void 0;
    }
    return;
  } else if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name8)) {
    parent.end = start;
    parser.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name8,
      depth: parser.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  let attribute;
  while (attribute = read_attribute(parser, unique_names)) {
    element.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (element.type === "DynamicComponent") {
    const index = element.attributes.findIndex(
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      error(start, "missing-svelte-component-definition");
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") {
      error(definition.start, "invalid-svelte-component-definition");
    }
    element.expression = definition.value[0].expression;
  }
  if (element.type === "DynamicElement") {
    const index = element.attributes.findIndex(
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      error(start, "missing-svelte-element-definition");
    }
    const definition = element.attributes.splice(index, 1)[0];
    if (definition.value === true || definition.value.length !== 1) {
      error(definition.start, "invalid-svelte-element-definition");
    }
    const chunk = definition.value[0];
    element.tag = chunk.type === "Text" ? chunk.data : chunk.expression;
  }
  const current2 = parser.current();
  if ((name8 === "script" || name8 === "style") && current2.type === "Root") {
    parser.eat(">", true);
    if (name8 === "script") {
      const content = read_script(parser, start, element.attributes);
      if (content)
        current2.js.push(content);
    } else {
      const content = read_style(parser, start, element.attributes);
      if (content)
        current2.css.push(content);
    }
    return;
  }
  parser.append(element);
  const self_closing = parser.eat("/") || is_void(name8);
  parser.eat(">", true);
  if (self_closing) {
    element.end = parser.index;
  } else if (name8 === "textarea") {
    element.fragment.nodes = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element.end = parser.index;
  } else if (name8 === "script" || name8 === "style") {
    const start2 = parser.index;
    const data2 = parser.read_until(new RegExp(`</${name8}>`));
    const end = parser.index;
    const node2 = {
      start: start2,
      end,
      type: "Text",
      data: data2,
      raw: data2,
      parent: null
    };
    element.fragment.nodes.push(node2);
    parser.eat(`</${name8}>`, true);
    element.end = parser.index;
  } else {
    parser.stack.push(element);
    parser.fragments.push(element.fragment);
  }
}
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
function read_tag_name(parser) {
  const start = parser.index;
  if (parser.read(SELF)) {
    let i = parser.stack.length;
    let legal = false;
    while (i--) {
      const fragment2 = parser.stack[i];
      if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      error(start, "invalid-self-placement");
    }
    return "svelte:self";
  }
  if (parser.read(COMPONENT))
    return "svelte:component";
  if (parser.read(ELEMENT))
    return "svelte:element";
  if (parser.read(SLOT))
    return "svelte:fragment";
  const name8 = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (meta_tags.has(name8))
    return name8;
  if (name8.startsWith("svelte:")) {
    const match = fuzzymatch(name8.slice(7), valid_meta_tags);
    error(start, "invalid-svelte-tag", valid_meta_tags, match);
  }
  if (!valid_tag_name.test(name8)) {
    error(start, "invalid-tag-name");
  }
  return name8;
}
var regex_token_ending_character = /[\s=\/>"']/;
var regex_starts_with_quote_characters = /^["']/;
function read_attribute(parser, unique_names) {
  const start = parser.index;
  function check_unique(name9) {
    if (unique_names.has(name9)) {
      error(start, "duplicate-attribute");
    }
    unique_names.add(name9);
  }
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const spread = {
        type: "Spread",
        start,
        end: parser.index,
        expression,
        parent: null
      };
      return spread;
    } else {
      const value_start = parser.index;
      const name9 = parser.read_identifier();
      if (name9 === null) {
        error(start, "empty-attribute-shorthand");
      }
      check_unique(name9);
      parser.allow_whitespace();
      parser.eat("}", true);
      const shorthand = {
        type: "AttributeShorthand",
        start: value_start,
        end: value_start + name9.length,
        expression: {
          start: value_start,
          end: value_start + name9.length,
          type: "Identifier",
          name: name9
        },
        parent: null
      };
      return {
        start,
        end: parser.index,
        type: "Attribute",
        name: name9,
        value: [shorthand],
        parent: null
      };
    }
  }
  const name8 = parser.read_until(regex_token_ending_character);
  if (!name8)
    return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name8.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name8.slice(0, colon_index));
  let value2 = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    value2 = read_attribute_value(parser);
    end = parser.index;
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    error(parser.index, "expected-token", "=");
  }
  if (type) {
    const [directive_name, ...modifiers] = name8.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      error(start + colon_index + 1, "empty-directive-name", type);
    }
    if (type === "BindDirective" && directive_name !== "this") {
      check_unique(directive_name);
    } else if (type !== "OnDirective" && type !== "UseDirective") {
      check_unique(name8);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers,
        value: value2,
        parent: null
      };
    }
    const first_value = value2 === true ? void 0 : value2[0];
    let expression = null;
    if (first_value) {
      const attribute_contains_text = value2.length > 1 || first_value.type === "Text";
      if (attribute_contains_text) {
        error(first_value.start, "invalid-directive-value");
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      modifiers,
      expression
    };
    if (directive.type === "TransitionDirective") {
      const direction = name8.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = {
        start: start + colon_index + 1,
        end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  check_unique(name8);
  return {
    start,
    end,
    type: "Attribute",
    name: name8,
    value: value2,
    parent: null
  };
}
function get_directive_type(name8) {
  if (name8 === "use")
    return "UseDirective";
  if (name8 === "animate")
    return "AnimateDirective";
  if (name8 === "bind")
    return "BindDirective";
  if (name8 === "class")
    return "ClassDirective";
  if (name8 === "style")
    return "StyleDirective";
  if (name8 === "on")
    return "OnDirective";
  if (name8 === "let")
    return "LetDirective";
  if (name8 === "in" || name8 === "out" || name8 === "transition")
    return "TransitionDirective";
  return false;
}
function read_attribute_value(parser) {
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: "",
        parent: null
      }
    ];
  }
  let value2;
  try {
    value2 = read_sequence(
      parser,
      () => {
        if (quote_mark)
          return parser.match(quote_mark);
        return !!parser.match_regex(regex_starts_with_invalid_attr_value);
      },
      "in attribute value"
    );
  } catch (e) {
    if (e.code === "parse-error") {
      if (parser.template.slice(e.pos - 1, e.pos + 1) === "/>") {
        parser.index = e.pos;
        error(e.pos, "unclosed-attribute-value", quote_mark || "}");
      }
    }
    throw e;
  }
  if (value2.length === 0 && !quote_mark) {
    error(parser.index, "missing-attribute-value");
  }
  if (quote_mark)
    parser.index += 1;
  return value2;
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: -1,
    type: "Text",
    raw: "",
    data: "",
    parent: null
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name8 = parser.read_until(/[^a-z]/);
        error(index2, "invalid-block-placement", location, name8);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name8 = parser.read_until(/[^a-z]/);
        error(index2, "invalid-tag-placement", location, name8);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const chunk = {
        type: "MustacheTag",
        start: index,
        end: parser.index,
        expression,
        parent: null,
        metadata: {
          // TODO remove this
          skip_escape: false,
          contains_call_expression: false
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser.index,
        end: -1,
        type: "Text",
        raw: "",
        data: "",
        parent: null
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  error(parser.template.length, "unexpected-eof");
}

// src/compiler/phases/1-parse/utils/full_char_code_at.ts
function full_char_code_at(str, i) {
  const code = str.charCodeAt(i);
  if (code <= 55295 || code >= 57344)
    return code;
  const next2 = str.charCodeAt(i + 1);
  return (code << 10) + next2 - 56613888;
}

// src/compiler/phases/1-parse/utils/bracket.ts
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code) {
  return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code) {
  return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open2, close2) {
  return open2 === SQUARE_BRACKET_OPEN && close2 === SQUARE_BRACKET_CLOSE || open2 === CURLY_BRACKET_OPEN && close2 === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open2) {
  if (open2 === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open2 === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}

// src/compiler/phases/1-parse/read/context.ts
function read_context(parser) {
  const start = parser.index;
  let i = parser.index;
  const code = full_char_code_at(parser.template, i);
  if (isIdentifierStart(code, true)) {
    return {
      type: "Identifier",
      name: parser.read_identifier(),
      start,
      end: parser.index
    };
  }
  if (!is_bracket_open(code)) {
    error(i, "expected-pattern");
  }
  const bracket_stack = [code];
  i += code <= 65535 ? 1 : 2;
  while (i < parser.template.length) {
    const code2 = full_char_code_at(parser.template, i);
    if (is_bracket_open(code2)) {
      bracket_stack.push(code2);
    } else if (is_bracket_close(code2)) {
      const popped = bracket_stack.pop();
      if (!is_bracket_pair(popped, code2)) {
        error(i, "expected-token", String.fromCharCode(get_bracket_close(popped)));
      }
      if (bracket_stack.length === 0) {
        i += code2 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code2 <= 65535 ? 1 : 2;
  }
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
  } catch (error2) {
    parser.acorn_error(error2);
  }
}

// src/compiler/phases/1-parse/state/mustache.ts
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function mustache(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("#"))
    return open(parser);
  if (parser.eat("/"))
    return close(parser);
  if (parser.eat(":"))
    return next(parser);
  if (parser.eat("@"))
    return special(parser);
  const expression = read_expression(parser);
  parser.allow_whitespace();
  parser.eat("}", true);
  parser.append({
    type: "MustacheTag",
    start,
    end: parser.index,
    expression,
    metadata: {
      // TODO what's this? can we get rid of it?
      skip_escape: false,
      contains_call_expression: false
    }
  });
}
function open(parser) {
  const start = parser.index - 2;
  if (parser.eat("if")) {
    parser.require_whitespace();
    const block2 = parser.append({
      type: "IfBlock",
      elseif: false,
      start,
      end: -1,
      test: read_expression(parser),
      consequent: create_fragment(),
      alternate: null
    });
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.stack.push(block2);
    parser.fragments.push(block2.consequent);
    return;
  }
  if (parser.eat("each")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("as", true);
    parser.require_whitespace();
    const context = read_context(parser);
    parser.allow_whitespace();
    let index;
    let key2;
    if (parser.eat(",")) {
      parser.allow_whitespace();
      index = parser.read_identifier();
      if (!index) {
        error(parser.index, "expected-identifier");
      }
      parser.allow_whitespace();
    }
    if (parser.eat("(")) {
      parser.allow_whitespace();
      key2 = read_expression(parser);
      parser.allow_whitespace();
      parser.eat(")", true);
      parser.allow_whitespace();
    }
    parser.eat("}", true);
    const block2 = parser.append({
      type: "EachBlock",
      start,
      end: -1,
      expression,
      body: create_fragment(),
      context,
      index,
      key: key2,
      // @ts-expect-error filled in later
      metadata: null
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  if (parser.eat("await")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    const block2 = parser.append({
      type: "AwaitBlock",
      start,
      end: -1,
      expression,
      value: null,
      error: null,
      pending: null,
      then: null,
      catch: null
    });
    if (parser.eat("then")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.value = read_context(parser);
        parser.allow_whitespace();
      }
      block2.then = create_fragment();
      parser.fragments.push(block2.then);
    } else if (parser.eat("catch")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.error = read_context(parser);
        parser.allow_whitespace();
      }
      block2.catch = create_fragment();
      parser.fragments.push(block2.catch);
    } else {
      block2.pending = create_fragment();
      parser.fragments.push(block2.pending);
    }
    parser.eat("}", true);
    parser.stack.push(block2);
    return;
  }
  if (parser.eat("key")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "KeyBlock",
      start,
      end: -1,
      expression,
      fragment: create_fragment()
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.fragment);
    return;
  }
  error(parser.index, "expected-block-type");
}
function next(parser) {
  const start = parser.index - 1;
  const block2 = parser.current();
  if (block2.type === "IfBlock") {
    if (!parser.eat("else"))
      error(start, "expected-token", "else");
    if (parser.eat("if"))
      error(start, "invalid-elseif");
    parser.allow_whitespace();
    parser.fragments.pop();
    block2.alternate = create_fragment();
    parser.fragments.push(block2.alternate);
    if (parser.eat("if")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const child = parser.append({
        start: parser.index,
        end: -1,
        type: "IfBlock",
        elseif: true,
        test: expression,
        consequent: create_fragment(),
        alternate: null
      });
      parser.stack.push(child);
      parser.fragments.pop();
      parser.fragments.push(child.consequent);
    } else {
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    return;
  }
  if (block2.type === "EachBlock") {
    if (!parser.eat("else"))
      error(start, "expected-token", "else");
    parser.allow_whitespace();
    parser.eat("}", true);
    block2.fallback = create_fragment();
    parser.fragments.pop();
    parser.fragments.push(block2.fallback);
    return;
  }
  if (block2.type === "AwaitBlock") {
    if (parser.eat("then")) {
      if (block2.then) {
        error(start, "TODO", "duplicate then");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.value = read_context(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.then = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.then);
      return;
    }
    if (parser.eat("catch")) {
      if (block2.catch) {
        error(start, "TODO", "duplicate catch");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.error = read_context(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.catch = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.catch);
      return;
    }
    error(start, "expected-token", "{:then ...} or {:catch ...}");
  }
}
function close(parser) {
  const start = parser.index - 1;
  let block2 = parser.current();
  switch (block2.type) {
    case "IfBlock":
      parser.eat("if", true);
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block2.elseif) {
        block2.end = parser.index;
        parser.stack.pop();
        block2 = parser.current();
      }
      parser.pop();
      return;
    case "EachBlock":
      parser.eat("each", true);
      break;
    case "KeyBlock":
      parser.eat("key", true);
      break;
    case "AwaitBlock":
      parser.eat("await", true);
      break;
    default:
      error(start, "unexpected-block-close");
  }
  parser.allow_whitespace();
  parser.eat("}", true);
  block2.end = parser.index;
  parser.pop();
}
function special(parser) {
  const start = parser.index - 1;
  if (parser.eat("html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "RawMustacheTag",
      start,
      end: parser.index,
      expression
    });
    return;
  }
  if (parser.eat("debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? expression.expressions : [expression];
      identifiers.forEach((node2) => {
        if (node2.type !== "Identifier") {
          error(node2.start, "invalid-debug");
        }
      });
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.append({
      type: "DebugTag",
      start,
      end: parser.index,
      identifiers
    });
    return;
  }
  if (parser.eat("const")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) {
      error(start, "invalid-const");
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "ConstTag",
      start,
      end: parser.index,
      expression
    });
  }
}

// src/compiler/phases/1-parse/state/text.ts
function text(parser) {
  const start = parser.index;
  let data2 = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data2 += parser.template[parser.index++];
  }
  parser.append({
    type: "Text",
    start,
    end: parser.index,
    raw: data2,
    data: decode_character_references(data2, false)
  });
}

// src/compiler/phases/1-parse/state/fragment.ts
function fragment(parser) {
  if (parser.match("<")) {
    return tag;
  }
  if (parser.match("{")) {
    return mustache;
  }
  return text;
}

// src/compiler/phases/1-parse/index.ts
var regex_position_indicator = / \(\d+:\d+\)$/;
var Parser11 = class {
  template;
  filename;
  customElement;
  index = 0;
  stack = [];
  fragments = [];
  root;
  meta_tags = {};
  last_auto_closed_tag;
  constructor(template2, options) {
    if (typeof template2 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template2.trimRight();
    this.filename = options.filename;
    this.customElement = options.customElement ?? false;
    this.root = {
      css: [],
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: {}
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      if (current2.type === "RegularElement") {
        error(current2, "unclosed-element", current2.name);
      } else {
        error(current2, "unclosed-block");
      }
    }
    if (state !== fragment) {
      error(this.index, "unexpected-eof");
    }
    if (this.root.fragment.nodes.length) {
      let start = this.root.fragment.nodes[0].start;
      while (regex_whitespace.test(template2[start]))
        start += 1;
      let end = this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end;
      while (regex_whitespace.test(template2[end - 1]))
        end -= 1;
      this.root.start = start;
      this.root.end = end;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex((thing) => thing.type === "Options");
    if (options_index !== -1) {
      const options2 = this.root.fragment.nodes[options_index];
      this.root.fragment.nodes.splice(options_index, 1);
      for (const attribute of options2.attributes) {
        if (attribute.type !== "Attribute") {
          error(attribute, "invalid-svelte-option-attribute");
        }
        let value2 = true;
        if (Array.isArray(attribute.value)) {
          if (attribute.value.length !== 1) {
            throw new Error("TODO");
          }
          const node2 = attribute.value[0];
          if (node2.type === "MustacheTag") {
            if (node2.expression.type !== "Literal") {
              throw new Error("TODO");
            }
            value2 = node2.expression.value;
          } else {
            value2 = node2.data;
          }
        }
        if (!["runes", "immutable", "accessors", "namespace"].includes(attribute.name)) {
          throw new Error(`TODO handle '${attribute.name}' option`);
        }
        if (attribute.name === "namespace") {
          if (value2 === "http://www.w3.org/2000/svg") {
            this.root.options.namespace = "svg";
          } else if (value2 === "html" || value2 === "svg") {
            this.root.options.namespace = value2;
          } else {
            error(attribute, "invalid-svelte-option-namespace");
          }
        } else {
          this.root.options[attribute.name] = value2;
        }
      }
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  acorn_error(err) {
    error(err.pos, "js-parse-error", err.message.replace(regex_position_indicator, ""));
  }
  eat(str, required) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required) {
      if (this.index === this.template.length) {
        error(this.index, "unexpected-eof");
      } else {
        error(this.index, "expected-token", str);
      }
    }
    return false;
  }
  match(str) {
    return this.template.slice(this.index, this.index + str.length) === str;
  }
  /**
   * Match a regex at the current index
   * @param pattern Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0)
      return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param pattern Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result)
      this.index += result.length;
    return result;
  }
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code, true))
      return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code2, true))
        break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && reserved.includes(identifier)) {
      error(start, "unexpected-reserved-word", identifier);
    }
    return identifier;
  }
  read_until(pattern) {
    if (this.index >= this.template.length) {
      error(this.template.length, "unexpected-eof");
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      error(this.index, "missing-whitespace");
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  append(node2) {
    const current2 = this.current();
    const fragment2 = this.fragments.at(-1);
    Object.defineProperties(node2, {
      prev: {
        enumerable: false,
        value: fragment2.nodes.at(-1) ?? null
      },
      parent: {
        enumerable: false,
        value: current2
      }
    });
    fragment2.nodes.push(node2);
    return node2;
  }
};
function parse14(template2, options) {
  const parser = new Parser11(template2, options);
  return parser.root;
}

// ../../node_modules/.pnpm/is-reference@3.0.1/node_modules/is-reference/src/index.js
function is_reference(node2, parent) {
  if (node2.type === "MemberExpression") {
    return !node2.computed && is_reference(node2.object, node2);
  }
  if (node2.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node2 === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "PropertyDefinition":
        return parent.computed || node2 === parent.value;
      case "Property":
        return parent.computed || node2 === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node2 === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}

// src/compiler/utils/assert.js
function ok(value2) {
  if (!value2)
    error(null, "INTERNAL", "Assertion failed");
}
function equal(actual, expected) {
  if (actual !== expected)
    error(null, "INTERNAL", "Assertion failed");
}

// src/compiler/utils/builders.ts
function array(elements2 = []) {
  return { type: "ArrayExpression", elements: elements2 };
}
function array_pattern(elements2) {
  return { type: "ArrayPattern", elements: elements2 };
}
function arrow(params, body) {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    expression: body.type !== "BlockStatement",
    generator: false,
    async: false,
    metadata: null
    // should not be used by codegen
  };
}
function assignment(operator, left, right) {
  return {
    type: "AssignmentExpression",
    operator,
    left,
    right
  };
}
function binary(operator, left, right) {
  return {
    type: "BinaryExpression",
    operator,
    left,
    right
  };
}
function block(body) {
  return { type: "BlockStatement", body };
}
function call(callee, ...args) {
  if (typeof callee === "string")
    callee = id(callee);
  args = args.slice();
  while (args.length > 0 && !args.at(-1))
    args.pop();
  return {
    type: "CallExpression",
    callee,
    arguments: args,
    optional: false
  };
}
function conditional(test, consequent, alternate) {
  return { type: "ConditionalExpression", test, consequent, alternate };
}
function declaration(kind, pattern, init2) {
  if (typeof pattern === "string")
    pattern = id(pattern);
  return {
    type: "VariableDeclaration",
    kind,
    declarations: [init2 ? declarator(pattern, init2) : declarator(pattern)]
  };
}
function declarator(id2, init2) {
  return { type: "VariableDeclarator", id: id2, init: init2 };
}
var empty2 = {
  type: "EmptyStatement"
};
function export_default(declaration2) {
  return {
    type: "ExportDefaultDeclaration",
    declaration: declaration2
  };
}
function function_declaration(id2, params, body) {
  return {
    type: "FunctionDeclaration",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: null
    // should not be used by codegen
  };
}
function get(name8, body) {
  return prop("get", key(name8), function_builder(null, [], block(body)));
}
function id(name8) {
  return { type: "Identifier", name: name8 };
}
function import_namespace(local) {
  return {
    type: "ImportNamespaceSpecifier",
    local: id(local)
  };
}
function init(name8, value2) {
  return prop("init", key(name8), value2);
}
function literal2(value2) {
  return { type: "Literal", value: value2 };
}
function member(object3, property, computed = false, optional = false) {
  return {
    type: "MemberExpression",
    object: object3,
    property,
    computed,
    optional
  };
}
function member_id(path) {
  const parts = path.split(".");
  let expression = id(parts[0]);
  for (let i = 1; i < parts.length; i += 1) {
    expression = member(expression, id(parts[i]));
  }
  return expression;
}
function object(properties) {
  return { type: "ObjectExpression", properties };
}
function object_pattern(properties) {
  return { type: "ObjectPattern", properties };
}
function prop(kind, key2, value2, computed = false) {
  return { type: "Property", kind, key: key2, value: value2, method: false, shorthand: false, computed };
}
function quasi(cooked, tail = false) {
  const raw = cooked.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
  return { type: "TemplateElement", value: { raw, cooked }, tail };
}
function rest(argument) {
  return { type: "RestElement", argument };
}
function sequence(expressions) {
  return { type: "SequenceExpression", expressions };
}
function set(name8, body) {
  return prop("set", key(name8), function_builder(null, [id("$$value")], block(body)));
}
function stmt(expression) {
  return {
    type: "ExpressionStatement",
    expression
  };
}
function template(elements2, expressions) {
  return {
    type: "TemplateLiteral",
    quasis: elements2,
    expressions
  };
}
function thunk(expression) {
  return arrow([], expression);
}
function update(operator, argument, prefix = false) {
  return {
    type: "UpdateExpression",
    operator,
    argument,
    prefix
  };
}
var true_instance = literal2(true);
var false_instance = literal2(false);
var this_instance = {
  type: "ThisExpression"
};
function let_builder(pattern, init2) {
  return declaration("let", pattern, init2);
}
function const_builder(pattern, init2) {
  return declaration("const", pattern, init2);
}
function var_builder(pattern, init2) {
  return declaration("var", pattern, init2);
}
function for_builder(init2, test, update2, body) {
  return { type: "ForStatement", init: init2, test, update: update2, body };
}
function function_builder(id2, params, body) {
  return {
    type: "FunctionExpression",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: null
    // should not be used by codegen
  };
}
function if_builder(test, consequent, alternate) {
  return { type: "IfStatement", test, consequent, alternate };
}
function import_all(as2, source) {
  return {
    type: "ImportDeclaration",
    source: literal2(source),
    specifiers: [import_namespace(as2)]
  };
}
function return_builder(argument = null) {
  return { type: "ReturnStatement", argument };
}
function key(name8) {
  return regex_is_valid_identifier.test(name8) ? id(name8) : literal2(name8);
}

// src/compiler/utils/ast.js
function object2(expression) {
  while (expression.type === "MemberExpression") {
    expression = /** @type {import('estree').MemberExpression | import('estree').Identifier} */
    expression.object;
  }
  if (expression.type !== "Identifier") {
    return null;
  }
  return expression;
}
function get_callee_name(node2) {
  if (!node2)
    return null;
  if (node2.type !== "CallExpression")
    return null;
  if (node2.callee.type !== "Identifier" && node2.callee.type !== "MemberExpression")
    return null;
  const id2 = object2(node2.callee);
  return id2 === null ? null : id2.name;
}
function is_text_attribute(attribute) {
  return attribute.value !== true && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
function extract_identifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          extract_identifiers(prop2.argument, nodes);
        } else {
          extract_identifiers(prop2.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      for (const element of param.elements) {
        if (element)
          extract_identifiers(element, nodes);
      }
      break;
    case "RestElement":
      extract_identifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extract_identifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function extract_identifiers_from_expression(node2, nodes = []) {
  switch (node2.type) {
    case "Identifier":
      nodes.push(node2);
      break;
    case "ObjectExpression":
      for (const prop2 of node2.properties) {
        if (prop2.type === "Property") {
          extract_identifiers_from_expression(
            /** @type {any} */
            prop2.value,
            nodes
          );
        } else {
          extract_identifiers_from_expression(
            /** @type {any} */
            prop2.argument,
            nodes
          );
        }
      }
      break;
    case "ArrayExpression":
      for (const element of node2.elements) {
        if (element)
          extract_identifiers_from_expression(
            /** @type {any} */
            element,
            nodes
          );
      }
      break;
  }
  return nodes;
}
function extract_paths(param) {
  return _extract_paths(
    [],
    param,
    (node2) => (
      /** @type {import('estree').Identifier | import('estree').MemberExpression} */
      node2
    ),
    (node2) => (
      /** @type {import('estree').Identifier | import('estree').MemberExpression} */
      node2
    )
  );
}
function _extract_paths(assignments = [], param, expression, update_expression) {
  switch (param.type) {
    case "Identifier":
    case "MemberExpression":
      assignments.push({
        node: param,
        is_rest: false,
        expression,
        update_expression
      });
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          const rest_expression = (object3) => {
            const props = [];
            for (const p of param.properties) {
              if (p.type === "Property" && p.key.type !== "PrivateIdentifier") {
                if (p.key.type === "Identifier" && !p.computed) {
                  props.push(literal2(p.key.name));
                } else {
                  props.push(p.key);
                }
              }
            }
            return call("$.exclude_from_object", expression(object3), array(props));
          };
          if (prop2.argument.type === "Identifier") {
            assignments.push({
              node: prop2.argument,
              is_rest: true,
              expression: rest_expression,
              update_expression: rest_expression
            });
          } else {
            _extract_paths(assignments, prop2.argument, rest_expression, rest_expression);
          }
        } else {
          const object_expression = (object3) => member(expression(object3), prop2.key, prop2.computed || prop2.key.type !== "Identifier");
          _extract_paths(assignments, prop2.value, object_expression, object_expression);
        }
      }
      break;
    case "ArrayPattern":
      for (let i = 0; i < param.elements.length; i += 1) {
        const element = param.elements[i];
        if (element) {
          if (element.type === "RestElement") {
            const rest_expression = (object3) => call(member(expression(object3), id("slice")), literal2(i));
            if (element.argument.type === "Identifier") {
              assignments.push({
                node: element.argument,
                is_rest: true,
                expression: rest_expression,
                update_expression: rest_expression
              });
            } else {
              _extract_paths(assignments, element.argument, rest_expression, rest_expression);
            }
          } else {
            const array_expression = (object3) => member(expression(object3), literal2(i), true);
            _extract_paths(assignments, element, array_expression, array_expression);
          }
        }
      }
      break;
    case "AssignmentPattern": {
      const fallback_expression = (object3) => call("$.value_or_fallback", expression(object3), param.right);
      if (param.left.type === "Identifier") {
        assignments.push({
          node: param.left,
          is_rest: false,
          expression: fallback_expression,
          update_expression
        });
      } else {
        _extract_paths(assignments, param.left, fallback_expression, update_expression);
      }
      break;
    }
  }
  return assignments;
}

// src/compiler/phases/constants.ts
var DOMBooleans = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var DOMBooleanAttributes = new Set(DOMBooleans);
var DOMProperties = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "inert",
  ...DOMBooleans
]);
var AttributeAliases = /* @__PURE__ */ new Map([
  ["class", "className"],
  ["formnovalidate", "formNoValidate"],
  ["ismap", "isMap"],
  ["nomodule", "noModule"],
  ["playsinline", "playsInline"],
  ["readonly", "readOnly"]
]);
var VoidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var DelegatedEvents = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  // 'input', This conflicts with bind:input
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]);
var PassiveEvents = /* @__PURE__ */ new Set([
  "wheel",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel"
]);
var Runes = ["$state", "$props", "$derived", "$effect"];
var ReservedKeywords = /* @__PURE__ */ new Set(["$$props", "$$restProps", "$$slots"]);

// src/compiler/phases/nodes.ts
var element_nodes = /* @__PURE__ */ new Set([
  "DynamicElement",
  "RegularElement",
  "SlotTemplate",
  "InlineComponent",
  "DynamicComponent",
  "SelfElement",
  "Slot"
]);
function is_element_node(node2) {
  return element_nodes.has(node2.type);
}

// src/compiler/phases/scope.ts
var Scope3 = class _Scope {
  root;
  /** The immediate parent scope */
  #parent;
  /** Whether or not `var` declarations are contained by this scope */
  #porous;
  /** A map of every identifier declared by this scope, and all the
   * identifiers that reference it */
  declarations = /* @__PURE__ */ new Map();
  /** A map of declarators to the bindings they declare */
  declarators = /* @__PURE__ */ new Map();
  /** A set of all the names referenced with this scope
   *  useful for generating unique names */
  references = /* @__PURE__ */ new Map();
  constructor(root, parent, porous) {
    this.root = root;
    this.#parent = parent;
    this.#porous = porous;
  }
  declare(node2, kind, declaration_kind, initial = null) {
    if (declaration_kind === "var" && this.#porous) {
      return this.#parent.declare(node2, kind, declaration_kind);
    }
    if (declaration_kind === "import" && this.#parent) {
      return this.#parent.declare(node2, kind, declaration_kind, initial);
    }
    const binding = {
      node: node2,
      references: [],
      legacy_dependencies: [],
      initial,
      mutated: false,
      scope: this,
      kind,
      declaration_kind,
      is_called: false,
      is_used_as_member: false,
      prop_alias: null,
      expression: null,
      mutation: null
    };
    this.declarations.set(node2.name, binding);
    this.root.conflicts.add(node2.name);
    return binding;
  }
  child(porous = false) {
    return new _Scope(this.root, this, porous);
  }
  generate(preferred_name) {
    if (this.#porous) {
      return this.#parent.generate(preferred_name);
    }
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_");
    let name8 = preferred_name;
    let n2 = 1;
    while (this.references.has(name8) || this.declarations.has(name8) || this.root.conflicts.has(name8)) {
      name8 = `${preferred_name}_${n2++}`;
    }
    this.references.set(name8, []);
    this.root.conflicts.add(name8);
    return name8;
  }
  get(name8) {
    return this.declarations.get(name8) ?? this.#parent?.get(name8) ?? null;
  }
  get_bindings(node2) {
    const bindings2 = this.declarators.get(node2);
    if (!bindings2) {
      error(node2, "INTERNAL", "No binding found for declarator");
    }
    return bindings2;
  }
  owner(name8) {
    return this.declarations.has(name8) ? this : this.#parent && this.#parent.owner(name8);
  }
  reference(node2) {
    if (!this.references.has(node2.name))
      this.references.set(node2.name, []);
    this.references.get(node2.name).push(node2);
    const declaration2 = this.declarations.get(node2.name);
    if (declaration2) {
      declaration2.references.push(node2);
    } else if (this.#parent) {
      this.#parent.reference(node2);
    }
  }
};
var ScopeRoot = class {
  conflicts = /* @__PURE__ */ new Set();
  unique(preferred_name) {
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_");
    let final_name = preferred_name;
    let n2 = 1;
    while (this.conflicts.has(final_name)) {
      final_name = `${preferred_name}_${n2++}`;
    }
    this.conflicts.add(final_name);
    const id2 = id(final_name);
    return id2;
  }
};
function create_scopes(ast, root, allow_reactive_declarations, parent = null) {
  const scopes = /* @__PURE__ */ new Map();
  const scope = new Scope3(root, parent, false);
  scopes.set(ast, scope);
  const state = { scope };
  const references = [];
  const updates = [];
  const possible_implicit_declarations = [];
  function add_params(scope2, params) {
    for (const param of params) {
      for (const node2 of extract_identifiers(param)) {
        scope2.declare(node2, "normal", "let");
      }
    }
  }
  const create_block_scope = (node2, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child(true);
    scopes.set(node2, scope2);
    next2({ scope: scope2 });
  };
  const SlotTemplate = (node2, { state: state2, next: next2 }) => {
    const scope2 = analyze_let_directives(node2, state2);
    if (scope2) {
      scopes.set(node2, scope2);
      next2({ scope: scope2 });
    } else {
      next2();
    }
  };
  const CreateBlock = (node2, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child();
    scopes.set(node2, scope2);
    next2({ scope: scope2 });
  };
  function analyze_let_directives(node2, state2) {
    let scope2 = void 0;
    for (const attribute of node2.attributes) {
      if (attribute.type !== "LetDirective")
        continue;
      if (!scope2) {
        scope2 = state2.scope.child();
      }
      const bindings2 = [];
      scope2.declarators.set(attribute, bindings2);
      scopes.set(attribute, scope2);
      if (attribute.expression) {
        for (const id2 of extract_identifiers_from_expression(attribute.expression)) {
          const binding = scope2.declare(id2, "derived", "const");
          bindings2.push(binding);
        }
      } else {
        const id2 = {
          name: attribute.name,
          type: "Identifier",
          start: attribute.start,
          end: attribute.end
        };
        const binding = scope2.declare(id2, "derived", "const");
        bindings2.push(binding);
      }
    }
    return scope2;
  }
  walk(ast, state, {
    // references
    Identifier(node2, { path, state: state2 }) {
      const parent2 = path.at(-1);
      if (parent2 && is_reference(node2, parent2)) {
        references.push([state2.scope, node2]);
      }
    },
    LabeledStatement(node2, { path, next: next2 }) {
      if (path.length > 1 || !allow_reactive_declarations)
        return next2();
      if (node2.label.name !== "$")
        return next2();
      const scope2 = state.scope.child();
      scopes.set(node2, scope2);
      if (node2.body.type === "ExpressionStatement" && node2.body.expression.type === "AssignmentExpression") {
        for (const id2 of extract_identifiers(node2.body.expression.left)) {
          if (!id2.name.startsWith("$")) {
            possible_implicit_declarations.push(id2);
          }
        }
      }
      next2({ scope: scope2 });
    },
    // TODO rename SlotTemplate
    SlotTemplate,
    DynamicElement: SlotTemplate,
    RegularElement: SlotTemplate,
    InlineComponent(node2, { state: state2, visit }) {
      const scope2 = analyze_let_directives(node2, state2);
      for (const attribute of node2.attributes) {
        visit(attribute);
      }
      for (const child of node2.fragment.nodes) {
        if (is_element_node(child) && child.attributes.some(
          (attribute) => attribute.type === "Attribute" && attribute.name === "slot"
        )) {
          visit(child);
        } else {
          if (scope2) {
            scopes.set(child, scope2);
            if (child.expression)
              scopes.set(child.expression, scope2);
            visit(child, { scope: scope2 });
          } else {
            visit(child);
          }
        }
      }
    },
    // updates
    AssignmentExpression(node2, { state: state2, next: next2 }) {
      updates.push([state2.scope, node2.left]);
      next2();
    },
    UpdateExpression(node2, { state: state2, next: next2 }) {
      updates.push([state2.scope, node2.argument]);
      next2();
    },
    ImportDeclaration(node2, { state: state2 }) {
      for (const specifier of node2.specifiers) {
        state2.scope.declare(specifier.local, "normal", "import", node2);
      }
    },
    FunctionExpression(node2, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node2, scope2);
      if (node2.id)
        scope2.declare(node2.id, "normal", "function");
      add_params(scope2, node2.params);
      next2({ scope: scope2 });
    },
    FunctionDeclaration(node2, { state: state2, next: next2 }) {
      if (node2.id)
        state2.scope.declare(node2.id, "normal", "function", node2);
      const scope2 = state2.scope.child();
      scopes.set(node2, scope2);
      add_params(scope2, node2.params);
      next2({ scope: scope2 });
    },
    ArrowFunctionExpression(node2, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node2, scope2);
      add_params(scope2, node2.params);
      next2({ scope: scope2 });
    },
    ForStatement: create_block_scope,
    ForInStatement: create_block_scope,
    ForOfStatement: create_block_scope,
    BlockStatement: create_block_scope,
    SwitchStatement: create_block_scope,
    ClassDeclaration(node2, { state: state2, next: next2 }) {
      if (node2.id)
        state2.scope.declare(node2.id, "normal", "const");
      next2();
    },
    VariableDeclaration(node2, { state: state2, next: next2 }) {
      for (const declarator2 of node2.declarations) {
        const bindings2 = [];
        state2.scope.declarators.set(declarator2, bindings2);
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state2.scope.declare(id2, "normal", node2.kind, declarator2.init);
          bindings2.push(binding);
        }
      }
      next2();
    },
    CatchClause(node2, { state: state2, next: next2 }) {
      if (node2.param) {
        const scope2 = state2.scope.child(true);
        scopes.set(node2, scope2);
        for (const id2 of extract_identifiers(node2.param)) {
          state2.scope.declare(id2, "normal", "let");
        }
        next2({ scope: scope2 });
      } else {
        next2();
      }
    },
    EachBlock(node2, { state: state2, visit }) {
      const references_within = /* @__PURE__ */ new Set();
      const idx = references.length;
      visit(node2.expression);
      for (let i = idx; i < references.length; i++) {
        const [scope3, id2] = references[i];
        if (scope3 === state2.scope) {
          references_within.add(id2);
        }
      }
      scopes.set(node2.expression, state2.scope);
      const scope2 = state2.scope.child();
      scopes.set(node2, scope2);
      for (const id2 of extract_identifiers(node2.context)) {
        scope2.declare(id2, "each", "const");
      }
      if (node2.context.type !== "Identifier") {
        scope2.declare(id("$$item"), "derived", "const");
      }
      if (node2.index) {
        scope2.declare(
          id(node2.index),
          // TODO see logic in EachBlock in dom.ts
          node2.key ? "derived" : "normal",
          "const"
        );
      }
      if (node2.key)
        visit(node2.key, { scope: scope2 });
      for (const child of node2.body.nodes) {
        visit(child, { scope: scope2 });
      }
      if (node2.fallback)
        visit(node2.fallback, { scope: scope2 });
      let needs_array_deduplication = false;
      for (const [name8] of scope2.declarations) {
        if (state2.scope.get(name8) !== null) {
          needs_array_deduplication = true;
        }
      }
      node2.metadata = {
        contains_group_binding: false,
        array_name: needs_array_deduplication ? state2.scope.root.unique("$$array") : null,
        index: scope2.root.unique("$$index"),
        item_name: node2.context.type === "Identifier" ? node2.context.name : "$$item",
        references: [...references_within].map((id2) => state2.scope.get(id2.name)).filter(Boolean),
        is_controlled: false
      };
    },
    AwaitBlock(node2, context) {
      context.next();
      if (node2.then && node2.value !== null) {
        const then_scope = scopes.get(node2.then);
        const value_scope = context.state.scope.child();
        for (const id2 of extract_identifiers(node2.value)) {
          then_scope.declare(id2, "normal", "const");
          value_scope.declare(id2, "normal", "const");
        }
        scopes.set(node2.value, value_scope);
      }
      if (node2.catch && node2.error !== null) {
        const catch_scope = scopes.get(node2.catch);
        const error_scope = context.state.scope.child();
        for (const id2 of extract_identifiers(node2.error)) {
          catch_scope.declare(id2, "normal", "const");
          error_scope.declare(id2, "normal", "const");
        }
        scopes.set(node2.error, error_scope);
      }
    },
    Fragment: (node2, context) => {
      const scope2 = context.state.scope.child(node2.transparent);
      scopes.set(node2, scope2);
      context.next({ scope: scope2 });
    },
    // TODO this will be unnecessary when we switch to fragments
    IfBlock: CreateBlock,
    BindDirective(node2, context) {
      updates.push([context.state.scope, node2.expression]);
      context.next();
    },
    ConstTag(node2, { state: state2, next: next2 }) {
      for (const identifier of extract_identifiers(node2.expression.left)) {
        state2.scope.declare(identifier, "derived", "const");
      }
      next2();
    }
    // TODO others
  });
  for (const id2 of possible_implicit_declarations) {
    const binding = scope.get(id2.name);
    if (binding)
      continue;
    scope.declare(id2, "legacy_reactive", "let");
  }
  for (const [scope2, node2] of references) {
    scope2.reference(node2);
  }
  for (const [scope2, node2] of updates) {
    if (node2.type === "MemberExpression") {
      let object3 = node2.object;
      while (object3.type === "MemberExpression") {
        object3 = object3.object;
      }
      const binding = scope2.get(object3.name);
      if (binding)
        binding.mutated = true;
    } else {
      extract_identifiers(node2).forEach((identifier) => {
        const binding = scope2.get(identifier.name);
        if (binding)
          binding.mutated = true;
      });
    }
  }
  return {
    scope,
    scopes
  };
}
function set_scope(scopes) {
  return {
    _(node2, { next: next2, state }) {
      const scope = scopes.get(node2);
      next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
    }
  };
}
function get_rune(node2, scope) {
  const callee = get_callee_name(node2);
  if (callee === null || !Runes.includes(callee))
    return null;
  const binding = scope.get(callee);
  if (binding !== null)
    return null;
  return callee;
}

// src/compiler/phases/visitors.ts
var overrides = {
  visit() {
    throw new Error("Cannot call visit() during analysis");
  },
  stop() {
    throw new Error("Cannot call stop() during analysis");
  }
};
function merge(...tasks) {
  const visitors = {};
  for (const task of tasks) {
    for (const key2 in task) {
      if (!visitors[key2])
        visitors[key2] = [];
      visitors[key2].push(task[key2]);
    }
  }
  const combined = {};
  for (const key2 in visitors) {
    const fns = visitors[key2];
    combined[key2] = (node2, context) => {
      const go2 = (i, state) => {
        const fn2 = fns[i];
        if (!fn2)
          return context.next(state);
        let called_next = false;
        fn2(node2, {
          ...context,
          ...overrides,
          state,
          next(next_state = state) {
            called_next = true;
            go2(i + 1, next_state);
          }
        });
        if (!called_next) {
          go2(i + 1, state);
        }
      };
      go2(0, context.state);
    };
  }
  return combined;
}

// ../../node_modules/.pnpm/magic-string@0.30.3/node_modules/magic-string/dist/magic-string.es.mjs
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn2) {
    let chunk = this;
    while (chunk) {
      fn2(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn2) {
    let chunk = this;
    while (chunk) {
      fn2(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str) => window.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa = /* @__PURE__ */ getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = (0, import_sourcemap_codec.encode)(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to2) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to2.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString2 = Object.prototype.toString;
function isObject(thing) {
  return toString2.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === "boundary") {
          if (wordRegex.test(original[originalCharIndex])) {
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last;
    if (!first.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_2, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re2, str) {
      let match;
      const matches2 = [];
      while (match = re2.exec(str)) {
        matches2.push(match);
      }
      return matches2;
    }
    if (searchValue.global) {
      const matches2 = matchAll(searchValue, this.original);
      matches2.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// src/compiler/phases/2-analyze/css/gather_possible_values.js
var UNKNOWN = {};
function gather_possible_values(node2, set2) {
  if (node2.type === "Literal") {
    set2.add(String(node2.value));
  } else if (node2.type === "ConditionalExpression") {
    gather_possible_values(node2.consequent, set2);
    gather_possible_values(node2.alternate, set2);
  } else {
    set2.add(UNKNOWN);
  }
}
function get_possible_values(chunk) {
  const values = /* @__PURE__ */ new Set();
  if (chunk.type === "Text") {
    values.add(chunk.data);
  } else {
    gather_possible_values(chunk.expression, values);
  }
  if (values.has(UNKNOWN))
    return null;
  return values;
}

// src/compiler/phases/2-analyze/css/Selector.js
var NO_MATCH = "NO_MATCH";
var POSSIBLE_MATCH = "POSSIBLE_MATCH";
var UNKNOWN_SELECTOR = "UNKNOWN_SELECTOR";
var NodeExist = (
  /** @type {const} */
  {
    Probably: 0,
    Definitely: 1
  }
);
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", /* @__PURE__ */ new Set(["open"])],
  ["dialog", /* @__PURE__ */ new Set(["open"])]
]);
var regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
var Selector = class {
  /** @type {import('./private.js').CssNode} */
  node;
  /** @type {import('./Stylesheet.js').default} */
  stylesheet;
  /** @type {Block[]} */
  blocks;
  /** @type {Block[]} */
  local_blocks;
  /** @type {boolean} */
  used;
  /**
   * @param {import('./private.js').CssNode} node
   * @param {import('./Stylesheet.js').default} stylesheet
   */
  constructor(node2, stylesheet) {
    this.node = node2;
    this.stylesheet = stylesheet;
    this.blocks = group_selectors(node2);
    let i = this.blocks.length;
    while (i > 0) {
      if (!this.blocks[i - 1].global)
        break;
      i -= 1;
    }
    this.local_blocks = this.blocks.slice(0, i);
    const host_only = this.blocks.length === 1 && this.blocks[0].host;
    const root_only = this.blocks.length === 1 && this.blocks[0].root;
    this.used = this.local_blocks.length === 0 || host_only || root_only;
  }
  /** @param {import('../../../interfaces.js').RegularElement | import('../../../interfaces.js').DynamicElement} node */
  apply(node2) {
    const to_encapsulate = [];
    apply_selector(this.local_blocks.slice(), node2, to_encapsulate);
    if (to_encapsulate.length > 0) {
      to_encapsulate.forEach(({ node: node3, block: block2 }) => {
        this.stylesheet.nodes_with_css_class.add(node3);
        block2.should_encapsulate = true;
      });
      this.used = true;
    }
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} attr
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, attr, max_amount_class_specificity_increased) {
    const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block2) => block2.should_encapsulate).length;
    function remove_global_pseudo_class(selector) {
      const first = selector.children[0];
      const last = selector.children[selector.children.length - 1];
      code.remove(selector.start, first.start).remove(last.end, selector.end);
    }
    function encapsulate_block(block2, attr2) {
      for (const selector of block2.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          remove_global_pseudo_class(selector);
        }
      }
      let i = block2.selectors.length;
      while (i--) {
        const selector = block2.selectors[i];
        if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
          if (selector.name !== "root" && selector.name !== "host") {
            if (i === 0)
              code.prependRight(selector.start, attr2);
          }
          continue;
        }
        if (selector.type === "TypeSelector" && selector.name === "*") {
          code.update(selector.start, selector.end, attr2);
        } else {
          code.appendLeft(selector.end, attr2);
        }
        break;
      }
    }
    this.blocks.forEach((block2, index) => {
      if (block2.global) {
        remove_global_pseudo_class(block2.selectors[0]);
      }
      if (block2.should_encapsulate)
        encapsulate_block(
          block2,
          index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr
        );
    });
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    let start = 0;
    let end = this.blocks.length;
    for (; start < end; start += 1) {
      if (!this.blocks[start].global)
        break;
    }
    for (; end > start; end -= 1) {
      if (!this.blocks[end - 1].global)
        break;
    }
    for (let i = start; i < end; i += 1) {
      if (this.blocks[i].global) {
        error(this.blocks[i].selectors[0], "invalid-css-global-placement");
      }
    }
    this.validate_global_with_multiple_selectors();
    this.validate_global_compound_selector();
    this.validate_invalid_combinator_without_selector(analysis);
  }
  validate_global_with_multiple_selectors() {
    if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) {
      return;
    }
    for (const block2 of this.blocks) {
      for (const selector of block2.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          if (regex_is_single_css_selector.test(selector.children[0].value)) {
            error(selector, "invalid-css-global-selector");
          }
        }
      }
    }
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate_invalid_combinator_without_selector(analysis) {
    for (let i = 0; i < this.blocks.length; i++) {
      const block2 = this.blocks[i];
      if (block2.selectors.length === 0) {
        error(this.node, "invalid-css-selector");
      }
    }
  }
  validate_global_compound_selector() {
    for (const block2 of this.blocks) {
      for (const selector of block2.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global" && block2.selectors.length !== 1) {
          error(selector, "invalid-css-global-selector-list");
        }
      }
    }
  }
  get_amount_class_specificity_increased() {
    let count = 0;
    for (const block2 of this.blocks) {
      if (block2.should_encapsulate) {
        count++;
      }
    }
    return count;
  }
};
function apply_selector(blocks, node2, to_encapsulate) {
  const block2 = blocks.pop();
  if (!block2)
    return false;
  if (!node2) {
    return block2.global && blocks.every((block3) => block3.global) || block2.host && blocks.length === 0;
  }
  const applies = block_might_apply_to_node(block2, node2);
  if (applies === NO_MATCH) {
    return false;
  }
  if (applies === UNKNOWN_SELECTOR) {
    to_encapsulate.push({ node: node2, block: block2 });
    return true;
  }
  if (block2.combinator) {
    if (block2.combinator.type === "Combinator" && block2.combinator.name === " ") {
      for (const ancestor_block of blocks) {
        if (ancestor_block.global) {
          continue;
        }
        if (ancestor_block.host) {
          to_encapsulate.push({ node: node2, block: block2 });
          return true;
        }
        let parent = node2;
        while (parent = get_element_parent(parent)) {
          if (block_might_apply_to_node(ancestor_block, parent) !== NO_MATCH) {
            to_encapsulate.push({ node: parent, block: ancestor_block });
          }
        }
        if (to_encapsulate.length) {
          to_encapsulate.push({ node: node2, block: block2 });
          return true;
        }
      }
      if (blocks.every((block3) => block3.global)) {
        to_encapsulate.push({ node: node2, block: block2 });
        return true;
      }
      return false;
    } else if (block2.combinator.name === ">") {
      const has_global_parent = blocks.every((block3) => block3.global);
      if (has_global_parent || apply_selector(blocks, get_element_parent(node2), to_encapsulate)) {
        to_encapsulate.push({ node: node2, block: block2 });
        return true;
      }
      return false;
    } else if (block2.combinator.name === "+" || block2.combinator.name === "~") {
      const siblings = get_possible_element_siblings(node2, block2.combinator.name === "+");
      let has_match = false;
      const has_global = blocks.some((block3) => block3.global);
      if (has_global) {
        if (siblings.size === 0 && get_element_parent(node2) !== null) {
          return false;
        }
        to_encapsulate.push({ node: node2, block: block2 });
        return true;
      }
      for (const possible_sibling of siblings.keys()) {
        if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
          to_encapsulate.push({ node: node2, block: block2 });
          has_match = true;
        }
      }
      return has_match;
    }
    to_encapsulate.push({ node: node2, block: block2 });
    return true;
  }
  to_encapsulate.push({ node: node2, block: block2 });
  return true;
}
var regex_backslash_and_following_character = /\\(.)/g;
function block_might_apply_to_node(block2, node2) {
  if (block2.host || block2.root)
    return NO_MATCH;
  let i = block2.selectors.length;
  while (i--) {
    const selector = block2.selectors[i];
    if (selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector") {
      continue;
    }
    if (selector.type === "AttributeSelector") {
      const whitelisted = whitelist_attribute_selector.get(node2.name.toLowerCase());
      if (!whitelisted?.has(selector.name.name.toLowerCase()) && !attribute_matches(
        node2,
        selector.name.name,
        selector.value && unquote(selector.value),
        selector.matcher,
        selector.flags
      )) {
        return NO_MATCH;
      }
    } else {
      const name8 = typeof selector.name === "string" && selector.name.replace(regex_backslash_and_following_character, "$1");
      if (typeof name8 !== "string")
        throw new Error("Unexpected error");
      if (selector.type === "PseudoClassSelector" && (name8 === "host" || name8 === "root")) {
        return NO_MATCH;
      }
      if (block2.selectors.length === 1 && selector.type === "PseudoClassSelector" && name8 === "global") {
        return NO_MATCH;
      }
      if (selector.type === "ClassSelector") {
        if (!attribute_matches(node2, "class", name8, "~=", false) && !node2.attributes.some(
          (attribute) => attribute.type === "ClassDirective" && attribute.name === name8
        )) {
          return NO_MATCH;
        }
      } else if (selector.type === "IdSelector") {
        if (!attribute_matches(node2, "id", name8, "=", false))
          return NO_MATCH;
      } else if (selector.type === "TypeSelector") {
        if (node2.name.toLowerCase() !== name8.toLowerCase() && name8 !== "*" && node2.type !== "DynamicElement") {
          return NO_MATCH;
        }
      } else {
        return UNKNOWN_SELECTOR;
      }
    }
  }
  return POSSIBLE_MATCH;
}
function test_attribute(operator, expected_value, case_insensitive, value2) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value2 = value2.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value2 === expected_value;
    case "~=":
      return value2.split(/\s/).includes(expected_value);
    case "|=":
      return `${value2}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value2.startsWith(expected_value);
    case "$=":
      return value2.endsWith(expected_value);
    case "*=":
      return value2.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node2, name8, expected_value, operator, case_insensitive) {
  for (const attribute of node2.attributes) {
    if (attribute.type === "Spread")
      return true;
    if (attribute.type === "BindDirective" && attribute.name === name8)
      return true;
    if (attribute.type !== "Attribute")
      continue;
    if (attribute.name.toLowerCase() !== name8.toLowerCase())
      continue;
    if (attribute.value === true)
      return operator === null;
    if (expected_value === null)
      return true;
    const chunks = attribute.value;
    if (chunks.length === 1) {
      const value2 = chunks[0];
      if (value2.type === "Text") {
        return test_attribute(operator, expected_value, case_insensitive, value2.data);
      }
    }
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of chunks) {
      const current_possible_values = get_possible_values(chunk);
      if (!current_possible_values)
        return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value)) {
            start_with_space.push(current_possible_value);
          } else {
            remaining.push(current_possible_value);
          }
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0) {
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          }
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value2) => {
              combined.push(prev_value + value2);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value2) => {
            if (regex_ends_with_whitespace.test(value2)) {
              possible_values.add(value2);
            } else {
              prev_values.push(value2);
            }
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value)) {
          possible_values.add(current_possible_value);
        } else {
          prev_values.push(current_possible_value);
        }
      });
      if (prev_values.length < current_possible_values.size) {
        prev_values.push(" ");
      }
      if (prev_values.length > 20) {
        return true;
      }
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    for (const value2 of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value2))
        return true;
    }
  }
  return false;
}
function unquote(value2) {
  if (value2.type === "Identifier")
    return value2.name;
  const str = value2.value;
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_element_parent(node2) {
  let parent = node2;
  while (
    // @ts-expect-error TODO figure out a more elegant solution
    (parent = parent.parent) && parent.type !== "RegularElement" && parent.type !== "DynamicElement"
  )
    ;
  return parent ?? null;
}
function find_previous_sibling(node2) {
  let current_node = node2;
  do {
    if (current_node.type === "Slot") {
      const slot_children = current_node.fragment.nodes;
      if (slot_children.length > 0) {
        current_node = slot_children.slice(-1)[0];
        continue;
      }
    }
    while (!current_node.prev && current_node.parent && current_node.parent.type === "Slot") {
      current_node = current_node.parent;
    }
    current_node = current_node.prev;
  } while (current_node && current_node.type === "Slot");
  return current_node;
}
function get_possible_element_siblings(node2, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  let prev = node2;
  while (prev = find_previous_sibling(prev)) {
    if (prev.type === "RegularElement") {
      if (!prev.attributes.find(
        (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
      )) {
        result.set(prev, NodeExist.Definitely);
      }
      if (adjacent_only) {
        break;
      }
    } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
      const possible_last_child = get_possible_last_child(prev, adjacent_only);
      add_to_map(possible_last_child, result);
      if (adjacent_only && has_definite_elements(possible_last_child)) {
        return result;
      }
    }
  }
  if (!prev || !adjacent_only) {
    let parent = node2;
    while (
      // @ts-expect-error TODO
      (parent = parent?.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "AwaitBlock")
    ) {
      const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
      add_to_map(possible_siblings, result);
      if (parent.type === "EachBlock" && !parent.fallback?.nodes.includes(node2)) {
        add_to_map(get_possible_last_child(parent, adjacent_only), result);
      }
      if (adjacent_only && has_definite_elements(possible_siblings)) {
        break;
      }
    }
  }
  return result;
}
function get_possible_last_child(block2, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  if (block2.type === "EachBlock") {
    const each_result = loop_child(block2.body.nodes, adjacent_only);
    const else_result = block2.fallback ? loop_child(block2.fallback.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(each_result);
      mark_as_probably(else_result);
    }
    add_to_map(each_result, result);
    add_to_map(else_result, result);
  } else if (block2.type === "IfBlock") {
    const if_result = loop_child(block2.consequent.nodes, adjacent_only);
    const else_result = block2.alternate ? loop_child(block2.alternate.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(if_result);
      mark_as_probably(else_result);
    }
    add_to_map(if_result, result);
    add_to_map(else_result, result);
  } else if (block2.type === "AwaitBlock") {
    const pending_result = block2.pending ? loop_child(block2.pending.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const then_result = block2.then ? loop_child(block2.then.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const catch_result = block2.catch ? loop_child(block2.catch.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
    if (not_exhaustive) {
      mark_as_probably(pending_result);
      mark_as_probably(then_result);
      mark_as_probably(catch_result);
    }
    add_to_map(pending_result, result);
    add_to_map(then_result, result);
    add_to_map(catch_result, result);
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0)
    return false;
  for (const exist of result.values()) {
    if (exist === NodeExist.Definitely) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to2) {
  from.forEach((exist, element) => {
    to2.set(element, higher_existence(exist, to2.get(element)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist1 === void 0 || exist2 === void 0)
    return exist1 || exist2;
  return exist1 > exist2 ? exist1 : exist2;
}
function mark_as_probably(result) {
  for (const key2 of result.keys()) {
    result.set(key2, NodeExist.Probably);
  }
}
function loop_child(children, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (child.type === "RegularElement") {
      result.set(child, NodeExist.Definitely);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
      const child_result = get_possible_last_child(child, adjacent_only);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
  }
  return result;
}
var Block = class {
  /** @type {boolean} */
  host;
  /** @type {boolean} */
  root;
  /** @type {import('./private.js').CssNode | null} */
  combinator;
  /** @type {import('./private.js').CssNode[]} */
  selectors;
  /** @type {number} */
  start;
  /** @type {number} */
  end;
  /** @type {boolean} */
  should_encapsulate;
  /** @param {import('./private.js').CssNode | null} combinator */
  constructor(combinator) {
    this.combinator = combinator;
    this.host = false;
    this.root = false;
    this.selectors = [];
    this.start = -1;
    this.end = -1;
    this.should_encapsulate = false;
  }
  /** @param {import('./private.js').CssNode} selector */
  add(selector) {
    if (this.selectors.length === 0) {
      this.start = selector.start;
      this.host = selector.type === "PseudoClassSelector" && selector.name === "host";
    }
    this.root = this.root || selector.type === "PseudoClassSelector" && selector.name === "root";
    this.selectors.push(selector);
    this.end = selector.end;
  }
  get global() {
    return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every(
      (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
    );
  }
};
function group_selectors(selector) {
  let block2 = new Block(null);
  const blocks = [block2];
  selector.children.forEach((child) => {
    if (child.type === "WhiteSpace" || child.type === "Combinator") {
      block2 = new Block(child);
      blocks.push(block2);
    } else {
      block2.add(child);
    }
  });
  return blocks;
}

// src/compiler/phases/2-analyze/utils/hash.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}

// src/compiler/phases/2-analyze/utils/push_array.js
function push_array(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// src/compiler/phases/2-analyze/css/Stylesheet.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
function remove_css_prefix(name8) {
  return name8.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node2) => remove_css_prefix(node2.name) === "keyframes";
var at_rule_has_declaration = ({ block: block2 }) => block2 && block2.children && block2.children.find(
  (node2) => node2.type === "Declaration"
);
function escape_comment_close(node2, code) {
  let escaped = false;
  let in_comment = false;
  for (let i = node2.start; i < node2.end; i++) {
    if (escaped) {
      escaped = false;
    } else {
      const char = code.original[i];
      if (in_comment) {
        if (char === "*" && code.original[i + 1] === "/") {
          code.prependRight(++i, "\\");
          in_comment = false;
        }
      } else if (char === "\\") {
        escaped = true;
      } else if (char === "/" && code.original[++i] === "*") {
        in_comment = true;
      }
    }
  }
}
var Rule = class {
  /** @type {import('./Selector.js').default[]} */
  selectors;
  /** @type {Declaration[]} */
  declarations;
  /** @type {import('./private.js').CssNode} */
  node;
  /** @type {Atrule | undefined} */
  parent;
  /**
   * @param {import('./private.js').CssNode} node
   * @param {any} stylesheet
   * @param {Atrule | undefined} parent
   */
  constructor(node2, stylesheet, parent) {
    this.node = node2;
    this.parent = parent;
    this.selectors = node2.prelude.children.map(
      (node3) => new Selector(node3, stylesheet)
    );
    this.declarations = node2.block.children.map(
      (node3) => new Declaration(node3)
    );
  }
  /** @param {import('../../../interfaces').RegularElement | import('../../../interfaces').DynamicElement} node */
  apply(node2) {
    this.selectors.forEach((selector) => selector.apply(node2));
  }
  /** @param {boolean} dev */
  is_used(dev) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
      return true;
    if (this.declarations.length === 0)
      return dev;
    return this.selectors.some((s) => s.used);
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, id2, keyframes, max_amount_class_specificity_increased) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) {
      return;
    }
    const attr = `.${id2}`;
    this.selectors.forEach(
      (selector) => selector.transform(code, attr, max_amount_class_specificity_increased)
    );
    this.declarations.forEach((declaration2) => declaration2.transform(code, keyframes));
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    this.selectors.forEach((selector) => {
      selector.validate(analysis);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    this.selectors.forEach((selector) => {
      if (!selector.used)
        handler(selector);
    });
  }
  /** @returns number */
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.selectors.map((selector) => selector.get_amount_class_specificity_increased())
    );
  }
  /**
   * @param {MagicString} code
   * @param {boolean} dev
   */
  prune(code, dev) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) {
      return;
    }
    if (this.declarations.length === 0) {
      if (!dev) {
        code.prependRight(this.node.start, "/* (empty) ");
        code.appendLeft(this.node.end, "*/");
        escape_comment_close(this.node, code);
      }
      return;
    }
    const used = this.selectors.filter((s) => s.used);
    if (used.length === 0) {
      code.prependRight(this.node.start, "/* (unused) ");
      code.appendLeft(this.node.end, "*/");
      escape_comment_close(this.node, code);
      return;
    }
    if (used.length < this.selectors.length) {
      let pruning = false;
      let last = 0;
      for (let i = 0; i < this.selectors.length; i += 1) {
        const selector = this.selectors[i];
        if (selector.used !== pruning)
          continue;
        if (pruning) {
          let i2 = selector.node.start;
          while (code.original[i2] !== ",")
            i2--;
          code.overwrite(i2, i2 + 1, "*/");
        } else {
          if (i === 0) {
            code.prependRight(selector.node.start, "/* (unused) ");
          } else {
            code.overwrite(last, selector.node.start, " /* (unused) ");
          }
        }
        pruning = !pruning;
        last = selector.node.end;
      }
      if (pruning) {
        code.appendLeft(last, "*/");
      }
    }
  }
};
var Declaration = class {
  /** @type {import('./private.js').CssNode} */
  node;
  /** @param {import('./private.js').CssNode} node */
  constructor(node2) {
    this.node = node2;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {Map<string, string>} keyframes
   */
  transform(code, keyframes) {
    const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      this.node.value.children.forEach((block2) => {
        if (block2.type === "Identifier") {
          const name8 = block2.name;
          const keyframe = keyframes.get(name8);
          if (keyframe) {
            code.update(block2.start, block2.end, keyframe);
          }
        }
      });
    }
  }
};
var Atrule = class {
  /** @type {import('./private.js').CssNode} */
  node;
  /** @type {Array<Atrule | Rule>} */
  children;
  /** @type {Declaration[]} */
  declarations;
  /** @param {import('./private.js').CssNode} node */
  constructor(node2) {
    this.node = node2;
    this.children = [];
    this.declarations = [];
  }
  /** @param {import('../../../interfaces').RegularElement | import('../../../interfaces').DynamicElement} node */
  apply(node2) {
    if (this.node.name === "container" || this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer") {
      this.children.forEach((child) => {
        child.apply(node2);
      });
    } else if (is_keyframes_node(this.node)) {
      this.children.forEach((rule) => {
        rule.selectors.forEach((selector) => {
          selector.used = true;
        });
      });
    }
  }
  /** @param {boolean} _dev */
  is_used(_dev) {
    return true;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, id2, keyframes, max_amount_class_specificity_increased) {
    if (is_keyframes_node(this.node)) {
      this.node.prelude.children.forEach(
        ({ type, name: name8, start, end }) => {
          if (type === "Identifier") {
            if (name8.startsWith("-global-")) {
              code.remove(start, start + 8);
              this.children.forEach((rule) => {
                rule.selectors.forEach((selector) => {
                  selector.used = true;
                });
              });
            } else {
              const keyframe = (
                /** @type {string} */
                keyframes.get(name8)
              );
              code.update(start, end, keyframe);
            }
          }
        }
      );
    }
    this.children.forEach((child) => {
      child.transform(code, id2, keyframes, max_amount_class_specificity_increased);
    });
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    this.children.forEach((child) => {
      child.validate(analysis);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    if (this.node.name !== "media")
      return;
    this.children.forEach((child) => {
      child.warn_on_unused_selector(handler);
    });
  }
  /** @returns {number} */
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
  }
  /**
   * @param {MagicString} code
   * @param {boolean} dev
   */
  prune(code, dev) {
  }
};
var get_default_css_hash = ({ css: css3, hash: hash2 }) => {
  return `svelte-${hash2(css3)}`;
};
var Stylesheet = class {
  /** @type {import('../../../interfaces').Style | undefined} */
  ast;
  /** @type {string} */
  filename;
  /** @type {boolean} */
  has_styles;
  /** @type {string} */
  id;
  /** @type {Array<Rule | Atrule>} */
  children = [];
  /** @type {Map<string, string>} */
  keyframes = /* @__PURE__ */ new Map();
  /** @type {Set<import('../../../interfaces').RegularElement>} */
  nodes_with_css_class = /* @__PURE__ */ new Set();
  /**
   * @param {{
   * 		ast: import('../../../interfaces').Style | undefined;
   * 		filename: string;
   * 		component_name: string;
   * 		get_css_hash?: import('../../../interfaces').CssHashGetter;
   * 	}} params
   */
  constructor({ ast, component_name, filename, get_css_hash = get_default_css_hash }) {
    this.ast = ast;
    this.filename = filename;
    if (!ast || ast.children.length === 0) {
      this.has_styles = false;
      this.id = "";
      return;
    }
    this.id = get_css_hash({
      filename,
      name: component_name,
      css: ast.content.styles,
      hash
    });
    this.has_styles = true;
    const state = {
      /** @type {Atrule | undefined} */
      atrule: void 0
    };
    walk(
      /** @type {import('./private').CssNode} */
      ast,
      state,
      {
        _(node2, { next: next2 }) {
          if (node2.loc) {
            node2.start = node2.loc.start.offset;
            node2.end = node2.loc.end.offset;
            delete node2.loc;
          }
          next2();
        },
        Atrule: (node2, context) => {
          const atrule = new Atrule(node2);
          if (context.state.atrule) {
            context.state.atrule.children.push(atrule);
          } else {
            this.children.push(atrule);
          }
          if (is_keyframes_node(node2)) {
            node2.prelude.children.forEach((expression) => {
              if (expression.type === "Identifier" && !expression.name.startsWith("-global-")) {
                this.keyframes.set(expression.name, `${this.id}-${expression.name}`);
              }
            });
          } else if (at_rule_has_declaration(node2)) {
            const at_rule_declarations = (
              /** @type {import('./private').CssNode[]} */
              node2.block.children.filter((node3) => node3.type === "Declaration").map((node3) => new Declaration(node3))
            );
            push_array(atrule.declarations, at_rule_declarations);
          }
          context.next({
            ...context.state,
            atrule
          });
        },
        Rule: (node2, context) => {
          const rule = new Rule(node2, this, context.state.atrule);
          if (context.state.atrule) {
            context.state.atrule.children.push(rule);
          } else {
            this.children.push(rule);
          }
          context.next();
        }
      }
    );
  }
  /** @param {import('../../../interfaces').RegularElement | import('../../../interfaces').DynamicElement} node */
  apply(node2) {
    if (!this.has_styles)
      return;
    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.children[i];
      child.apply(node2);
    }
  }
  reify() {
    nodes:
      for (const node2 of this.nodes_with_css_class) {
        let class_attribute = void 0;
        for (const attribute of node2.attributes) {
          if (attribute.type === "Spread") {
            continue nodes;
          }
          if (attribute.type !== "Attribute")
            continue;
          if (attribute.name.toLowerCase() !== "class")
            continue;
          class_attribute = attribute;
        }
        if (class_attribute && class_attribute.value !== true) {
          const chunks = class_attribute.value;
          if (chunks.length === 1 && chunks[0].type === "Text") {
            chunks[0].data += ` ${this.id}`;
          } else {
            chunks.push({
              type: "Text",
              data: ` ${this.id}`,
              raw: ` ${this.id}`,
              parent: null
            });
          }
        } else {
          node2.attributes.push({
            type: "Attribute",
            name: "class",
            value: [{ type: "Text", data: this.id, raw: this.id, parent: null }],
            parent: null
          });
        }
      }
  }
  /**
   * @param {string} file
   * @param {string} source
   * @param {boolean} dev
   */
  render(file, source, dev) {
    if (!this.ast)
      throw new Error("Unexpected error");
    const code = new MagicString(source);
    walk(
      /** @type {import('./private.js').CssNode} */
      this.ast,
      null,
      {
        _: (node2) => {
          code.addSourcemapLocation(node2.start);
          code.addSourcemapLocation(node2.end);
        }
      }
    );
    const max = Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
    for (const child of this.children) {
      child.transform(code, this.id, this.keyframes, max);
    }
    code.remove(
      0,
      /** @type {number} */
      this.ast.start
    );
    code.prependRight(
      /** @type {number} */
      this.ast.start,
      "/*"
    );
    code.appendLeft(
      /** @type {number} */
      this.ast.content.start,
      "*/"
    );
    for (const child of this.children) {
      child.prune(code, dev);
    }
    code.prependRight(this.ast.content.end, "/*");
    code.appendLeft(
      /** @type {number} */
      this.ast.end,
      "*/"
    );
    code.remove(
      /** @type {number} */
      this.ast.end,
      source.length
    );
    return {
      code: code.toString(),
      map: code.generateMap({
        includeContent: true,
        source: this.filename,
        file
      })
    };
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    this.children.forEach((child) => {
      child.validate(analysis);
    });
  }
  /** @param {import('../../types.js').Analysis} analysis */
  warn_on_unused_selectors(analysis) {
  }
};

// src/compiler/phases/2-analyze/validation.js
function validate_component(node2, context) {
  for (const attribute of node2.attributes) {
    if (attribute.type !== "Attribute" && attribute.type !== "Spread" && attribute.type !== "LetDirective" && attribute.type !== "OnDirective" && attribute.type !== "BindDirective") {
      error(attribute, "invalid-component-directive");
    }
  }
  context.next({
    ...context.state,
    parent_element: null
  });
}
function validate_element(node2, context) {
  for (const attribute of node2.attributes) {
    if (attribute.type === "Attribute" && attribute.name === "slot") {
      let owner = void 0;
      let i = context.path.length;
      while (i--) {
        const ancestor = context.path[i];
        if (ancestor.type === "InlineComponent" || ancestor.type === "DynamicComponent" || ancestor.type === "SelfElement" || ancestor.type === "RegularElement" || ancestor.type === "DynamicElement") {
          owner = ancestor;
        }
      }
      if (owner) {
        if (attribute.value === true || attribute.value.length > 1) {
          error(attribute, "invalid-slot-attribute");
        }
        const value2 = attribute.value[0];
        if (value2.type !== "Text") {
          error(attribute, "invalid-slot-attribute");
        }
        if (owner.type === "InlineComponent" || owner.type === "DynamicComponent") {
          if (owner !== context.path.at(-2)) {
            error(attribute, "invalid-slot-placement");
          }
        }
      } else {
        error(attribute, "invalid-slot-placement");
      }
    }
  }
}
var implied_end_tags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
function is_tag_valid_with_parent(tag2, parent_tag) {
  switch (parent_tag) {
    case "select":
      return tag2 === "option" || tag2 === "optgroup" || tag2 === "#text";
    case "optgroup":
      return tag2 === "option" || tag2 === "#text";
    case "option":
      return tag2 === "#text";
    case "tr":
      return tag2 === "th" || tag2 === "td" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "tbody":
    case "thead":
    case "tfoot":
      return tag2 === "tr" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "colgroup":
      return tag2 === "col" || tag2 === "template";
    case "table":
      return tag2 === "caption" || tag2 === "colgroup" || tag2 === "tbody" || tag2 === "tfoot" || tag2 === "thead" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "head":
      return tag2 === "base" || tag2 === "basefont" || tag2 === "bgsound" || tag2 === "link" || tag2 === "meta" || tag2 === "title" || tag2 === "noscript" || tag2 === "noframes" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "html":
      return tag2 === "head" || tag2 === "body" || tag2 === "frameset";
    case "frameset":
      return tag2 === "frame";
    case "#document":
      return tag2 === "html";
  }
  switch (tag2) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      return parent_tag !== "h1" && parent_tag !== "h2" && parent_tag !== "h3" && parent_tag !== "h4" && parent_tag !== "h5" && parent_tag !== "h6";
    case "rp":
    case "rt":
      return implied_end_tags.indexOf(parent_tag) === -1;
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
    case "tbody":
    case "td":
    case "tfoot":
    case "th":
    case "thead":
    case "tr":
      return parent_tag == null;
  }
  return true;
}
var validation = {
  BindDirective(node2, context) {
    validate_no_const_assignment(node2, node2.expression, context.state.scope);
    let left = node2.expression;
    while (left.type === "MemberExpression") {
      left = /** @type {import('estree').MemberExpression} */
      left.object;
    }
    if (left.type !== "Identifier") {
      error(node2, "invalid-binding-expression");
    }
    if (node2.expression.type === "Identifier" && node2.name !== "this") {
      const binding = context.state.scope.get(left.name);
      if (!binding || binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "each" && binding.kind !== "store_sub" && !binding.mutated) {
        error(node2, "invalid-binding-value");
      }
    }
    if (node2.name === "group") {
      const binding = context.state.scope.get(left.name);
      if (!binding) {
        error(node2, "INTERNAL", "Cannot find declaration for bind:group");
      }
    }
  },
  RegularElement(node2, context) {
    if (node2.name === "textarea" && node2.fragment.nodes.length > 0) {
      for (const attribute of node2.attributes) {
        if (attribute.type === "Attribute" && attribute.name === "value") {
          error(node2, "invalid-textarea-content");
        }
      }
    }
    validate_element(node2, context);
    if (context.state.parent_element) {
      if (!is_tag_valid_with_parent(node2.name, context.state.parent_element)) {
        error(node2, "invalid-node-placement", `<${node2.name}>`, context.state.parent_element);
      }
    }
    context.next({
      ...context.state,
      parent_element: node2.name
    });
  },
  DynamicElement(node2, context) {
    validate_element(node2, context);
    context.next({
      ...context.state,
      parent_element: null
    });
  },
  InlineComponent: validate_component,
  DynamicComponent: validate_component,
  SelfElement: validate_component,
  Text(node2, context) {
    if (!node2.parent)
      return;
    if (context.state.parent_element && regex_not_whitespace.test(node2.data)) {
      if (!is_tag_valid_with_parent("#text", context.state.parent_element)) {
        error(node2, "invalid-node-placement", "Text node", context.state.parent_element);
      }
    }
  },
  MustacheTag(node2, context) {
    if (!node2.parent)
      return;
    if (context.state.parent_element) {
      if (!is_tag_valid_with_parent("#text", context.state.parent_element)) {
        error(node2, "invalid-node-placement", "{expression}", context.state.parent_element);
      }
    }
  }
};
var validation_legacy = merge(validation, {
  VariableDeclarator(node2) {
    if (node2.init?.type !== "CallExpression")
      return;
    const callee = node2.init.callee;
    if (callee.type !== "Identifier" || callee.name !== "$state" && callee.name !== "$derived" && callee.name !== "$props") {
      return;
    }
    error(node2.init, "invalid-rune-usage", callee.name);
  },
  ExportNamedDeclaration(node2) {
    if (node2.declaration && node2.declaration.type !== "VariableDeclaration" && node2.declaration.type !== "FunctionDeclaration") {
      error(node2, "TODO", "whatever this is");
    }
  },
  SlotTemplate(node2) {
    for (const attribute of node2.attributes) {
      if (attribute.type === "Attribute") {
        if (attribute.name === "slot") {
          if (!is_text_attribute(attribute)) {
            error(attribute, "invalid-svelte-fragment-slot");
          }
        }
      } else if (attribute.type !== "LetDirective") {
        error(attribute, "invalid-svelte-fragment-attribute");
      }
    }
  },
  Slot(node2) {
    for (const attribute of node2.attributes) {
      if (attribute.type === "Attribute") {
        if (attribute.name === "name") {
          if (!is_text_attribute(attribute)) {
            error(attribute, "invalid-slot-name");
          }
        }
      } else if (attribute.type !== "Spread") {
        error(attribute, "invalid-slot-element-attribute");
      }
    }
  }
});
function validate_export(node2, scope, name8) {
  const binding = scope.get(name8);
  if (binding && (binding.kind === "derived" || binding.kind === "state")) {
    error(node2, "invalid-rune-export", `$${binding.kind}`);
  }
}
function validate_call_expression(node2, scope, path) {
  const rune = get_rune(node2, scope);
  if (rune === null)
    return;
  if ((rune === "$derived" || rune === "$props" || rune === "$state") && path.at(-1)?.type !== "VariableDeclarator") {
    error(
      node2,
      rune === "$derived" ? "invalid-derived-location" : rune === "$props" ? "invalid-props-location" : "invalid-state-location"
    );
  } else if (rune === "$effect") {
    if (path.at(-1)?.type !== "ExpressionStatement") {
      error(node2, "invalid-effect-location");
    } else if (node2.arguments.length !== 1) {
      error(node2, "invalid-rune-args-length", "$effect", [1]);
    }
  }
}
var validation_runes_js = {
  ExportSpecifier(node2, { state }) {
    validate_export(node2, state.scope, node2.local.name);
  },
  ExportNamedDeclaration(node2, { state, next: next2 }) {
    if (node2.declaration?.type !== "VariableDeclaration")
      return;
    next2();
    for (const declarator2 of node2.declaration.declarations) {
      for (const id2 of extract_identifiers(declarator2.id)) {
        validate_export(node2, state.scope, id2.name);
      }
    }
  },
  CallExpression(node2, { state, path }) {
    validate_call_expression(node2, state.scope, path);
  },
  VariableDeclarator(node2, { state }) {
    const init2 = node2.init;
    const rune = get_rune(init2, state.scope);
    if (rune === null)
      return;
    const args = (
      /** @type {import('estree').CallExpression} */
      init2.arguments
    );
    if (rune === "$derived" && args.length !== 1) {
      error(node2, "invalid-rune-args-length", "$derived", [1]);
    } else if (rune === "$state" && args.length > 1) {
      error(node2, "invalid-rune-args-length", "$state", [0, 1]);
    } else if (rune === "$props") {
      error(node2, "invalid-props-location");
    }
  },
  AssignmentExpression(node2, { state }) {
    validate_assignment(node2, node2.left, state.scope);
  },
  UpdateExpression(node2, { state }) {
    validate_assignment(node2, node2.argument, state.scope);
  }
};
function validate_no_const_assignment(node2, argument, scope) {
  if (argument.type === "Identifier") {
    const binding = scope.get(argument.name);
    if (binding?.declaration_kind === "const" && binding.kind !== "each") {
      error(node2, "invalid-const-assignment");
    }
  }
}
function validate_assignment(node2, argument, scope) {
  validate_no_const_assignment(node2, argument, scope);
  let left = (
    /** @type {import('estree').Pattern} */
    argument
  );
  while (left.type === "MemberExpression") {
    left = /** @type {import('estree').Identifier | import('estree').MemberExpression} */
    left.object;
  }
  if (left.type === "Identifier") {
    const binding = scope.get(left.name);
    if (binding?.kind === "derived") {
      error(node2, "invalid-derived-assignment");
    }
  }
}
var validation_runes = merge(validation, {
  AssignmentExpression(node2, { state, path }) {
    const parent = path.at(-1);
    if (parent && parent.type === "ConstTag")
      return;
    validate_assignment(node2, node2.left, state.scope);
  },
  UpdateExpression(node2, { state }) {
    validate_assignment(node2, node2.argument, state.scope);
  },
  LabeledStatement(node2, { path }) {
    if (node2.label.name !== "$" || path.at(-1)?.type !== "Program")
      return;
    error(node2, "invalid-legacy-reactive-statement");
  },
  ExportNamedDeclaration(node2, { state }) {
    if (node2.declaration?.type !== "VariableDeclaration")
      return;
    if (node2.declaration.kind !== "let")
      return;
    if (state.analysis.instance.scope !== state.scope)
      return;
    error(node2, "invalid-legacy-export");
  },
  ExportSpecifier(node2, { state }) {
    validate_export(node2, state.scope, node2.local.name);
  },
  CallExpression(node2, { state, path }) {
    validate_call_expression(node2, state.scope, path);
  },
  EachBlock(node2, { next: next2, state }) {
    const context = node2.context;
    if (context.type === "Identifier" && (context.name === "$state" || context.name === "$derived")) {
      error(
        node2,
        context.name === "$derived" ? "invalid-derived-location" : "invalid-state-location"
      );
    }
    next2({ ...state });
  },
  VariableDeclarator(node2, { state }) {
    const init2 = node2.init;
    const rune = get_rune(init2, state.scope);
    if (rune === null)
      return;
    const args = (
      /** @type {import('estree').CallExpression} */
      init2.arguments
    );
    if (rune === "$derived" && args.length !== 1) {
      error(node2, "invalid-rune-args-length", "$derived", [1]);
    } else if (rune === "$state" && args.length > 1) {
      error(node2, "invalid-rune-args-length", "$state", [0, 1]);
    } else if (rune === "$props") {
      if (args.length > 0) {
        error(node2, "invalid-rune-args-length", "$props", [0]);
      }
      if (node2.id.type !== "ObjectPattern") {
        error(node2, "invalid-props-id");
      }
      if (state.scope !== state.analysis.instance.scope) {
        error(node2, "invalid-props-location");
      }
      for (const property of node2.id.properties) {
        if (property.type === "Property") {
          if (property.computed) {
            error(property, "invalid-props-pattern");
          }
          const value2 = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
          if (value2.type !== "Identifier") {
            error(property, "invalid-props-pattern");
          }
        }
      }
    }
  }
});

// src/compiler/warnings.js
var css2 = {
  "unused-selector": () => "Unused CSS selector"
};
var runes2 = {
  /** @param {string} name */
  "store-with-rune-name": (name8) => `It looks like you're using the $${name8} rune, but there is a local binding called ${name8}. Referencing a local variable with a $ prefix will create a store subscription. Please rename ${name8} to avoid the ambiguity.`
};
var warnings = {
  ...css2,
  ...runes2
};
function warn(node2, code, ...args) {
  const start = typeof node2 === "number" ? node2 : node2?.start;
  const end = typeof node2 === "number" ? node2 : node2?.end;
  const fn2 = warnings[code];
  const message = fn2(...args);
  return { code, message, start, end };
}

// src/compiler/phases/2-analyze/index.ts
function js2(script, root, allow_reactive_declarations, parent = null) {
  const ast = script?.content ?? {
    type: "Program",
    sourceType: "module",
    start: -1,
    end: -1,
    body: []
  };
  const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
  return { ast, scope, scopes };
}
function get_component_name(filename) {
  const parts = filename.split(/[/\\]/);
  const basename = parts.pop();
  const last_dir = parts.at(-1);
  let name8 = basename.replace(".svelte", "");
  if (name8 === "index" && last_dir && last_dir !== "src") {
    name8 = last_dir;
  }
  return name8[0].toUpperCase() + name8.slice(1);
}
function analyze_module(ast, options) {
  const { scope, scopes } = create_scopes(ast, new ScopeRoot(), false);
  const uses_runes = [...scope.references].some(([name8]) => {
    return Runes.includes(name8) && scope.get(name8) === null;
  });
  if (!uses_runes) {
    return null;
  }
  walk(
    ast,
    { scope },
    merge(set_scope(scopes), validation_runes_js, runes_scope_js_tweaker)
  );
  return {
    // These are the important ones to set that actually matter
    module: { ast, scope, scopes },
    root: scope.root,
    runes: true,
    // These are all just placeholders which are not actually used,
    // but it makes it possible to reuse the dom/ssr generation code.
    accessors: false,
    binding_groups: /* @__PURE__ */ new Map(),
    dev: false,
    dynamic_nodes: /* @__PURE__ */ new Set(),
    elements: [],
    exports: [],
    immutable: false,
    instance: {
      ast: { type: "Program", body: [], sourceType: "module" },
      scope,
      scopes: /* @__PURE__ */ new Map()
    },
    template: { ast: { type: "Template", body: [], parent: null }, scope, scopes: /* @__PURE__ */ new Map() },
    name: options.filename || "module",
    namespace: void 0,
    preserve_comments: false,
    preserve_whitespace: false,
    reactive_statements: /* @__PURE__ */ new Map(),
    stylesheet: new Stylesheet({ ast: void 0, component_name: "", filename: "" }),
    uses_rest_props: false,
    warnings: []
  };
}
function analyze_component(root, global_options) {
  const options = {
    ...global_options,
    ...root.options
  };
  const scope_root = new ScopeRoot();
  const module = js2(
    root.js.find((script) => script.context === "module"),
    scope_root,
    false
  );
  const instance = js2(
    root.js.find((script) => script.context !== "module"),
    scope_root,
    true,
    module.scope
  );
  const template2 = {
    ast: {
      type: "Template",
      body: root.fragment.nodes,
      parent: null,
      // appease typescript
      start: -1,
      end: -1
    },
    // these will be set right afterwards
    scope: null,
    scopes: null
  };
  ({ scope: template2.scope, scopes: template2.scopes } = create_scopes(
    template2.ast,
    scope_root,
    false,
    instance.scope
  ));
  const warnings2 = [];
  for (const [name8, references] of module.scope.references) {
    if (name8[0] !== "$" || ReservedKeywords.has(name8))
      continue;
    if (name8 === "$" || name8[1] === "$") {
      error(references[0], "illegal-global", name8);
    }
    const store_name = name8.slice(1);
    const declaration2 = instance.scope.get(store_name);
    if (options.runes === false || !Runes.includes(name8) || declaration2 !== null && // const state = $state(0) is valid
    !Runes.includes(get_callee_name(declaration2.initial)) && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
    !(name8 === "$derived" && declaration2.initial?.type === "ImportDeclaration" && declaration2.initial.source.value === "svelte/store")) {
      if (options.runes !== false) {
        if (declaration2 === null && /[a-z]/.test(store_name[0])) {
          error(references[0], "illegal-global", name8);
        } else if (declaration2 !== null && Runes.includes(name8)) {
          warnings2.push(warn(declaration2.node, "store-with-rune-name", store_name));
        }
      }
      const binding = instance.scope.declare(id(name8), "store_sub", "let");
      binding.references = references;
    }
  }
  const component_name = get_component_name(global_options.filename ?? "Component");
  const analysis = {
    name: module.scope.generate(global_options.name ?? component_name),
    root: scope_root,
    module,
    instance,
    template: template2,
    elements: [],
    stylesheet: new Stylesheet({
      ast: root.css[0],
      // TODO are any of these necessary or can we just pass in the whole `analysis` object later?
      filename: global_options.filename ?? "<unknown>",
      component_name,
      get_css_hash: global_options.cssHash
    }),
    runes: options.runes ?? Array.from(module.scope.references).some(([name8]) => Runes.includes(name8)),
    immutable: options.immutable ?? false,
    exports: [],
    dynamic_nodes: /* @__PURE__ */ new Set(),
    uses_rest_props: false,
    dev: options.dev ?? false,
    accessors: options.accessors ?? false,
    preserve_comments: options.preserveComments ?? false,
    preserve_whitespace: options.preserveWhitespace ?? false,
    namespace: options.namespace,
    reactive_statements: /* @__PURE__ */ new Map(),
    binding_groups: /* @__PURE__ */ new Map(),
    warnings: warnings2
  };
  if (analysis.runes) {
    const props_refs = module.scope.references.get("$$props");
    if (props_refs) {
      error(props_refs[0], "invalid-legacy-props");
    }
    const rest_props_refs = module.scope.references.get("$$restProps");
    if (rest_props_refs) {
      error(rest_props_refs[0], "invalid-legacy-rest-props");
    }
    for (const { ast, scope, scopes } of [module, instance, template2]) {
      const state = {
        scope,
        analysis,
        dynamic: { scope, value: false },
        parent_element: null
      };
      walk(
        ast,
        state,
        merge(set_scope(scopes), validation_runes, runes_scope_tweaker, common_visitors)
      );
    }
  } else {
    instance.scope.declare(id("$$props"), "prop", "const");
    instance.scope.declare(id("$$restProps"), "rest_prop", "const");
    for (const { ast, scope, scopes } of [module, instance, template2]) {
      const state = {
        scope,
        analysis,
        parent_element: null,
        ast_type: ast === instance.ast ? "instance" : ast === template2.ast ? "template" : "module",
        instance_scope: instance.scope,
        dynamic: { scope, value: false },
        reactive_statement: null,
        reactive_statements: analysis.reactive_statements
      };
      walk(
        ast,
        state,
        // @ts-expect-error TODO
        merge(set_scope(scopes), validation_legacy, legacy_scope_tweaker, common_visitors)
      );
    }
    analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
  }
  analysis.stylesheet.validate(analysis);
  for (const element of analysis.elements) {
    analysis.stylesheet.apply(element);
  }
  analysis.stylesheet.reify();
  return analysis;
}
var legacy_scope_tweaker = {
  LabeledStatement(node2, { next: next2, path, state }) {
    if (state.ast_type !== "instance" || node2.label.name !== "$" || path.at(-1).type !== "Program") {
      return next2();
    }
    const reactive_statement = {
      assignments: /* @__PURE__ */ new Set(),
      dependencies: /* @__PURE__ */ new Set()
    };
    next2({ ...state, reactive_statement });
    for (const [name8, nodes] of state.scope.references) {
      const binding = state.scope.get(name8);
      if (binding === null)
        continue;
      if (nodes.some((n2) => n2 !== binding.node && !reactive_statement.assignments.has(n2))) {
        reactive_statement.dependencies.add(binding);
      }
    }
    state.reactive_statements.set(node2, reactive_statement);
    if (node2.body.type === "ExpressionStatement" && node2.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node2.body.expression.left)) {
        const binding = state.scope.get(id2.name);
        if (binding?.kind === "legacy_reactive") {
          binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
        }
      }
    }
  },
  AssignmentExpression(node2, { state, next: next2 }) {
    if (state.reactive_statement && node2.operator === "=") {
      for (const id2 of extract_identifiers(node2.left)) {
        state.reactive_statement.assignments.add(id2);
      }
    }
    next2();
  },
  Identifier(node2, { state, path }) {
    const parent = path.at(-1);
    if (is_reference(node2, parent)) {
      if (node2.name === "$$restProps") {
        state.analysis.uses_rest_props = true;
      }
      let binding = state.scope.get(node2.name);
      if (binding?.kind === "store_sub") {
        binding = state.scope.get(node2.name.slice(1));
      }
      if (binding !== null && binding.kind === "normal" && binding.scope === state.instance_scope && binding.declaration_kind !== "function" && binding.declaration_kind !== "import") {
        if (binding.mutated && // TODO could be more fine-grained - not every mention in the template implies a state binding
        (state.reactive_statement || state.ast_type === "template")) {
          binding.kind = "state";
        } else if (state.reactive_statement && parent.type === "AssignmentExpression" && parent.left === binding.node) {
          binding.kind = "derived";
        } else {
          let idx = -1;
          let ancestor = path.at(idx);
          while (ancestor) {
            if (ancestor.type === "EachBlock") {
              if (ancestor.expression === (idx === -1 ? node2 : path.at(idx + 1))) {
                binding.kind = "state";
                break;
              }
            }
            ancestor = path.at(--idx);
          }
        }
      }
    }
  },
  ExportNamedDeclaration(node2, { next: next2, state }) {
    if (state.ast_type !== "instance") {
      return next2();
    }
    if (!node2.declaration) {
      for (const specifier of node2.specifiers) {
        const binding = state.scope.get(specifier.local.name);
        if (binding.kind === "state" || binding.kind === "normal" && binding.declaration_kind === "let") {
          binding.kind = "prop";
          if (specifier.exported.name !== specifier.local.name) {
            binding.prop_alias = specifier.exported.name;
          }
        } else {
          state.analysis.exports.push({
            name: specifier.local.name,
            alias: specifier.exported.name
          });
        }
      }
      return next2();
    }
    if (node2.declaration.type === "FunctionDeclaration") {
      state.analysis.exports.push({ name: node2.declaration.id.name, alias: null });
      return next2();
    }
    if (node2.declaration.type === "VariableDeclaration") {
      if (node2.declaration.kind === "const") {
        for (const declarator2 of node2.declaration.declarations) {
          for (const node3 of extract_identifiers(declarator2.id)) {
            state.analysis.exports.push({ name: node3.name, alias: null });
          }
        }
        return next2();
      }
      for (const declarator2 of node2.declaration.declarations) {
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state.scope.get(id2.name);
          binding.kind = "prop";
        }
      }
    }
  }
};
var runes_scope_js_tweaker = {
  VariableDeclarator(node2, { state }) {
    if (node2.init?.type !== "CallExpression")
      return;
    if (get_rune(node2.init, state.scope) === null)
      return;
    const callee = node2.init.callee;
    if (callee.type !== "Identifier")
      return;
    const name8 = callee.name;
    if (name8 !== "$state" && name8 !== "$derived")
      return;
    for (const path of extract_paths(node2.id)) {
      const binding = state.scope.get(path.node.name);
      binding.kind = name8 === "$state" ? "state" : "derived";
    }
  }
};
var runes_scope_tweaker = {
  VariableDeclarator(node2, { state }) {
    if (node2.init?.type !== "CallExpression")
      return;
    if (get_rune(node2.init, state.scope) === null)
      return;
    const callee = node2.init.callee;
    if (callee.type !== "Identifier")
      return;
    const name8 = callee.name;
    if (name8 !== "$state" && name8 !== "$derived" && name8 !== "$props")
      return;
    for (const path of extract_paths(node2.id)) {
      const binding = state.scope.get(path.node.name);
      binding.kind = name8 === "$state" ? "state" : name8 === "$derived" ? "derived" : path.is_rest ? "rest_prop" : "prop";
    }
    if (name8 === "$props") {
      for (const property of node2.id.properties) {
        if (property.type !== "Property")
          continue;
        const name9 = property.value.type === "AssignmentPattern" ? property.value.left.name : property.value.name;
        const alias = property.key.type === "Identifier" ? property.key.name : property.key.value;
        const binding = state.scope.get(name9);
        binding.prop_alias = alias;
      }
    }
  },
  ExportSpecifier(node2, { state }) {
    state.analysis.exports.push({
      name: node2.local.name,
      alias: node2.exported.name
    });
  }
};
var find_dynamic_nodes = (node2, context) => {
  const dynamic = { scope: context.state.scope, value: false };
  context.next({ ...context.state, dynamic });
  if (dynamic.value) {
    context.state.analysis.dynamic_nodes.add(node2);
  }
};
function is_known_safe_call(node2, context) {
  const callee = node2.callee;
  if (callee.type === "MemberExpression" && callee.object.type === "Identifier") {
    const binding = context.state.scope.get(callee.object.name);
    const selector_binding = context.state.scope.get("selector");
    if (selector_binding !== null && selector_binding.declaration_kind === "import" && selector_binding.initial !== null && selector_binding.initial.type === "ImportDeclaration" && selector_binding.initial.source.value === "svelte" && binding !== null && binding.initial !== null && binding.initial.type === "CallExpression" && binding.initial.callee.type === "Identifier" && binding.initial.callee.name === "selector") {
      return true;
    }
  }
  if (callee.type === "Identifier") {
    const name8 = callee.name;
    const binding = context.state.scope.get(name8);
    if (binding === null && (name8 === "BigInt" || name8 === "String" || name8 === "Number" || name8 === "Boolean")) {
      return true;
    }
  }
  return false;
}
var common_visitors = {
  Attribute: find_dynamic_nodes,
  ClassDirective: find_dynamic_nodes,
  Spread: find_dynamic_nodes,
  Property: find_dynamic_nodes,
  StyleDirective(node2, context) {
    if (node2.value === true) {
      const binding = context.state.scope.get(node2.name);
      if (binding?.kind !== "normal") {
        context.state.analysis.dynamic_nodes.add(node2);
      }
    } else {
      find_dynamic_nodes(node2, context);
    }
  },
  Identifier(node2, context) {
    const parent = context.path.at(-1);
    if (!is_reference(node2, parent))
      return;
    const binding = context.state.scope.get(node2.name);
    if (binding?.kind !== "normal") {
      context.state.analysis.dynamic_nodes.add(node2);
      if (context.state.scope === context.state.dynamic.scope) {
        context.state.dynamic.value = true;
      }
    }
  },
  CallExpression(node2, context) {
    if (!is_known_safe_call(node2, context)) {
      for (const node3 of context.path) {
        if (node3.type === "MustacheTag") {
          node3.metadata.contains_call_expression = true;
          break;
        }
      }
    }
    if (context.state.scope === context.state.dynamic.scope) {
      context.state.dynamic.value = true;
    }
    const callee = node2.callee;
    if (callee.type === "Identifier") {
      const binding = context.state.scope.get(callee.name);
      if (binding !== null) {
        binding.is_called = true;
      }
    }
    context.next();
  },
  MemberExpression(node2, context) {
    if (context.state.scope === context.state.dynamic.scope) {
      context.state.dynamic.value = true;
    }
    if (node2.object.type === "Identifier") {
      const binding = context.state.scope.get(node2.object.name);
      if (binding !== null) {
        binding.is_used_as_member = true;
      }
    }
    context.next();
  },
  BindDirective(node2, context) {
    if (node2.name !== "group")
      return;
    let i = context.path.length;
    while (i--) {
      const parent = context.path[i];
      if (parent.type === "EachBlock") {
        parent.metadata.contains_group_binding = true;
        for (const binding2 of parent.metadata.references) {
          binding2.mutated = true;
        }
      }
    }
    const id2 = object2(node2.expression);
    const binding = id2 === null ? null : context.state.scope.get(id2.name);
    ok(binding);
    let group = context.state.analysis.binding_groups.get(binding);
    if (!group) {
      group = {
        name: context.state.scope.root.unique("binding_group"),
        directives: []
      };
      context.state.analysis.binding_groups.set(binding, group);
    }
    group.directives.push(node2);
    node2.metadata = {
      binding_group_name: group.name,
      parent_each_blocks: context.path.filter((p) => p.type === "EachBlock")
    };
  },
  OnDirective(node2, context) {
    const handler = node2.expression;
    const event_name = node2.name;
    node2.metadata = { delegated: null };
    context.next();
    if (!handler || node2.modifiers.includes("capture") || !DelegatedEvents.has(event_name)) {
      return;
    }
    const element = context.path.at(-1);
    if (element == null || element.type !== "RegularElement" && element.type !== "Slot") {
      return;
    }
    if (element.attributes.filter((attr) => attr.type === "OnDirective").length > 1) {
      return;
    }
    let target_function = null;
    let binding = null;
    if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
      target_function = handler;
    } else if (handler.type === "Identifier") {
      binding = context.state.scope.get(handler.name);
      if (binding !== null && binding.initial !== null && !binding.mutated && !binding.is_called) {
        const binding_type = binding.initial.type;
        if (binding_type === "ArrowFunctionExpression" || binding_type === "FunctionDeclaration" || binding_type === "FunctionExpression") {
          target_function = binding.initial;
        }
      }
    }
    if (target_function == null) {
      return;
    }
    if (target_function.params.length > 1) {
      return;
    }
    const metadata = target_function.metadata;
    const scope = metadata.scope;
    for (const [reference] of scope.references) {
      const binding2 = scope.get(reference);
      if (binding2 !== null && (!context.state.analysis.runes && binding2.kind === "each" || binding2.kind === "normal") && binding2.mutated) {
        return;
      }
    }
    metadata.delegated = true;
    node2.metadata.delegated = target_function;
  },
  ArrowFunctionExpression(node2, context) {
    node2.metadata = {
      delegated: false,
      delegated_params: [],
      scope: context.state.scope
    };
  },
  FunctionExpression(node2, context) {
    node2.metadata = {
      delegated: false,
      delegated_params: [],
      scope: context.state.scope
    };
  },
  FunctionDeclaration(node2, context) {
    node2.metadata = {
      delegated: false,
      delegated_params: [],
      scope: context.state.scope
    };
  },
  RegularElement(node2, context) {
    if (node2.name === "textarea" && node2.fragment.nodes.length > 0) {
      if (node2.fragment.nodes.length > 1 || node2.fragment.nodes[0].type !== "Text") {
        const first = node2.fragment.nodes[0];
        if (first.type === "Text") {
          first.data = first.data.replace(/\r?\n/, "");
          first.raw = first.raw.replace(/\r?\n/, "");
        }
        node2.attributes.push({
          type: "Attribute",
          name: "value",
          // @ts-ignore
          value: node2.fragment.nodes,
          start: node2.fragment.nodes[0].start,
          end: node2.fragment.nodes[node2.fragment.nodes.length - 1].end
        });
        node2.fragment.nodes = [];
      }
    }
    if (node2.name === "option" && node2.fragment.nodes?.length === 1 && node2.fragment.nodes[0].type === "MustacheTag" && !node2.attributes.some(
      (attribute) => attribute.type === "Attribute" && attribute.name === "value"
    )) {
      const child = node2.fragment.nodes[0];
      node2.attributes.push({
        type: "Attribute",
        name: "value",
        value: [child],
        start: child.start,
        end: child.end,
        parent: null
      });
    }
    context.state.analysis.elements.push(node2);
  },
  DynamicElement(node2, { state }) {
    state.analysis.elements.push(node2);
  }
};
function order_reactive_statements(unsorted_reactive_declarations) {
  const lookup = /* @__PURE__ */ new Map();
  for (const [node2, declaration2] of unsorted_reactive_declarations) {
    declaration2.assignments.forEach(({ name: name8 }) => {
      const statements = lookup.get(name8) ?? [];
      statements.push([node2, declaration2]);
      lookup.set(name8, statements);
    });
  }
  const reactive_declarations = /* @__PURE__ */ new Map();
  const add_declaration = (node2, declaration2) => {
    if ([...reactive_declarations.values()].includes(declaration2))
      return;
    declaration2.dependencies.forEach(({ node: { name: name8 } }) => {
      if ([...declaration2.assignments].some((a) => a.name === name8))
        return;
      for (const [node3, earlier] of lookup.get(name8) ?? []) {
        add_declaration(node3, earlier);
      }
    });
    reactive_declarations.set(node2, declaration2);
  };
  for (const [node2, declaration2] of unsorted_reactive_declarations) {
    add_declaration(node2, declaration2);
  }
  return reactive_declarations;
}

// ../../node_modules/.pnpm/esrap@1.0.2/node_modules/esrap/src/handlers.js
function push_array2(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}
function handle(node2, state) {
  const handler = handlers[node2.type];
  if (!handler) {
    throw new Error(`Not implemented ${node2.type}`);
  }
  const result = handler(node2, state);
  if (node2.leadingComments) {
    result.unshift(
      c(
        node2.leadingComments.map(
          (comment) => comment.type === "Block" ? `/*${comment.value}*/${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment.value}${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}`
        ).join(``)
      )
    );
  }
  if (node2.trailingComments) {
    state.comments.push(node2.trailingComments[0]);
  }
  return result;
}
function c(content, node2) {
  return {
    content,
    loc: node2?.loc ?? null,
    has_newline: /\n/.test(content)
  };
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  MetaProperty: 19,
  CallExpression: 19,
  ChainExpression: 19,
  ImportExpression: 19,
  NewExpression: 19,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node2, parent, is_right) {
  if (node2.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node2.operator !== "??" || parent.operator !== "??" && node2.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node2.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {import('estree').BinaryExpression} */
    node2.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {import('estree').BinaryExpression} */
      node2.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {import('estree').BinaryExpression} */
    node2.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node2) {
  while (node2) {
    if (node2.type[0] === "CallExpression") {
      return true;
    } else if (node2.type === "MemberExpression") {
      node2 = node2.object;
    } else {
      return false;
    }
  }
}
var has_newline = (chunks) => {
  for (let i = 0; i < chunks.length; i += 1) {
    if (chunks[i].has_newline)
      return true;
  }
  return false;
};
var get_length = (chunks) => {
  let total = 0;
  for (let i = 0; i < chunks.length; i += 1) {
    total += chunks[i].content.length;
  }
  return total;
};
var sum = (a, b2) => a + b2;
var join = (nodes, separator) => {
  if (nodes.length === 0)
    return [];
  const joined = [...nodes[0]];
  for (let i = 1; i < nodes.length; i += 1) {
    joined.push(separator);
    push_array2(joined, nodes[i]);
  }
  return joined;
};
var handle_body = (nodes, state) => {
  const chunks = [];
  const body = nodes.filter((statement) => statement.type !== "EmptyStatement").map((statement) => {
    const chunks2 = handle(statement, {
      ...state,
      indent: state.indent
    });
    let add_newline = false;
    while (state.comments.length) {
      const comment = (
        /** @type {import('estree').Comment} */
        state.comments.shift()
      );
      const prefix = add_newline ? `
${state.indent}` : ` `;
      chunks2.push(
        c(
          comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`
        )
      );
      add_newline = comment.type === "Line";
    }
    return chunks2;
  });
  let needed_padding = false;
  for (let i = 0; i < body.length; i += 1) {
    const needs_padding = has_newline(body[i]);
    if (i > 0) {
      chunks.push(c(needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`));
    }
    push_array2(chunks, body[i]);
    needed_padding = needs_padding;
  }
  return chunks;
};
var handle_var_declaration = (node2, state) => {
  const chunks = [c(`${node2.kind} `)];
  const declarators = node2.declarations.map(
    (d2) => handle(d2, {
      ...state,
      indent: state.indent + (node2.declarations.length === 1 ? "" : "	")
    })
  );
  const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
  const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
  push_array2(chunks, join(declarators, separator));
  return chunks;
};
var shared = {
  /**
   * @param {import('estree').ArrayExpression | import('estree').ArrayPattern} node
   * @param {import('./types').State} state
   */
  "ArrayExpression|ArrayPattern": (node2, state) => {
    const chunks = [c("[")];
    const elements2 = [];
    let sparse_commas = [];
    for (let i = 0; i < node2.elements.length; i += 1) {
      const element = node2.elements[i];
      if (element) {
        elements2.push([
          ...sparse_commas,
          ...handle(element, {
            ...state,
            indent: state.indent + "	"
          })
        ]);
        sparse_commas = [];
      } else {
        sparse_commas.push(c(","));
      }
    }
    const multiple_lines = elements2.some(has_newline) || elements2.map(get_length).reduce(sum, 0) + (state.indent.length + elements2.length - 1) * 2 > 80;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array2(chunks, join(elements2, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent}`));
      push_array2(chunks, sparse_commas);
    } else {
      push_array2(chunks, join(elements2, c(", ")));
      push_array2(chunks, sparse_commas);
    }
    chunks.push(c("]"));
    return chunks;
  },
  /**
   * @param {import('estree').BinaryExpression | import('estree').LogicalExpression} node
   * @param {import('./types').State} state
   */
  "BinaryExpression|LogicalExpression": (node2, state) => {
    const chunks = [];
    if (needs_parens(node2.left, node2, false)) {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.left, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.left, state));
    }
    chunks.push(c(` ${node2.operator} `));
    if (needs_parens(node2.right, node2, true)) {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.right, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.right, state));
    }
    return chunks;
  },
  /**
   * @param {import('estree').BlockStatement | import('estree').ClassBody} node
   * @param {import('./types').State} state
   */
  "BlockStatement|ClassBody": (node2, state) => {
    if (node2.body.length === 0)
      return [c("{}")];
    return [
      c(`{
${state.indent}	`),
      ...handle_body(node2.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  },
  /**
   * @param {import('estree').ClassDeclaration | import('estree').ClassExpression} node
   * @param {import('./types').State} state
   */
  "ClassDeclaration|ClassExpression": (node2, state) => {
    const chunks = [c("class ")];
    if (node2.id) {
      push_array2(chunks, handle(node2.id, state));
      chunks.push(c(" "));
    }
    if (node2.superClass) {
      chunks.push(c("extends "));
      push_array2(chunks, handle(node2.superClass, state));
      chunks.push(c(" "));
    }
    push_array2(chunks, handle(node2.body, state));
    return chunks;
  },
  /**
   * @param {import('estree').ForInStatement | import('estree').ForOfStatement} node
   * @param {import('./types').State} state
   */
  "ForInStatement|ForOfStatement": (node2, state) => {
    const chunks = [c(`for ${node2.type === "ForOfStatement" && node2.await ? "await " : ""}(`)];
    if (node2.left.type === "VariableDeclaration") {
      push_array2(chunks, handle_var_declaration(node2.left, state));
    } else {
      push_array2(chunks, handle(node2.left, state));
    }
    chunks.push(c(node2.type === "ForInStatement" ? ` in ` : ` of `));
    push_array2(chunks, handle(node2.right, state));
    chunks.push(c(") "));
    push_array2(chunks, handle(node2.body, state));
    return chunks;
  },
  /**
   * @param {import('estree').FunctionDeclaration | import('estree').FunctionExpression} node
   * @param {import('./types').State} state
   */
  "FunctionDeclaration|FunctionExpression": (node2, state) => {
    const chunks = [];
    if (node2.async)
      chunks.push(c("async "));
    chunks.push(c(node2.generator ? "function* " : "function "));
    if (node2.id)
      push_array2(chunks, handle(node2.id, state));
    chunks.push(c("("));
    const params = node2.params.map(
      (p) => handle(p, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
    const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array2(chunks, join(params, separator));
      chunks.push(c(`
${state.indent}`));
    } else {
      push_array2(chunks, join(params, separator));
    }
    chunks.push(c(") "));
    push_array2(chunks, handle(node2.body, state));
    return chunks;
  },
  /**
   * @param {import('estree').RestElement | import('estree').SpreadElement} node
   * @param {import('./types').State} state
   */
  "RestElement|SpreadElement": (node2, state) => {
    return [c("..."), ...handle(node2.argument, state)];
  }
};
var handlers = {
  ArrayExpression: shared["ArrayExpression|ArrayPattern"],
  ArrayPattern: shared["ArrayExpression|ArrayPattern"],
  ArrowFunctionExpression: (node2, state) => {
    const chunks = [];
    if (node2.async)
      chunks.push(c("async "));
    if (node2.params.length === 1 && node2.params[0].type === "Identifier") {
      push_array2(chunks, handle(node2.params[0], state));
    } else {
      const params = node2.params.map(
        (param) => handle(param, {
          ...state,
          indent: state.indent + "	"
        })
      );
      chunks.push(c("("));
      push_array2(chunks, join(params, c(", ")));
      chunks.push(c(")"));
    }
    chunks.push(c(" => "));
    if (node2.body.type === "ObjectExpression" || node2.body.type === "AssignmentExpression" && node2.body.left.type === "ObjectPattern") {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.body, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.body, state));
    }
    return chunks;
  },
  AssignmentExpression(node2, state) {
    return [...handle(node2.left, state), c(` ${node2.operator} `), ...handle(node2.right, state)];
  },
  AssignmentPattern(node2, state) {
    return [...handle(node2.left, state), c(` = `), ...handle(node2.right, state)];
  },
  AwaitExpression(node2, state) {
    if (node2.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node2.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        return [c("await ("), ...handle(node2.argument, state), c(")")];
      } else {
        return [c("await "), ...handle(node2.argument, state)];
      }
    }
    return [c("await")];
  },
  BinaryExpression: shared["BinaryExpression|LogicalExpression"],
  BlockStatement: shared["BlockStatement|ClassBody"],
  BreakStatement(node2, state) {
    return node2.label ? [c("break "), ...handle(node2.label, state), c(";")] : [c("break;")];
  },
  CallExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.callee, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.callee, state));
    }
    if (
      /** @type {import('estree').SimpleCallExpression} */
      node2.optional
    ) {
      chunks.push(c("?."));
    }
    let has_inline_comment = false;
    let arg_chunks = [];
    outer:
      for (const arg of node2.arguments) {
        const chunks2 = [];
        while (state.comments.length) {
          const comment = (
            /** @type {import('estree').Comment} */
            state.comments.shift()
          );
          if (comment.type === "Line") {
            has_inline_comment = true;
            break outer;
          }
          chunks2.push(c(comment.type === "Block" ? `/*${comment.value}*/ ` : `//${comment.value}`));
        }
        push_array2(chunks2, handle(arg, state));
        arg_chunks.push(chunks2);
      }
    const multiple_lines = has_inline_comment || arg_chunks.slice(0, -1).some(has_newline);
    if (multiple_lines) {
      const args = node2.arguments.map((arg, i) => {
        const chunks2 = handle(arg, {
          ...state,
          indent: `${state.indent}	`
        });
        if (i < node2.arguments.length - 1)
          chunks2.push(c(","));
        while (state.comments.length) {
          const comment = (
            /** @type {import('estree').Comment} */
            state.comments.shift()
          );
          chunks2.push(
            c(comment.type === "Block" ? ` /*${comment.value}*/ ` : ` //${comment.value}`)
          );
        }
        return chunks2;
      });
      chunks.push(c(`(
${state.indent}	`));
      push_array2(chunks, join(args, c(`
${state.indent}	`)));
      chunks.push(c(`
${state.indent})`));
    } else {
      chunks.push(c("("));
      push_array2(chunks, join(arg_chunks, c(", ")));
      chunks.push(c(")"));
    }
    return chunks;
  },
  ChainExpression(node2, state) {
    return handle(node2.expression, state);
  },
  ClassBody: shared["BlockStatement|ClassBody"],
  ClassDeclaration: shared["ClassDeclaration|ClassExpression"],
  ClassExpression: shared["ClassDeclaration|ClassExpression"],
  ConditionalExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      push_array2(chunks, handle(node2.test, state));
    } else {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.test, state));
      chunks.push(c(")"));
    }
    const child_state = { ...state, indent: state.indent + "	" };
    const consequent = handle(node2.consequent, child_state);
    const alternate = handle(node2.alternate, child_state);
    const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}? `));
      push_array2(chunks, consequent);
      chunks.push(c(`
${state.indent}: `));
      push_array2(chunks, alternate);
    } else {
      chunks.push(c(` ? `));
      push_array2(chunks, consequent);
      chunks.push(c(` : `));
      push_array2(chunks, alternate);
    }
    return chunks;
  },
  ContinueStatement(node2, state) {
    return node2.label ? [c("continue "), ...handle(node2.label, state), c(";")] : [c("continue;")];
  },
  DebuggerStatement(node2, state) {
    return [c("debugger", node2), c(";")];
  },
  DoWhileStatement(node2, state) {
    return [
      c("do "),
      ...handle(node2.body, state),
      c(" while ("),
      ...handle(node2.test, state),
      c(");")
    ];
  },
  EmptyStatement(node2, state) {
    return [c(";")];
  },
  ExportAllDeclaration(node2, state) {
    return [c(`export * from `), ...handle(node2.source, state), c(`;`)];
  },
  ExportDefaultDeclaration(node2, state) {
    const chunks = [c(`export default `), ...handle(node2.declaration, state)];
    if (node2.declaration.type !== "FunctionDeclaration") {
      chunks.push(c(";"));
    }
    return chunks;
  },
  ExportNamedDeclaration(node2, state) {
    const chunks = [c("export ")];
    if (node2.declaration) {
      push_array2(chunks, handle(node2.declaration, state));
    } else {
      const specifiers = node2.specifiers.map((specifier) => {
        const name8 = handle(specifier.local, state)[0];
        const as2 = handle(specifier.exported, state)[0];
        if (name8.content === as2.content) {
          return [name8];
        }
        return [name8, c(" as "), as2];
      });
      const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
      if (width > 80) {
        chunks.push(c("{\n	"));
        push_array2(chunks, join(specifiers, c(",\n	")));
        chunks.push(c("\n}"));
      } else {
        chunks.push(c("{ "));
        push_array2(chunks, join(specifiers, c(", ")));
        chunks.push(c(" }"));
      }
      if (node2.source) {
        chunks.push(c(" from "));
        push_array2(chunks, handle(node2.source, state));
      }
    }
    chunks.push(c(";"));
    return chunks;
  },
  ExpressionStatement(node2, state) {
    if (node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "ObjectPattern") {
      return [c("("), ...handle(node2.expression, state), c(");")];
    }
    return [...handle(node2.expression, state), c(";")];
  },
  ForStatement: (node2, state) => {
    const chunks = [c("for (")];
    if (node2.init) {
      if (node2.init.type === "VariableDeclaration") {
        push_array2(chunks, handle_var_declaration(node2.init, state));
      } else {
        push_array2(chunks, handle(node2.init, state));
      }
    }
    chunks.push(c("; "));
    if (node2.test)
      push_array2(chunks, handle(node2.test, state));
    chunks.push(c("; "));
    if (node2.update)
      push_array2(chunks, handle(node2.update, state));
    chunks.push(c(") "));
    push_array2(chunks, handle(node2.body, state));
    return chunks;
  },
  ForInStatement: shared["ForInStatement|ForOfStatement"],
  ForOfStatement: shared["ForInStatement|ForOfStatement"],
  FunctionDeclaration: shared["FunctionDeclaration|FunctionExpression"],
  FunctionExpression: shared["FunctionDeclaration|FunctionExpression"],
  Identifier(node2) {
    let name8 = node2.name;
    return [c(name8, node2)];
  },
  IfStatement(node2, state) {
    const chunks = [
      c("if ("),
      ...handle(node2.test, state),
      c(") "),
      ...handle(node2.consequent, state)
    ];
    if (node2.alternate) {
      chunks.push(c(" else "));
      push_array2(chunks, handle(node2.alternate, state));
    }
    return chunks;
  },
  ImportDeclaration(node2, state) {
    const chunks = [c("import ")];
    const { length } = node2.specifiers;
    const source = handle(node2.source, state);
    if (length > 0) {
      let i = 0;
      while (i < length) {
        if (i > 0) {
          chunks.push(c(", "));
        }
        const specifier = node2.specifiers[i];
        if (specifier.type === "ImportDefaultSpecifier") {
          chunks.push(c(specifier.local.name, specifier));
          i += 1;
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          chunks.push(c("* as " + specifier.local.name, specifier));
          i += 1;
        } else {
          break;
        }
      }
      if (i < length) {
        const specifiers = (
          /** @type {import('estree').ImportSpecifier[]} */
          node2.specifiers.slice(i).map((specifier) => {
            const name8 = handle(specifier.imported, state)[0];
            const as2 = handle(specifier.local, state)[0];
            if (name8.content === as2.content) {
              return [as2];
            }
            return [name8, c(" as "), as2];
          })
        );
        const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
        if (width > 80) {
          chunks.push(c(`{
	`));
          push_array2(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c(`{ `));
          push_array2(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
      }
      chunks.push(c(" from "));
    }
    push_array2(chunks, source);
    chunks.push(c(";"));
    return chunks;
  },
  ImportExpression(node2, state) {
    return [c("import("), ...handle(node2.source, state), c(")")];
  },
  LabeledStatement(node2, state) {
    return [...handle(node2.label, state), c(": "), ...handle(node2.body, state)];
  },
  Literal(node2, state) {
    if (typeof node2.value === "string") {
      return [
        // TODO do we need to handle weird unicode characters somehow?
        // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
        c(node2.raw || JSON.stringify(node2.value), node2)
      ];
    }
    return [c(node2.raw || String(node2.value), node2)];
  },
  LogicalExpression: shared["BinaryExpression|LogicalExpression"],
  MemberExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.object, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.object, state));
    }
    if (node2.computed) {
      if (node2.optional) {
        chunks.push(c("?."));
      }
      chunks.push(c("["));
      push_array2(chunks, handle(node2.property, state));
      chunks.push(c("]"));
    } else {
      chunks.push(c(node2.optional ? "?." : "."));
      push_array2(chunks, handle(node2.property, state));
    }
    return chunks;
  },
  MetaProperty(node2, state) {
    return [...handle(node2.meta, state), c("."), ...handle(node2.property, state)];
  },
  MethodDefinition(node2, state) {
    const chunks = [];
    if (node2.static) {
      chunks.push(c("static "));
    }
    if (node2.kind === "get" || node2.kind === "set") {
      chunks.push(c(node2.kind + " "));
    }
    if (node2.value.async) {
      chunks.push(c("async "));
    }
    if (node2.value.generator) {
      chunks.push(c("*"));
    }
    if (node2.computed) {
      chunks.push(c("["));
      push_array2(chunks, handle(node2.key, state));
      chunks.push(c("]"));
    } else {
      push_array2(chunks, handle(node2.key, state));
    }
    chunks.push(c("("));
    const { params } = node2.value;
    for (let i = 0; i < params.length; i += 1) {
      push_array2(chunks, handle(params[i], state));
      if (i < params.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(") "));
    push_array2(chunks, handle(node2.value.body, state));
    return chunks;
  },
  NewExpression(node2, state) {
    const chunks = [c("new ")];
    if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node2.callee)) {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.callee, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.callee, state));
    }
    const args = node2.arguments.map(
      (arg) => handle(arg, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
    chunks.push(c("("));
    push_array2(chunks, join(args, separator));
    chunks.push(c(")"));
    return chunks;
  },
  ObjectExpression(node2, state) {
    if (node2.properties.length === 0) {
      return [c("{}")];
    }
    let has_inline_comment = false;
    const chunks = [];
    const separator = c(", ");
    node2.properties.forEach((p, i) => {
      push_array2(
        chunks,
        handle(p, {
          ...state,
          indent: state.indent + "	"
        })
      );
      if (state.comments.length) {
        chunks.push(c(", "));
        while (state.comments.length) {
          const comment = (
            /** @type {import('estree').Comment} */
            state.comments.shift()
          );
          chunks.push(
            c(
              comment.type === "Block" ? `/*${comment.value}*/
${state.indent}	` : `//${comment.value}
${state.indent}	`
            )
          );
          if (comment.type === "Line") {
            has_inline_comment = true;
          }
        }
      } else {
        if (i < node2.properties.length - 1) {
          chunks.push(separator);
        }
      }
    });
    const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
    if (multiple_lines) {
      separator.content = `,
${state.indent}	`;
    }
    return [
      c(multiple_lines ? `{
${state.indent}	` : `{ `),
      ...chunks,
      c(multiple_lines ? `
${state.indent}}` : ` }`)
    ];
  },
  ObjectPattern(node2, state) {
    const chunks = [c("{ ")];
    for (let i = 0; i < node2.properties.length; i += 1) {
      push_array2(chunks, handle(node2.properties[i], state));
      if (i < node2.properties.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(" }"));
    return chunks;
  },
  // @ts-expect-error this isn't a real node type, but Acorn produces it
  ParenthesizedExpression(node2, state) {
    return handle(node2.expression, state);
  },
  PrivateIdentifier(node2, state) {
    const chunks = [c("#")];
    push_array2(chunks, [c(node2.name, node2)]);
    return chunks;
  },
  Program(node2, state) {
    return handle_body(node2.body, state);
  },
  Property(node2, state) {
    const value2 = handle(node2.value, state);
    if (node2.key === node2.value) {
      return value2;
    }
    if (!node2.computed && node2.value.type === "AssignmentPattern" && node2.value.left.type === "Identifier" && node2.key.type === "Identifier" && node2.value.left.name === node2.key.name) {
      return value2;
    }
    if (!node2.computed && node2.value.type === "Identifier" && (node2.key.type === "Identifier" && node2.key.name === value2[0].content || node2.key.type === "Literal" && node2.key.value === value2[0].content)) {
      return value2;
    }
    const key2 = handle(node2.key, state);
    if (node2.value.type === "FunctionExpression" && !node2.value.id) {
      const chunks = node2.kind !== "init" ? [c(`${node2.kind} `)] : [];
      if (node2.value.async) {
        chunks.push(c("async "));
      }
      if (node2.value.generator) {
        chunks.push(c("*"));
      }
      push_array2(chunks, node2.computed ? [c("["), ...key2, c("]")] : key2);
      chunks.push(c("("));
      push_array2(
        chunks,
        join(
          node2.value.params.map((param) => handle(param, state)),
          c(", ")
        )
      );
      chunks.push(c(") "));
      push_array2(chunks, handle(node2.value.body, state));
      return chunks;
    }
    if (node2.computed) {
      return [c("["), ...key2, c("]: "), ...value2];
    }
    return [...key2, c(": "), ...value2];
  },
  PropertyDefinition(node2, state) {
    const chunks = [];
    if (node2.static) {
      chunks.push(c("static "));
    }
    if (node2.computed) {
      chunks.push(c("["), ...handle(node2.key, state), c("]"));
    } else {
      chunks.push(...handle(node2.key, state));
    }
    if (node2.value) {
      chunks.push(c(" = "));
      chunks.push(...handle(node2.value, state));
    }
    chunks.push(c(";"));
    return chunks;
  },
  RestElement: shared["RestElement|SpreadElement"],
  ReturnStatement(node2, state) {
    if (node2.argument) {
      const contains_comment = node2.argument.leadingComments && node2.argument.leadingComments.some(
        (comment) => comment.has_trailing_newline
      );
      return [
        c(contains_comment ? "return (" : "return "),
        ...handle(node2.argument, state),
        c(contains_comment ? ");" : ";")
      ];
    } else {
      return [c("return;")];
    }
  },
  SequenceExpression(node2, state) {
    const expressions = node2.expressions.map((e) => handle(e, state));
    return [c("("), ...join(expressions, c(", ")), c(")")];
  },
  SpreadElement: shared["RestElement|SpreadElement"],
  StaticBlock(node2, state) {
    return [
      c("static "),
      c(`{
${state.indent}	`),
      ...handle_body(node2.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  },
  Super(node2, state) {
    return [c("super", node2)];
  },
  SwitchStatement(node2, state) {
    const chunks = [c("switch ("), ...handle(node2.discriminant, state), c(") {")];
    node2.cases.forEach((block2) => {
      if (block2.test) {
        chunks.push(c(`
${state.indent}	case `));
        push_array2(chunks, handle(block2.test, { ...state, indent: `${state.indent}	` }));
        chunks.push(c(":"));
      } else {
        chunks.push(c(`
${state.indent}	default:`));
      }
      block2.consequent.forEach((statement) => {
        chunks.push(c(`
${state.indent}		`));
        push_array2(chunks, handle(statement, { ...state, indent: `${state.indent}		` }));
      });
    });
    chunks.push(c(`
${state.indent}}`));
    return chunks;
  },
  TaggedTemplateExpression(node2, state) {
    return handle(node2.tag, state).concat(handle(node2.quasi, state));
  },
  TemplateLiteral(node2, state) {
    const chunks = [c("`")];
    const { quasis, expressions } = node2;
    for (let i = 0; i < expressions.length; i++) {
      chunks.push(c(quasis[i].value.raw), c("${"));
      push_array2(chunks, handle(expressions[i], state));
      chunks.push(c("}"));
    }
    chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
    return chunks;
  },
  ThisExpression(node2, state) {
    return [c("this", node2)];
  },
  ThrowStatement(node2, state) {
    return [c("throw "), ...handle(node2.argument, state), c(";")];
  },
  TryStatement(node2, state) {
    const chunks = [c("try "), ...handle(node2.block, state)];
    if (node2.handler) {
      if (node2.handler.param) {
        chunks.push(c(" catch("));
        push_array2(chunks, handle(node2.handler.param, state));
        chunks.push(c(") "));
      } else {
        chunks.push(c(" catch "));
      }
      push_array2(chunks, handle(node2.handler.body, state));
    }
    if (node2.finalizer) {
      chunks.push(c(" finally "));
      push_array2(chunks, handle(node2.finalizer, state));
    }
    return chunks;
  },
  UnaryExpression(node2, state) {
    const chunks = [c(node2.operator)];
    if (node2.operator.length > 1) {
      chunks.push(c(" "));
    }
    if (EXPRESSIONS_PRECEDENCE[node2.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      chunks.push(c("("));
      push_array2(chunks, handle(node2.argument, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node2.argument, state));
    }
    return chunks;
  },
  UpdateExpression(node2, state) {
    return node2.prefix ? [c(node2.operator), ...handle(node2.argument, state)] : [...handle(node2.argument, state), c(node2.operator)];
  },
  VariableDeclaration(node2, state) {
    return handle_var_declaration(node2, state).concat(c(";"));
  },
  VariableDeclarator(node2, state) {
    if (node2.init) {
      return [...handle(node2.id, state), c(" = "), ...handle(node2.init, state)];
    } else {
      return handle(node2.id, state);
    }
  },
  WhileStatement(node2, state) {
    return [c("while ("), ...handle(node2.test, state), c(") "), ...handle(node2.body, state)];
  },
  WithStatement(node2, state) {
    return [c("with ("), ...handle(node2.object, state), c(") "), ...handle(node2.body, state)];
  },
  YieldExpression(node2, state) {
    if (node2.argument) {
      return [c(node2.delegate ? `yield* ` : `yield `), ...handle(node2.argument, state)];
    }
    return [c(node2.delegate ? `yield*` : `yield`)];
  }
};

// ../../node_modules/.pnpm/esrap@1.0.2/node_modules/esrap/src/index.js
var import_sourcemap_codec2 = __toESM(require_sourcemap_codec_umd(), 1);
var btoa2 = () => {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa2 = (str) => window.btoa(unescape(encodeURIComponent(str)));
} else if (typeof Buffer === "function") {
  btoa2 = (str) => Buffer.from(str, "utf-8").toString("base64");
}
function print(node2, opts = {}) {
  if (Array.isArray(node2)) {
    return print(
      {
        type: "Program",
        body: node2,
        sourceType: "module"
      },
      opts
    );
  }
  const chunks = handle(node2, {
    indent: "",
    comments: []
  });
  let code = "";
  let current_column = 0;
  let mappings = [];
  let current_line = [];
  for (let i = 0; i < chunks.length; i += 1) {
    const chunk = chunks[i];
    code += chunk.content;
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.start.line - 1,
        chunk.loc.start.column
      ]);
    }
    for (let i2 = 0; i2 < chunk.content.length; i2 += 1) {
      if (chunk.content[i2] === "\n") {
        mappings.push(current_line);
        current_line = [];
        current_column = 0;
      } else {
        current_column += 1;
      }
    }
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.end.line - 1,
        chunk.loc.end.column
      ]);
    }
  }
  mappings.push(current_line);
  const map = {
    version: 3,
    /** @type {string[]} */
    names: [],
    sources: [opts.sourceMapSource || null],
    sourcesContent: [opts.sourceMapContent || null],
    mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? (0, import_sourcemap_codec2.encode)(mappings) : mappings
  };
  Object.defineProperties(map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
      }
    }
  });
  return {
    code,
    map
  };
}

// src/compiler/phases/3-transform/utils.ts
function escape_html(s, attr) {
  if (typeof s !== "string")
    return s;
  const delimiter = attr ? '"' : "<";
  const escaped_delimiter = attr ? "&quot;" : "&lt;";
  let i_delimiter = s.indexOf(delimiter);
  let i_ampersand = s.indexOf("&");
  if (i_delimiter < 0 && i_ampersand < 0)
    return s;
  let left = 0, out = "";
  while (i_delimiter >= 0 && i_ampersand >= 0) {
    if (i_delimiter < i_ampersand) {
      if (left < i_delimiter)
        out += s.substring(left, i_delimiter);
      out += escaped_delimiter;
      left = i_delimiter + 1;
      i_delimiter = s.indexOf(delimiter, left);
    } else {
      if (left < i_ampersand)
        out += s.substring(left, i_ampersand);
      out += "&amp;";
      left = i_ampersand + 1;
      i_ampersand = s.indexOf("&", left);
    }
  }
  if (i_delimiter >= 0) {
    do {
      if (left < i_delimiter)
        out += s.substring(left, i_delimiter);
      out += escaped_delimiter;
      left = i_delimiter + 1;
      i_delimiter = s.indexOf(delimiter, left);
    } while (i_delimiter >= 0);
  } else {
    while (i_ampersand >= 0) {
      if (left < i_ampersand)
        out += s.substring(left, i_ampersand);
      out += "&amp;";
      left = i_ampersand + 1;
      i_ampersand = s.indexOf("&", left);
    }
  }
  return left < s.length ? out + s.substring(left) : out;
}
var svg_elements = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hatch",
  "hatchpath",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "unknown",
  "use",
  "view",
  "vkern"
];
function is_svg_element(name8) {
  return svg_elements.includes(name8);
}
function is_delegated_function(node2) {
  if (node2.type === "ArrowFunctionExpression" || node2.type === "FunctionExpression" || node2.type === "FunctionDeclaration") {
    return node2.metadata?.delegated;
  }
  return false;
}
function clean_nodes(parent, nodes, path, namespace = "html", preserve_whitespace, preserve_noscript) {
  const hoisted = [];
  const regular = [];
  for (const node2 of nodes) {
    if (node2.type === "Comment") {
      continue;
    }
    if (node2.type === "RegularElement" && node2.name === "noscript" && !preserve_noscript) {
      continue;
    }
    if (node2.type === "ConstTag" || node2.type === "DebugTag" || node2.type === "Body" || node2.type === "Window" || node2.type === "Document" || node2.type === "Head") {
      hoisted.push(node2);
    } else {
      regular.push(node2);
    }
  }
  if (preserve_whitespace) {
    return { hoisted, trimmed: regular };
  }
  let first, last;
  while ((first = regular[0]) && first.type === "Text" && !regex_not_whitespace.test(first.data)) {
    regular.shift();
  }
  if (first?.type === "Text") {
    first.raw = first.raw.replace(regex_starts_with_whitespaces, "");
    first.data = first.data.replace(regex_starts_with_whitespaces, "");
  }
  while ((last = regular.at(-1)) && last.type === "Text" && !regex_not_whitespace.test(last.data)) {
    regular.pop();
  }
  if (last?.type === "Text") {
    last.raw = last.raw.replace(regex_ends_with_whitespaces, "");
    last.data = last.data.replace(regex_ends_with_whitespaces, "");
  }
  const can_remove_entirely = namespace === "svg" && (parent.type !== "RegularElement" || parent.name !== "text") && !path.some((n2) => n2.type === "RegularElement" && n2.name === "text") || parent.type === "RegularElement" && // TODO others?
  (parent.name === "select" || parent.name === "tr" || parent.name === "table" || parent.name === "tbody" || parent.name === "thead" || parent.name === "tfoot" || parent.name === "colgroup" || parent.name === "datalist");
  const trimmed = [];
  let last_text = null;
  for (const node2 of regular) {
    if (node2.type === "Text") {
      node2.data = node2.data.replace(regex_whitespaces_strict, " ");
      node2.raw = node2.raw.replace(regex_whitespaces_strict, " ");
      if ((last_text === null || !regex_ends_with_whitespaces.test(last_text.data)) && (!can_remove_entirely || node2.data !== " ")) {
        trimmed.push(node2);
      }
      last_text = node2;
    } else {
      last_text = null;
      trimmed.push(node2);
    }
  }
  return { hoisted, trimmed };
}

// src/compiler/phases/3-transform/ssr.ts
function t_string(value2) {
  return {
    type: "string",
    value: value2
  };
}
function t_expression(value2) {
  return {
    type: "expression",
    value: value2
  };
}
function t_statement(value2) {
  return {
    type: "statement",
    value: value2
  };
}
function serialize_anchor(state) {
  const id2 = state.scope.root.unique("anchor");
  return [const_builder(id2, call("$.create_anchor", id("$$payload"))), id2];
}
function serialize_template(template2) {
  let quasis = [];
  let expressions = [];
  const statements = [];
  const flush_payload = () => {
    statements.push(
      stmt(
        assignment(
          "+=",
          member(id("$$payload"), id("out")),
          template(quasis, expressions)
        )
      )
    );
    quasis = [];
    expressions = [];
  };
  for (let i = 0; i < template2.length; i++) {
    const template_item = template2[i];
    if (template_item.type === "statement") {
      if (quasis.length !== 0) {
        flush_payload();
      }
      statements.push(template_item.value);
    } else {
      if (quasis.length === 0) {
        quasis.push(quasi("", false));
      }
      if (template_item.type === "string") {
        quasis.at(-1).value.raw += sanitize_template_string(template_item.value);
      } else if (template_item.type === "expression") {
        const value2 = template_item.value;
        if (value2.type === "TemplateLiteral") {
          quasis.at(-1).value.raw += sanitize_template_string(value2.quasis[0].value.raw);
          quasis.push(...value2.quasis.slice(1));
          expressions.push(...value2.expressions);
          continue;
        }
        expressions.push(value2);
        quasis.push(quasi("", i + 1 === template2.length || template2[i + 1].type === "statement"));
      }
    }
  }
  if (quasis.length !== 0) {
    flush_payload();
  }
  return statements;
}
function sanitize_template_string(str) {
  return str.replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
function process_children(nodes, { visit, state }) {
  let sequence2 = [];
  function flush_sequence(sequence3, final) {
    if (sequence3.length === 1) {
      const node2 = sequence3[0];
      if (node2.type === "Text") {
        state.template.push(t_string(escape_html(node2.raw)));
        return;
      }
      const expression = node2.metadata.skip_escape ? visit(node2.expression) : call("$.escape", visit(node2.expression));
      state.template.push(t_expression(expression));
      return;
    }
    const quasis = [];
    const expressions = [];
    quasis.push(quasi("", false));
    for (let i = 0; i < sequence3.length; i++) {
      const node2 = sequence3[i];
      if (node2.type === "Text") {
        quasis.at(-1).value.raw = node2.raw.replace(/\s{2,}/g, " ");
      } else {
        if (node2.metadata.skip_escape) {
          expressions.push(visit(node2.expression));
        } else {
          expressions.push(call("$.escape", visit(node2.expression)));
        }
        quasis.push(quasi("", i + 1 === sequence3.length));
      }
    }
    state.template.push(t_expression(template(quasis, expressions)));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node2 = nodes[i];
    if (node2.type === "Text" || node2.type === "MustacheTag") {
      sequence2.push(node2);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2, false);
        sequence2 = [];
      }
      visit(node2, {
        ...state
      });
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2, true);
  }
}
function create_block(parent, nodes, context) {
  const body = [];
  const { hoisted, trimmed } = clean_nodes(
    parent,
    nodes,
    context.path,
    context.state.metadata.namespace,
    context.state.preserve_whitespace,
    true
  );
  if (hoisted.length === 0 && (trimmed.length === 0 || !context.state.analysis.preserve_comments && trimmed.every((node2) => node2.type === "Comment"))) {
    return [];
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_slot_template = trimmed.length === 1 && trimmed[0].type === "SlotTemplate";
  const state = {
    ...context.state,
    init: [],
    template: [],
    metadata: {
      namespace: context.state.metadata.namespace
    }
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_single_element) {
    const element = trimmed[0];
    context.visit(element, {
      ...state
    });
    body.push(...state.init);
    body.push(...serialize_template(state.template));
  } else if (is_single_slot_template) {
    const element = trimmed[0];
    context.visit(element, state);
    body.push(...state.init);
  } else {
    process_children(trimmed, {
      ...context,
      state
    });
    if (state.template.length > 0) {
      body.push(...state.init);
      body.push(...serialize_template(state.template));
    } else {
      body.push(...state.init);
    }
  }
  return body;
}
function create_state_declarators(declarator2, scope, value2) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, value2)];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value2),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path) => {
      const value3 = path.expression(id(tmp));
      return declarator(path.node, value3);
    })
  ];
}
function serialize_get_binding(node2, state) {
  const binding = state.scope.get(node2.name);
  if (binding === null || node2 === binding.node) {
    return node2;
  }
  if (binding.kind === "store_sub") {
    const store_id = id(node2.name.slice(1));
    return call("$.store_get", serialize_get_binding(store_id, state));
  }
  if (binding.expression) {
    return binding.expression;
  }
  return node2;
}
function get_assignment_value(node2, { state, visit }) {
  if (node2.left.type === "Identifier") {
    const operator = node2.operator;
    return operator === "=" ? visit(node2.right) : (
      // turn something like x += 1 into x = x + 1
      binary(
        operator.slice(0, -1),
        serialize_get_binding(node2.left, state),
        visit(node2.right)
      )
    );
  } else {
    return visit(node2.right);
  }
}
function is_store_name(name8) {
  return name8[0] === "$" && /[A-Za-z_]/.test(name8[1]);
}
function serialize_set_binding(node2, context, fallback) {
  const { state, visit } = context;
  if (node2.left.type === "ArrayPattern" || node2.left.type === "ObjectPattern" || node2.left.type === "RestElement") {
    const tmp_id = context.state.scope.generate("tmp");
    const original_assignments = [];
    const assignments = [];
    const paths = extract_paths(node2.left);
    for (const path of paths) {
      const value3 = path.expression(id(tmp_id));
      const assignment2 = assignment("=", path.node, value3);
      original_assignments.push(assignment2);
      assignments.push(serialize_set_binding(assignment2, context, () => assignment2));
    }
    if (assignments.every((assignment2, i) => assignment2 === original_assignments[i])) {
      return fallback();
    }
    return call(
      thunk(
        block([
          const_builder(tmp_id, visit(node2.right)),
          stmt(sequence(assignments)),
          return_builder(id(tmp_id))
        ])
      )
    );
  }
  if (node2.left.type !== "Identifier" && node2.left.type !== "MemberExpression") {
    error(node2, "INTERNAL", `Unexpected assignment type ${node2.left.type}`);
  }
  let left = node2.left;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (left.type !== "Identifier") {
    return fallback();
  }
  const is_store = is_store_name(left.name);
  const left_name = is_store ? left.name.slice(1) : left.name;
  const binding = state.scope.get(left_name);
  if (!binding)
    return fallback();
  if (binding.mutation !== null) {
    return binding.mutation(node2, context);
  }
  if (binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "each" && binding.kind !== "legacy_reactive" && !is_store) {
    return fallback();
  }
  const value2 = get_assignment_value(node2, { state, visit });
  if (left === node2.left) {
    if (is_store) {
      return call("$.store_set", id(left_name), visit(node2.right));
    }
    return fallback();
  } else if (is_store) {
    return call(
      "$.mutate_store",
      id(left_name),
      assignment(node2.operator, visit(node2.left), value2)
    );
  }
  return fallback();
}
var global_visitors = {
  Identifier(node2, { path, state }) {
    if (is_reference(node2, path.at(-1))) {
      return serialize_get_binding(node2, state);
    }
  },
  AssignmentExpression(node2, context) {
    return serialize_set_binding(node2, context, context.next);
  },
  UpdateExpression(node2, context) {
    const { state, next: next2, visit } = context;
    const argument = node2.argument;
    if (argument.type === "Identifier") {
      const binding = state.scope.get(argument.name);
      const is_store = binding?.kind === "store_sub";
      const name8 = is_store ? argument.name.slice(1) : argument.name;
      if (is_store) {
        let fn2 = node2.operator === "++" ? "$.increment" : "$.decrement";
        if (node2.prefix)
          fn2 += "_pre";
        if (is_store) {
          fn2 += "_store";
          return call(fn2, serialize_get_binding(id(name8), state), call("$" + name8));
        } else {
          return call(fn2, id(name8));
        }
      } else {
        return next2();
      }
    }
    return next2();
  }
};
var javascript_visitors = {
  Program(node2, { visit }) {
    return {
      ...node2,
      body: node2.body.map((node3) => visit(node3))
    };
  },
  BlockStatement(node2, { visit }) {
    return {
      ...node2,
      body: node2.body.map((node3) => visit(node3))
    };
  }
};
var javascript_visitors_runes = {
  VariableDeclaration(node2, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node2.declarations) {
      const rune = get_rune(declarator2.init, state.scope);
      if (!rune) {
        declarations.push(visit(declarator2));
        continue;
      }
      if (rune === "$props") {
        declarations.push(declarator(declarator2.id, id("$$props")));
        continue;
      }
      const args = declarator2.init.arguments;
      const value2 = args.length === 0 ? id("undefined") : visit(args[0]);
      if (declarator2.id.type === "Identifier") {
        declarations.push(declarator(declarator2.id, value2));
        continue;
      }
      if (rune === "$derived") {
        declarations.push(declarator(visit(declarator2.id), value2));
        continue;
      }
      declarations.push(...create_state_declarators(declarator2, state.scope, value2));
    }
    return {
      ...node2,
      declarations
    };
  },
  ExpressionStatement(node2, context) {
    const expression = node2.expression;
    if (expression.type === "CallExpression") {
      const callee = expression.callee;
      if (callee.type === "Identifier" && callee.name === "$effect") {
        return empty2;
      }
      if (callee.type === "MemberExpression" && callee.object.type === "Identifier" && callee.object.name === "$effect") {
        return empty2;
      }
    }
    context.next();
  }
};
function serialize_attribute_value(attribute_value, context) {
  if (attribute_value === true) {
    return true_instance;
  }
  if (attribute_value.length === 0) {
    return literal2("");
  }
  if (attribute_value.length === 1) {
    const value2 = attribute_value[0];
    if (value2.type === "Text") {
      return literal2(escape_html(value2.data, true));
    } else {
      return context.visit(value2.expression);
    }
  }
  const quasis = [];
  const expressions = [];
  if (attribute_value[0].type !== "Text") {
    quasis.push(quasi("", false));
  }
  let i = 0;
  for (const node2 of attribute_value) {
    i++;
    if (node2.type === "Text") {
      quasis.push(quasi(node2.raw, i === attribute_value.length));
    } else {
      expressions.push(context.visit(node2.expression));
      if (i === attribute_value.length) {
        quasis.push(quasi("", true));
      }
    }
  }
  return template(quasis, expressions);
}
function serialize_element_spread_attributes(attributes2, context) {
  let is_reactive2 = false;
  const values = [];
  for (const attribute of attributes2) {
    if (attribute.type === "Attribute") {
      let name8 = attribute.name.toLowerCase();
      if (name8 !== "class" && AttributeAliases.has(name8)) {
        name8 = AttributeAliases.get(name8);
      }
      const value2 = serialize_attribute_value(attribute.value, context);
      values.push(object([prop("init", literal2(name8), value2)]));
    } else {
      values.push(context.visit(attribute));
    }
    if (!is_reactive2) {
      is_reactive2 = context.state.analysis.dynamic_nodes.has(attribute);
    }
  }
  context.state.template.push(t_expression(call("$.spread_attributes", array(values))));
  return is_reactive2;
}
function serialize_style_directives(style_directives, context, is_attributes_reactive) {
  if (style_directives.length > 0) {
  }
}
function serialize_class_directives(class_directives, context, attributes2, is_attributes_reactive) {
  if (class_directives.length > 0) {
  }
}
function serialize_inline_component(node2, component_name, context) {
  const props = [];
  const spreads = [];
  const default_lets = [];
  const children = {};
  const events = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "LetDirective") {
      default_lets.push(context.visit(attribute));
    } else if (attribute.type === "OnDirective") {
    } else if (attribute.type === "Spread") {
      spreads.push(context.visit(attribute));
    } else if (attribute.type === "Attribute") {
      if (attribute.name === "slot")
        continue;
      const value2 = serialize_attribute_value(attribute.value, context);
      props.push(prop("init", literal2(attribute.name), value2));
    } else if (attribute.type === "BindDirective") {
      props.push(
        prop("init", literal2(attribute.name), context.visit(attribute.expression))
      );
    }
  }
  for (const child of node2.fragment.nodes) {
    let slot_name = "default";
    if (is_element_node(child)) {
      const attribute = child.attributes.find(
        (attribute2) => attribute2.type === "Attribute" && attribute2.name === "slot"
      );
      if (attribute !== void 0) {
        slot_name = attribute.value[0].data;
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  const serialized_slots = [];
  for (const slot_name of Object.keys(children)) {
    const body = create_block(node2, children[slot_name], context);
    if (body.length === 0)
      continue;
    const slot = prop(
      "init",
      literal2(slot_name),
      arrow(
        [id("$$payload"), id("$$slotProps")],
        block([...slot_name === "default" ? default_lets : [], ...body])
      )
    );
    serialized_slots.push(slot);
  }
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", array([object(props), ...spreads]));
  const events_expression = object(
    Object.keys(events).map(
      (name8) => prop("init", id(name8), events[name8].length > 1 ? array(events[name8]) : events[name8][0])
    )
  );
  return call(
    component_name,
    id("$$payload"),
    props_expression,
    events_expression,
    object(serialized_slots)
  );
}
function is_text_attribute2(attribute) {
  return attribute.value !== true && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
var javascript_visitors_legacy = {
  VariableDeclaration(node2, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node2.declarations) {
      const bindings2 = state.scope.get_bindings(declarator2);
      const has_state = bindings2.some((binding) => binding.kind === "state");
      const has_props = bindings2.some((binding) => binding.kind === "prop");
      if (!has_state && !has_props) {
        declarations.push(visit(declarator2));
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(declarator(id(tmp), visit(declarator2.init)));
          for (const path of paths) {
            const value2 = path.expression(id(tmp));
            const name8 = path.node.name;
            const prop3 = member(id("$$props"), literal2(name8), true);
            declarations.push(
              declarator(
                path.node,
                conditional(binary("!==", prop3, id("undefined")), prop3, value2)
              )
            );
          }
          continue;
        }
        const prop2 = member(id("$$props"), literal2(declarator2.id.name), true);
        let init2;
        if (declarator2.init) {
          init2 = conditional(
            binary("!==", prop2, id("undefined")),
            prop2,
            visit(declarator2.init)
          );
        } else {
          init2 = prop2;
        }
        declarations.push(declarator(declarator2.id, init2));
        continue;
      }
      declarations.push(
        ...create_state_declarators(
          declarator2,
          state.scope,
          declarator2.init && visit(declarator2.init)
        )
      );
    }
    return {
      ...node2,
      declarations
    };
  },
  LabeledStatement(node2, context) {
    if (context.path.length > 1)
      return;
    if (node2.label.name !== "$")
      return;
    let serialized = context.visit(node2.body);
    let reactive_statement = empty2;
    if (serialized.type === "ExpressionStatement" && serialized.expression.type === "AssignmentExpression") {
      if (serialized.expression.left.type === "Identifier") {
        const name8 = serialized.expression.left.name;
        const binding = context.state.scope.get(name8);
        if (binding !== null && binding.kind === "legacy_reactive") {
          reactive_statement = let_builder(serialized.expression.left);
        }
      }
    }
    context.state.legacy_reactive_statements.set(node2, stmt(serialized));
    return reactive_statement;
  },
  BreakStatement(node2, context) {
    if (!node2.label || node2.label.name !== "$")
      return;
    const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
    if (in_reactive_statement) {
      return return_builder();
    }
  }
};
var RegularElement = (node2, context) => {
  if (context.state.metadata.namespace === void 0) {
    if (is_svg_element(node2.name)) {
      context.state.metadata.namespace = "svg";
    } else {
      context.state.metadata.namespace = "html";
    }
  }
  context.state.template.push(t_string(`<${node2.name}`));
  const attributes2 = [];
  const class_directives = [];
  const style_directives = [];
  const lets = [];
  let has_spread = false;
  for (const attribute of node2.attributes) {
    if (attribute.type === "Attribute") {
      attributes2.push(attribute);
    } else if (attribute.type === "Spread") {
      attributes2.push(attribute);
      has_spread = true;
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
      lets.push(context.visit(attribute));
    } else {
      context.visit(attribute);
    }
  }
  context.state.init.push(...lets);
  let is_attributes_reactive = false;
  if (has_spread) {
    is_attributes_reactive = serialize_element_spread_attributes(attributes2, context);
  } else {
    for (const attribute of attributes2) {
      if (attribute.value === true || is_text_attribute2(attribute)) {
        const name9 = attribute.name.toLowerCase();
        const literal_value = serialize_attribute_value(attribute.value, context).value;
        if (name9 !== "class" || literal_value) {
          context.state.template.push(
            t_string(
              ` ${attribute.name}${DOMBooleanAttributes.has(name9) && literal_value === true ? "" : `="${literal_value === true ? "" : escape_html(String(literal_value), true)}"`}`
            )
          );
          continue;
        }
      }
      const is_reactive2 = context.state.analysis.dynamic_nodes.has(attribute);
      const name8 = attribute.name.toLowerCase();
      const aliased_name = AttributeAliases.get(name8) || name8;
      const is_boolean = DOMBooleanAttributes.has(aliased_name);
      const value2 = serialize_attribute_value(attribute.value, context);
      context.state.template.push(
        t_expression(
          call(
            "$.attr",
            literal2(aliased_name === "className" ? "class" : aliased_name),
            value2,
            literal2(is_boolean)
          )
        )
      );
      if (is_reactive2) {
        is_attributes_reactive = true;
      }
    }
  }
  serialize_class_directives(class_directives, context, attributes2, is_attributes_reactive);
  serialize_style_directives(style_directives, context, is_attributes_reactive);
  context.state.template.push(t_string(">"));
  const state = {
    ...context.state,
    preserve_whitespace: context.state.preserve_whitespace || node2.name === "pre" || node2.name === "textarea"
  };
  const { hoisted, trimmed } = clean_nodes(
    node2,
    node2.fragment.nodes,
    context.path,
    context.state.metadata.namespace,
    state.preserve_whitespace,
    true
  );
  for (const node3 of hoisted) {
    context.visit(node3, state);
  }
  process_children(trimmed, context);
  if (!VoidElements.has(node2.name)) {
    context.state.template.push(t_string(`</${node2.name}>`));
  }
};
var DynamicElement = (node2, context) => {
};
var template_visitors = {
  Fragment(node2, context) {
    const body = create_block(node2, node2.nodes, context);
    return block(body);
  },
  Template(node2, context) {
    return {
      type: "BlockStatement",
      body: create_block(node2, node2.body, context)
    };
  },
  RawMustacheTag(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const raw = context.visit(node2.expression);
    context.state.template.push(t_expression(raw));
    state.template.push(t_expression(id2));
  },
  ConstTag(node2, { state, visit }) {
    const pattern = visit(node2.expression.left);
    const init2 = visit(node2.expression.right);
    state.init.push(declaration("const", pattern, init2));
  },
  DebugTag(node2, { state, next: next2 }) {
    error(node2, "TODO", node2.type);
  },
  AnimateDirective(node2, { state, next: next2 }) {
    error(node2, "TODO", node2.type);
  },
  ClassDirective(node2, { state, next: next2 }) {
    error(node2, "INTERNAL", "Node should have been handled elsewhere");
  },
  StyleDirective(node2, { state, next: next2 }) {
    error(node2, "INTERNAL", "Node should have been handled elsewhere");
  },
  TransitionDirective(node2, { state, next: next2 }) {
    error(node2, "TODO", node2.type);
  },
  Body(node2, { state, next: next2 }) {
    next2({
      ...state
    });
  },
  RegularElement,
  DynamicElement,
  EachBlock(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const each_node_meta = node2.metadata;
    const collection = context.visit(node2.expression);
    const item = id(each_node_meta.item_name);
    const index = each_node_meta.contains_group_binding || !node2.index ? each_node_meta.index : id(node2.index);
    const children = node2.body.nodes;
    const [each_dec, each_id] = serialize_anchor(state);
    const mustache_tag = {
      type: "MustacheTag",
      expression: each_id,
      metadata: {
        skip_escape: true,
        contains_call_expression: false
      },
      parent: node2
    };
    const { hoisted, trimmed } = clean_nodes(
      node2,
      children,
      context.path,
      state.metadata.namespace,
      state.preserve_whitespace,
      true
    );
    trimmed.unshift(mustache_tag);
    trimmed.push(mustache_tag);
    const array_id = state.scope.root.unique("each_array");
    state.init.push(
      const_builder(
        array_id,
        conditional(
          collection,
          call("Array.from", collection),
          call("Array.isArray", collection)
        )
      )
    );
    const each = [const_builder(item, member(array_id, index, true))];
    if (node2.context.type !== "Identifier") {
      each.push(const_builder(node2.context, item));
    }
    if (index.name !== node2.index && node2.index != null) {
      each.push(let_builder(node2.index, index));
    }
    each.push(each_dec, ...create_block(node2, [...hoisted, ...trimmed], context));
    state.template.push(
      t_statement(
        for_builder(
          let_builder(index, literal2(0)),
          binary("<", index, member(array_id, id("length"))),
          update("++", index, false),
          block(each)
        )
      )
    );
    state.template.push(t_expression(id2));
  },
  IfBlock(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const consequent = create_block(node2, node2.consequent.nodes, context);
    state.template.push(
      t_statement(
        if_builder(
          context.visit(node2.test),
          block(consequent),
          node2.alternate ? context.visit(node2.alternate) : void 0
        )
      )
    );
    state.template.push(t_expression(id2));
  },
  AwaitBlock(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    state.template.push(
      t_statement(
        stmt(
          call(
            "$.await",
            context.visit(node2.expression),
            thunk(node2.pending ? context.visit(node2.pending) : block([])),
            arrow(
              node2.value ? [context.visit(node2.value)] : [],
              node2.then ? context.visit(node2.then) : block([])
            ),
            arrow(
              node2.error ? [context.visit(node2.error)] : [],
              node2.catch ? context.visit(node2.catch) : block([])
            )
          )
        )
      )
    );
    state.template.push(t_expression(id2));
  },
  KeyBlock(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const body = create_block(node2, node2.fragment.nodes, context);
    state.template.push(t_statement(block(body)));
    state.template.push(t_expression(id2));
  },
  OnDirective(node2, { state, visit }) {
  },
  UseDirective(node2, { state, next: next2, visit }) {
  },
  BindDirective(node2, context) {
  },
  InlineComponent(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const call2 = serialize_inline_component(node2, node2.name, context);
    state.template.push(t_statement(stmt(call2)));
    state.template.push(t_expression(id2));
  },
  SelfElement(node2, context) {
  },
  DynamicComponent(node2, context) {
  },
  Attribute(node2, context) {
    error(node2, "INTERNAL", `${node2.type} should be handled in parent node`);
  },
  LetDirective(node2, { state, path }) {
    const parent = path.at(-1);
    if (parent === void 0 || parent.type !== "InlineComponent" && parent.type !== "RegularElement" && parent.type !== "SlotTemplate") {
      error(node2, "INTERNAL", "let directive at invalid position");
    }
    if (node2.expression && node2.expression.type !== "Identifier") {
      const name8 = state.scope.generate(node2.name);
      const bindings2 = state.scope.get_bindings(node2);
      for (const binding of bindings2) {
        binding.expression = member(id(name8), id(binding.node.name));
      }
      return const_builder(
        name8,
        call(
          thunk(
            block([
              let_builder(
                node2.expression.type === "ObjectExpression" ? (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  object_pattern(node2.expression.properties)
                ) : (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  array_pattern(node2.expression.elements)
                ),
                member(id("$$slotProps"), id(node2.name))
              ),
              return_builder(object(bindings2.map((binding) => init(binding.node.name, binding.node))))
            ])
          )
        )
      );
    } else {
      const name8 = node2.expression === null ? node2.name : node2.expression.name;
      return const_builder(name8, member(id("$$slotProps"), id(node2.name)));
    }
  },
  AttributeShorthand(node2) {
    error(node2, "INTERNAL", `${node2.type} should be handled in parent node`);
  },
  Spread(node2, { visit }) {
    return visit(node2.expression);
  },
  MustacheTag(node2) {
    error(node2, "INTERNAL", `${node2.type} should be handled in parent node`);
  },
  SlotTemplate(node2, context) {
  },
  Title(node2, context) {
    const state = context.state;
    const body = create_block(node2, node2.fragment.nodes, context);
    state.template.push(t_string("<title>"));
    if (body.length === 1) {
      state.template.push(t_statement(body[0]));
    } else {
      state.template.push(t_statement(block(body)));
    }
    state.template.push(t_string("</title>"));
  },
  Slot(node2, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const props = [];
    const spreads = [];
    let name8 = literal2("default");
    for (const attribute of node2.attributes) {
      if (attribute.type === "Spread") {
        spreads.push(context.visit(attribute));
      } else if (attribute.type === "Attribute") {
        const value2 = serialize_attribute_value(attribute.value, context);
        if (attribute.name === "name") {
          name8 = value2;
        } else {
          if (context.state.analysis.dynamic_nodes.has(attribute)) {
            props.push(get(attribute.name, [return_builder(value2)]));
          } else {
            props.push(init(attribute.name, value2));
          }
        }
      }
    }
    const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", thunk(array([object(props), ...spreads])));
    const fallback = node2.fragment.nodes.length === 0 ? literal2(null) : thunk(block(create_block(node2, node2.fragment.nodes, context)));
    const slot = call(
      "$.slot",
      id("$$payload"),
      member(id("$$slots"), name8, true),
      props_expression,
      fallback
    );
    state.template.push(t_statement(stmt(slot)));
    state.template.push(t_expression(id2));
  },
  Head(node2, context) {
    const state = context.state;
    const body = create_block(node2, node2.fragment.nodes, context);
    state.template.push(
      t_statement(
        stmt(call("$.head", id("$$payload"), arrow([id("$$payload")], block(body))))
      )
    );
  },
  Window(node2, { state, next: next2 }) {
    next2({
      ...state
    });
  },
  Document(node2, { state, next: next2 }) {
    next2({
      ...state
    });
  }
};
function ssr_component(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    hoisted: [import_all("$", "svelte-experimental/server/internal")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called outside create_block");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called outside create_block");
      return a;
    },
    metadata: {
      namespace: analysis.namespace
    },
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = walk(analysis.module.ast, state, {
    ...set_scope(analysis.module.scopes),
    ...global_visitors,
    ...javascript_visitors,
    ...analysis.runes ? javascript_visitors_runes : javascript_visitors_legacy
  });
  const instance = walk(
    analysis.instance.ast,
    { ...state, scope: analysis.instance.scope },
    {
      ...set_scope(analysis.instance.scopes),
      ...global_visitors,
      ...javascript_visitors,
      ...analysis.runes ? javascript_visitors_runes : javascript_visitors_legacy,
      ImportDeclaration(node2, { state: state2 }) {
        state2.hoisted.push(node2);
        return { type: "EmptyStatement" };
      },
      ExportNamedDeclaration(node2, { state: state2, visit }) {
        if (node2.declaration) {
          return visit(node2.declaration);
        }
        return empty2;
      }
    }
  );
  const template2 = walk(
    analysis.template.ast,
    { ...state, scope: analysis.instance.scope },
    {
      ...set_scope(analysis.template.scopes),
      ...global_visitors,
      ...template_visitors
    }
  );
  for (const [node2] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node2);
    if (statement === void 0) {
      error(node2, "INTERNAL", "Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  const component_block = block([
    stmt(
      call(
        "$.push",
        id("$$events"),
        literal2(analysis.runes),
        ...analysis.immutable ? [literal2(true)] : []
      )
    ),
    ...instance.body,
    ...template2.body,
    stmt(call("$.pop"))
  ]);
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name: name8, alias }) => alias ?? name8);
    for (const [name8, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "prop")
        named_props.push(name8);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call("$.rest_props", id("$$props"), array(named_props.map((name8) => literal2(name8))))
      )
    );
  }
  const body = [
    ...state.hoisted,
    ...module.body,
    export_default(
      function_declaration(
        id(analysis.name),
        [id("$$payload"), id("$$props"), id("$$events"), id("$$slots")],
        component_block
      )
    )
  ];
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function ssr_module(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    hoisted: [import_all("$", "svelte-experimental/server/internal")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called");
      return a;
    },
    metadata: {
      namespace: analysis.namespace
    },
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = walk(analysis.module.ast, state, {
    ...set_scope(analysis.module.scopes),
    ...global_visitors,
    ...javascript_visitors,
    ...analysis.runes ? javascript_visitors_runes : javascript_visitors_legacy
  });
  return {
    type: "Program",
    sourceType: "module",
    body: [...state.hoisted, ...module.body]
  };
}

// src/compiler/phases/3-transform/dom.ts
var binding_properties = {
  fullscreenElement: {
    event: "fullscreenchange"
  },
  innerWidth: {
    event: "resize"
  },
  innerHeight: {
    event: "resize"
  },
  devicePixelRatio: {
    event: "resize"
  },
  open: {
    // TODO restrict to <details>
    event: "toggle"
  },
  indeterminate: {
    event: "change",
    type: "set"
  }
};
function serialize_set_binding2(node2, context, fallback) {
  const { state, visit } = context;
  if (node2.left.type === "ArrayPattern" || node2.left.type === "ObjectPattern" || node2.left.type === "RestElement") {
    const tmp_id = context.state.scope.generate("tmp");
    const original_assignments = [];
    const assignments = [];
    const paths = extract_paths(node2.left);
    for (const path of paths) {
      const value3 = path.expression(id(tmp_id));
      const assignment2 = assignment("=", path.node, value3);
      original_assignments.push(assignment2);
      assignments.push(serialize_set_binding2(assignment2, context, () => assignment2));
    }
    if (assignments.every((assignment2, i) => assignment2 === original_assignments[i])) {
      return fallback();
    }
    return call(
      thunk(
        block([
          const_builder(tmp_id, visit(node2.right)),
          stmt(sequence(assignments)),
          // return because it could be used in a nested expression where the value is needed.
          // example: { foo: ({ bar } = { bar: 1 })}
          return_builder(id(tmp_id))
        ])
      )
    );
  }
  if (node2.left.type !== "Identifier" && node2.left.type !== "MemberExpression") {
    error(node2, "INTERNAL", `Unexpected assignment type ${node2.left.type}`);
  }
  let left = node2.left;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (left.type !== "Identifier") {
    return fallback();
  }
  const binding = state.scope.get(left.name);
  if (!binding)
    return fallback();
  if (binding.mutation !== null) {
    return binding.mutation(node2, context);
  }
  const is_store = binding.kind === "store_sub";
  const left_name = is_store ? left.name.slice(1) : left.name;
  if (binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "each" && binding.kind !== "legacy_reactive" && !is_store) {
    return fallback();
  }
  const value2 = get_assignment_value2(node2, { state, visit });
  if (left === node2.left) {
    if (is_store) {
      return call("$.store_set", serialize_get_binding2(id(left_name), state), value2);
    } else {
      return call("$.set", id(left_name), value2);
    }
  } else {
    if (is_store) {
      return call(
        "$.mutate_store",
        serialize_get_binding2(id(left_name), state),
        assignment(node2.operator, visit(node2.left), value2),
        call("$" + left_name)
      );
    } else {
      return call(
        "$.mutate",
        id(left_name),
        assignment(node2.operator, visit(node2.left), value2)
      );
    }
  }
}
var global_visitors2 = {
  Identifier(node2, { path, state }) {
    if (is_reference(node2, path.at(-1))) {
      return serialize_get_binding2(node2, state);
    }
  },
  AssignmentExpression(node2, context) {
    return serialize_set_binding2(node2, context, context.next);
  },
  UpdateExpression(node2, context) {
    const { state, next: next2, visit } = context;
    const argument = node2.argument;
    if (argument.type === "Identifier") {
      const binding = state.scope.get(argument.name);
      const is_store = binding?.kind === "store_sub";
      const name8 = is_store ? argument.name.slice(1) : argument.name;
      if (binding?.kind === "state" || binding?.kind === "legacy_reactive" || binding?.kind === "prop" || is_store) {
        let fn2 = node2.operator === "++" ? "$.increment" : "$.decrement";
        if (node2.prefix)
          fn2 += "_pre";
        if (is_store) {
          fn2 += "_store";
          return call(fn2, serialize_get_binding2(id(name8), state), call("$" + name8));
        } else {
          return call(fn2, id(name8));
        }
      } else {
        return next2();
      }
    } else {
      const assignment2 = assignment(
        node2.operator === "++" ? "+=" : "-=",
        argument,
        literal2(1)
      );
      const serialized_assignment = serialize_set_binding2(assignment2, context, () => assignment2);
      const value2 = visit(argument);
      if (serialized_assignment === assignment2) {
        return next2();
      } else {
        let statements;
        if (node2.prefix) {
          statements = [stmt(serialized_assignment), return_builder(value2)];
        } else {
          const tmp_id = state.scope.generate("$$value");
          statements = [
            const_builder(tmp_id, value2),
            stmt(serialized_assignment),
            return_builder(id(tmp_id))
          ];
        }
        return call(thunk(block(statements)));
      }
    }
  }
};
function get_assignment_value2(node2, { state, visit }) {
  if (node2.left.type === "Identifier") {
    const operator = node2.operator;
    return operator === "=" ? visit(node2.right) : (
      // turn something like x += 1 into x = x + 1
      binary(
        operator.slice(0, -1),
        serialize_get_binding2(node2.left, state),
        visit(node2.right)
      )
    );
  } else {
    return visit(node2.right);
  }
}
var function_visitor = (node2, context) => {
  const metadata = node2.metadata;
  if (metadata?.delegated) {
    const params = serialize_delegated_params(node2, context);
    return {
      ...node2,
      params,
      body: context.visit(node2.body)
    };
  }
  context.next({ ...context.state });
};
var javascript_visitors2 = {
  Program(node2, { visit }) {
    return {
      ...node2,
      body: node2.body.map((node3) => visit(node3))
    };
  },
  BlockStatement(node2, { visit }) {
    return {
      ...node2,
      body: node2.body.map((node3) => visit(node3))
    };
  },
  FunctionExpression: function_visitor,
  ArrowFunctionExpression: function_visitor,
  FunctionDeclaration(node2, context) {
    const metadata = node2.metadata;
    if (metadata?.delegated) {
      const params = serialize_delegated_params(node2, context);
      context.state.hoisted.push({
        ...node2,
        id: node2.id !== null ? context.visit(node2.id) : null,
        params,
        body: context.visit(node2.body)
      });
      return empty2;
    }
    context.next({ ...context.state });
  }
};
var javascript_visitors_runes2 = {
  VariableDeclaration(node2, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node2.declarations) {
      const init2 = declarator2.init;
      const rune = get_rune(init2, state.scope);
      if (!rune) {
        if (init2 != null && is_delegated_function(init2)) {
          const delegated_function = visit(init2);
          state.hoisted.push(
            declaration("const", declarator2.id, delegated_function)
          );
          continue;
        }
        declarations.push(visit(declarator2));
        continue;
      }
      if (rune === "$props") {
        equal(declarator2.id.type, "ObjectPattern");
        const seen = [];
        for (const property of declarator2.id.properties) {
          if (property.type === "Property") {
            ok(property.key.type === "Identifier" || property.key.type === "Literal");
            let name8;
            if (property.key.type === "Identifier") {
              name8 = property.key.name;
            } else if (property.key.type === "Literal") {
              name8 = property.key.value.toString();
            } else {
              throw new Error("unreachable");
            }
            seen.push(name8);
            if (property.value.type === "Identifier") {
              declarations.push(
                declarator(
                  property.value,
                  call(
                    state.scope.get(property.value.name).mutated || state.analysis.accessors ? "$.prop_source" : "$.prop",
                    id("$$props"),
                    literal2(name8)
                  )
                )
              );
            } else if (property.value.type === "AssignmentPattern") {
              equal(property.value.left.type, "Identifier");
              declarations.push(
                // TODO this isn't completely correct  the right-hand-side will be evaluated
                // regardless of whether the prop is defined
                declarator(
                  property.value.left,
                  call(
                    state.scope.get(property.value.left.name).mutated || state.analysis.accessors ? "$.prop_source" : "$.prop",
                    id("$$props"),
                    literal2(name8),
                    property.value.right
                  )
                )
              );
            }
          } else {
            declarations.push(
              declarator(
                property.argument,
                call(
                  "$.rest_props",
                  id("$$props"),
                  array(seen.map((name8) => literal2(name8)))
                )
              )
            );
          }
        }
        continue;
      }
      const args = declarator2.init.arguments;
      const value2 = args.length === 0 ? id("undefined") : visit(args[0]);
      const opts = args[1] && visit(args[1]);
      if (declarator2.id.type === "Identifier") {
        const callee = rune === "$state" ? "$.source" : "$.derived";
        const arg = rune === "$state" ? value2 : thunk(value2);
        declarations.push(declarator(declarator2.id, call(callee, arg, opts)));
        continue;
      }
      if (rune === "$derived") {
        const bindings2 = state.scope.get_bindings(declarator2);
        const id2 = state.scope.generate("derived_value");
        declarations.push(
          declarator(
            id(id2),
            call(
              "$.derived",
              thunk(
                block([
                  let_builder(declarator2.id, value2),
                  return_builder(array(bindings2.map((binding) => binding.node)))
                ])
              )
            )
          )
        );
        for (let i = 0; i < bindings2.length; i++) {
          bindings2[i].expression = member(call("$.get", id(id2)), literal2(i), true);
        }
        continue;
      }
      declarations.push(...create_state_declarators2(declarator2, state.scope, value2));
    }
    if (declarations.length === 0) {
      return empty2;
    }
    return {
      ...node2,
      declarations
    };
  },
  ExpressionStatement(node2, context) {
    if (node2.expression.type === "CallExpression") {
      const callee = node2.expression.callee;
      if (callee.type === "Identifier" && callee.name === "$effect" && !context.state.scope.get("$effect")) {
        const func = context.visit(node2.expression.arguments[0]);
        return {
          ...node2,
          expression: call("$.effect", func)
        };
      }
      if (callee.type === "MemberExpression" && callee.object.type === "Identifier" && callee.object.name === "$effect" && callee.property.type === "Identifier" && callee.property.name === "pre" && !context.state.scope.get("$effect")) {
        const func = context.visit(node2.expression.arguments[0]);
        return {
          ...node2,
          expression: call("$.pre_effect", func)
        };
      }
    }
    context.next();
  }
};
var javascript_visitors_legacy2 = {
  VariableDeclaration(node2, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node2.declarations) {
      const bindings2 = state.scope.get_bindings(declarator2);
      const has_state = bindings2.some((binding) => binding.kind === "state");
      const has_props = bindings2.some((binding) => binding.kind === "prop");
      if (!has_state && !has_props) {
        const init2 = declarator2.init;
        if (init2 != null && is_delegated_function(init2)) {
          const delegated_function = visit(init2);
          state.hoisted.push(
            declaration("const", declarator2.id, delegated_function)
          );
          continue;
        }
        declarations.push(visit(declarator2));
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(declarator(id(tmp), visit(declarator2.init)));
          for (const path of paths) {
            const name8 = path.node.name;
            const binding2 = state.scope.get(name8);
            const value2 = path.expression(id(tmp));
            declarations.push(
              declarator(
                path.node,
                binding2.kind === "prop" || binding2.kind === "rest_prop" ? call(
                  binding2.mutated || state.analysis.accessors ? "$.prop_source" : "$.prop",
                  id("$$props"),
                  literal2(binding2.prop_alias ? binding2.prop_alias : name8),
                  value2
                ) : value2
              )
            );
          }
          continue;
        }
        const binding = state.scope.get(declarator2.id.name);
        const args = [
          id("$$props"),
          literal2(binding.prop_alias ? binding.prop_alias : declarator2.id.name)
        ];
        if (declarator2.init) {
          args.push(visit(declarator2.init));
        }
        declarations.push(
          declarator(
            declarator2.id,
            call(
              binding.mutated || state.analysis.accessors ? "$.prop_source" : "$.prop",
              ...args
            )
          )
        );
        continue;
      }
      declarations.push(
        ...create_state_declarators2(
          declarator2,
          state.scope,
          declarator2.init && visit(declarator2.init)
        )
      );
    }
    if (declarations.length === 0) {
      return empty2;
    }
    return {
      ...node2,
      declarations
    };
  },
  LabeledStatement(node2, context) {
    if (context.path.length > 1)
      return;
    if (node2.label.name !== "$")
      return;
    const state = context.state;
    const { dependencies } = state.analysis.reactive_statements.get(node2);
    let serialized_body = context.visit(node2.body);
    if (serialized_body.type !== "BlockStatement") {
      serialized_body = block([serialized_body]);
    }
    const body = serialized_body.body;
    const new_body = [];
    const sequence2 = [];
    for (const binding of dependencies) {
      if (binding.kind === "normal")
        continue;
      const name8 = binding.node.name;
      let serialized = serialize_get_binding2(id(name8), state);
      if (name8 === "$$props" || name8 === "$$restProps") {
        serialized = call("$.access_props", serialized);
      }
      sequence2.push(serialized);
    }
    if (sequence2.length > 0) {
      new_body.push(stmt(sequence(sequence2)));
    }
    new_body.push(stmt(call("$.untrack", thunk(block(body)))));
    serialized_body.body = new_body;
    state.legacy_reactive_statements.set(
      node2,
      stmt(call("$.pre_effect", thunk(serialized_body)))
    );
    return empty2;
  },
  BreakStatement(node2, context) {
    if (!node2.label || node2.label.name !== "$")
      return;
    const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
    if (in_reactive_statement) {
      return return_builder();
    }
  }
};
function setup_select_synchronization(value_binding, context) {
  let bound = value_binding.expression;
  while (bound.type === "MemberExpression") {
    bound = bound.object;
  }
  const names = [];
  for (const [name8, refs] of context.state.scope.references) {
    if (refs.length > 0 && // prevent infinite loop
    name8 !== bound.name) {
      names.push(name8);
    }
  }
  const to_invalidate = context.state.analysis.runes ? empty2 : stmt(
    call(
      "$.invalidate_inner_signals",
      thunk(
        block(
          names.map((name8) => {
            const serialized = serialize_get_binding2(id(name8), context.state);
            return stmt(serialized);
          })
        )
      )
    )
  );
  context.state.init.push(
    stmt(
      call(
        "$.pre_effect",
        thunk(
          block([stmt(context.visit(value_binding.expression)), to_invalidate])
        )
      )
    )
  );
}
function serialize_element_spread_attributes2(attributes2, context, element_id) {
  let is_reactive2 = false;
  const values = [];
  for (const attribute of attributes2) {
    if (attribute.type === "Attribute") {
      let name8 = attribute.name.toLowerCase();
      if (name8 !== "class" && AttributeAliases.has(name8)) {
        name8 = AttributeAliases.get(name8);
      }
      const [, value2] = serialize_attribute_value2(attribute.value, context);
      values.push(object([init(name8, value2)]));
    } else {
      values.push(context.visit(attribute));
    }
    if (!is_reactive2) {
      is_reactive2 = context.state.analysis.dynamic_nodes.has(attribute);
    }
  }
  if (is_reactive2) {
    const id2 = context.state.scope.generate("spread_attributes");
    context.state.init.push(let_builder(id2, void 0));
    context.state.update.push({
      grouped: stmt(
        assignment(
          "=",
          id(id2),
          call(
            "$.spread_attributes",
            element_id,
            id(id2),
            array(values),
            literal2(context.state.analysis.stylesheet.id)
          )
        )
      )
    });
    return id2;
  } else {
    context.state.init.push(
      stmt(
        call(
          "$.spread_attributes",
          element_id,
          literal2(null),
          array(values),
          literal2(context.state.analysis.stylesheet.id)
        )
      )
    );
    return null;
  }
}
function serialize_element_attribute_update_assignment(node_id, attribute, context) {
  const state = context.state;
  const name8 = attribute.name.toLowerCase();
  const aliased_name = AttributeAliases.get(name8) || name8;
  let [contains_call_expression, value2] = serialize_attribute_value2(attribute.value, context);
  let grouped_value = value2;
  if (name8 === "autofocus") {
    state.init.push(stmt(call("$.auto_focus", node_id, value2)));
    return false;
  }
  if (name8 === "class") {
    grouped_value = call("$.to_class", value2);
  }
  const assign = (grouped, singular) => {
    if (name8 === "class") {
      if (singular) {
        return {
          singular: stmt(call("$.class_name", node_id, thunk(singular))),
          grouped: stmt(call("$.class_name", node_id, grouped))
        };
      }
      return {
        grouped: stmt(call("$.class_name", node_id, grouped))
      };
    } else if (!DOMProperties.has(aliased_name)) {
      const func_name = name8.startsWith("xlink") ? "$.xlink_attr" : "$.attr";
      if (singular) {
        return {
          singular: stmt(call(func_name, node_id, literal2(name8), thunk(singular))),
          grouped: stmt(call(func_name, node_id, literal2(name8), grouped))
        };
      }
      return {
        grouped: stmt(call(func_name, node_id, literal2(name8), grouped))
      };
    } else {
      return { grouped: stmt(assignment("=", member(node_id, id(aliased_name)), grouped)) };
    }
  };
  if (state.analysis.dynamic_nodes.has(attribute)) {
    const id2 = state.scope.generate(`${node_id.name}_${aliased_name}`);
    serialize_update_assignment(
      state,
      id2,
      name8 === "class" ? literal2("") : void 0,
      grouped_value,
      assign(id(id2), value2),
      contains_call_expression
    );
    return true;
  } else {
    state.init.push(assign(grouped_value).grouped);
    return false;
  }
}
function serialize_element_special_value_attribute(element, node_id, attribute, context) {
  const state = context.state;
  const [contains_call_expression, value2] = serialize_attribute_value2(attribute.value, context);
  const inner_assignment = assignment(
    "=",
    member(node_id, id("value")),
    assignment("=", member(node_id, id("__value")), value2)
  );
  const is_reactive2 = state.analysis.dynamic_nodes.has(attribute);
  const needs_selected_call = element === "option" && (is_reactive2 || collect_parent_each_blocks(context).length > 0);
  const needs_option_call = element === "select" && is_reactive2;
  const assigment = stmt(
    needs_selected_call ? sequence([
      inner_assignment,
      // This ensures things stay in sync with the select binding
      // in case of updates to the option value or new values appearing
      call("$.selected", node_id)
    ]) : needs_option_call ? (
      // This ensures a one-way street to the DOM in case it's <select {value}>
      // and not <select bind:value>
      call("$.select_option", node_id, inner_assignment)
    ) : inner_assignment
  );
  if (is_reactive2) {
    const id2 = state.scope.generate(`${node_id.name}_value`);
    serialize_update_assignment(
      state,
      id2,
      void 0,
      value2,
      { grouped: assigment },
      contains_call_expression
    );
    return true;
  } else {
    state.init.push(assigment);
    return false;
  }
}
function serialize_update_assignment(state, id2, init2, value2, assignment2, contains_call_expression) {
  const grouped = if_builder(
    binary("!==", id(id2), assignment("=", id(id2), value2)),
    block([assignment2.grouped])
  );
  if (contains_call_expression && assignment2.singular) {
    state.update_effects.push(assignment2.singular);
  } else {
    if (assignment2.singular) {
      state.update.push({
        init: let_builder(id2, init2),
        singular: assignment2.singular,
        grouped
      });
    } else {
      state.update.push({
        init: let_builder(id2, init2),
        grouped
      });
    }
  }
}
function serialize_style_directives2(style_directives, element_id, context, is_attributes_reactive) {
  if (style_directives.length > 0) {
    const values = style_directives.map((directive) => {
      let value2 = directive.value === true ? serialize_get_binding2({ name: directive.name, type: "Identifier" }, context.state) : serialize_attribute_value2(directive.value, context)[1];
      if (directive.modifiers.includes("important")) {
        value2 = binary("+", value2, literal2(" !important"));
      }
      return stmt(call("$.style", element_id, literal2(directive.name), value2));
    });
    if (is_attributes_reactive || style_directives.some((directive) => context.state.analysis.dynamic_nodes.has(directive))) {
      context.state.update.push(...values.map((v2) => ({ grouped: v2 })));
    } else {
      context.state.init.push(...values);
    }
  }
}
function serialize_class_directives2(class_directives, element_id, context, is_attributes_reactive) {
  if (class_directives.length > 0) {
    const values = class_directives.map((directive) => {
      const value2 = context.visit(directive.expression);
      return stmt(call("$.class_toggle", element_id, literal2(directive.name), value2));
    });
    if (is_attributes_reactive || class_directives.some((directive) => context.state.analysis.dynamic_nodes.has(directive))) {
      context.state.update.push(...values.map((v2) => ({ grouped: v2 })));
    } else {
      context.state.init.push(...values);
    }
  }
}
var template_visitors2 = {
  Fragment(node2, context) {
    const body = create_block2(node2, "frag", node2.nodes, context);
    return block(body);
  },
  Template(node2, context) {
    return {
      type: "BlockStatement",
      body: create_block2(node2, "main", node2.body, context)
    };
  },
  RawMustacheTag(node2, context) {
    context.state.template.push("<!---->");
    const name8 = context.state.scope.generate("raw");
    const memo = context.state.scope.generate("raw_memo");
    context.state.init.push(
      const_builder(memo, call("$.derived", thunk(context.visit(node2.expression))))
    );
    serialize_update_assignment(
      context.state,
      name8,
      literal2(""),
      call("$.get", id(memo)),
      {
        grouped: stmt(
          call(
            "$.html",
            context.state.node,
            id(name8),
            literal2(context.state.metadata.namespace === "svg")
          )
        )
      },
      false
    );
  },
  ConstTag(node2, { state, visit }) {
    if (node2.expression.left.type === "Identifier") {
      state.init.push(
        const_builder(
          node2.expression.left,
          call("$.derived", thunk(visit(node2.expression.right)))
        )
      );
    } else {
      const identifiers = extract_identifiers(node2.expression.left);
      const tmp = id(state.scope.generate("computed_const"));
      for (const node3 of identifiers) {
        const binding = state.scope.get(node3.name);
        binding.expression = node3;
      }
      const fn2 = arrow(
        [],
        block([
          const_builder(
            visit(node2.expression.left),
            visit(node2.expression.right)
          ),
          return_builder(object(identifiers.map((node3) => prop("init", node3, node3))))
        ])
      );
      state.init.push(const_builder(tmp, call("$.derived", fn2)));
      for (const node3 of identifiers) {
        const binding = state.scope.get(node3.name);
        binding.expression = member(call("$.get", tmp), node3);
      }
    }
  },
  DebugTag(node2, { state, next: next2 }) {
    error(node2, "TODO", node2.type);
  },
  AnimateDirective(node2, { state, next: next2 }) {
    error(node2, "TODO", node2.type);
  },
  ClassDirective(node2, { state, next: next2 }) {
    error(node2, "INTERNAL", "Node should have been handled elsewhere");
  },
  StyleDirective(node2, { state, next: next2 }) {
    error(node2, "INTERNAL", "Node should have been handled elsewhere");
  },
  TransitionDirective(node2, { state, next: next2 }) {
    error(node2, "TODO", node2.type);
  },
  RegularElement(node2, context) {
    if (context.state.metadata.namespace === void 0) {
      if (is_svg_element(node2.name)) {
        context.state.metadata.namespace = "svg";
      } else {
        context.state.metadata.namespace = "html";
      }
    } else if (node2.name === "foreignObject") {
      context.state.metadata.namespace = "html";
    }
    context.state.template.push(`<${node2.name}`);
    const attributes2 = [];
    const class_directives = [];
    const style_directives = [];
    const lets = [];
    let has_spread = false;
    let value_binding = null;
    let needs_special_value_handling = node2.name === "option" || node2.name === "select";
    for (const attribute of node2.attributes) {
      if (attribute.type === "Attribute") {
        attributes2.push(attribute);
      } else if (attribute.type === "Spread") {
        attributes2.push(attribute);
        has_spread = true;
      } else if (attribute.type === "ClassDirective") {
        class_directives.push(attribute);
      } else if (attribute.type === "StyleDirective") {
        style_directives.push(attribute);
      } else if (attribute.type === "LetDirective") {
        lets.push(context.visit(attribute));
      } else {
        if (attribute.type === "BindDirective") {
          if (attribute.name === "group" || attribute.name === "checked") {
            needs_special_value_handling = true;
          } else if (attribute.name === "value") {
            value_binding = attribute;
          }
        }
        context.visit(attribute);
      }
    }
    if (value_binding !== null && node2.name === "select") {
      setup_select_synchronization(value_binding, context);
    }
    const node_id = context.state.node;
    context.state.init.push(...lets);
    let is_attributes_reactive = false;
    if (has_spread) {
      const spread_id = serialize_element_spread_attributes2(attributes2, context, node_id);
      add_select_to_spread_update(spread_id, node2, context, node_id);
      is_attributes_reactive = spread_id !== null;
    } else {
      for (const attribute of attributes2) {
        if (needs_special_value_handling && attribute.name === "value") {
          serialize_element_special_value_attribute(node2.name, node_id, attribute, context);
          continue;
        }
        if (attribute.name !== "autofocus" && (attribute.value === true || is_text_attribute(attribute))) {
          const name8 = attribute.name.toLowerCase();
          const literal_value = serialize_attribute_value2(attribute.value, context)[1].value;
          if (name8 !== "class" || literal_value) {
            context.state.template.push(
              ` ${attribute.name}${DOMBooleanAttributes.has(name8) && literal_value === true ? "" : `="${literal_value === true ? "" : escape_html(String(literal_value), true)}"`}`
            );
            continue;
          }
        }
        const is3 = serialize_element_attribute_update_assignment(node_id, attribute, context);
        if (is3)
          is_attributes_reactive = true;
      }
    }
    serialize_class_directives2(class_directives, node_id, context, is_attributes_reactive);
    serialize_style_directives2(style_directives, node_id, context, is_attributes_reactive);
    context.state.template.push(">");
    const state = {
      ...context.state,
      scope: context.state.scopes.get(node2.fragment),
      preserve_whitespace: context.state.preserve_whitespace || node2.name === "pre" || node2.name === "textarea"
    };
    const { hoisted, trimmed } = clean_nodes(
      node2,
      node2.fragment.nodes,
      context.path,
      context.state.metadata.namespace,
      state.preserve_whitespace,
      false
    );
    for (const node3 of hoisted) {
      context.visit(node3, state);
    }
    process_children2(
      trimmed,
      call(
        "$.child",
        node2.name === "template" ? member(context.state.node, id("content")) : context.state.node
      ),
      { ...context, state }
    );
    if (!VoidElements.has(node2.name)) {
      context.state.template.push(`</${node2.name}>`);
    }
  },
  DynamicElement(node2, context) {
    context.state.template.push(`<!---->`);
    const attributes2 = [];
    const class_directives = [];
    const style_directives = [];
    const lets = [];
    let namespace = null;
    let has_spread = false;
    const element_id = id(context.state.scope.generate("$$element"));
    const inner_context = {
      ...context,
      state: {
        ...context.state,
        node: element_id,
        init: [],
        update: [],
        update_effects: [],
        after_update: []
      }
    };
    for (const attribute of node2.attributes) {
      if (attribute.type === "Attribute") {
        attributes2.push(attribute);
        if (attribute.name === "xmlns" && is_text_attribute(attribute)) {
          namespace = attribute.value[0].data;
        }
      } else if (attribute.type === "Spread") {
        attributes2.push(attribute);
        has_spread = true;
      } else if (attribute.type === "ClassDirective") {
        class_directives.push(attribute);
      } else if (attribute.type === "StyleDirective") {
        style_directives.push(attribute);
      } else if (attribute.type === "LetDirective") {
        lets.push(context.visit(attribute));
      } else {
        context.visit(attribute, inner_context.state);
      }
    }
    context.state.init.push(...lets);
    let is_attributes_reactive = false;
    if (has_spread) {
      is_attributes_reactive = serialize_element_spread_attributes2(attributes2, inner_context, element_id) !== null;
    } else {
      for (const attribute of attributes2) {
        const is3 = serialize_element_attribute_update_assignment(
          element_id,
          attribute,
          inner_context
        );
        if (is3)
          is_attributes_reactive = true;
      }
    }
    serialize_class_directives2(class_directives, element_id, inner_context, is_attributes_reactive);
    serialize_style_directives2(style_directives, element_id, inner_context, is_attributes_reactive);
    const get_tag = thunk(
      typeof node2.tag === "string" ? literal2(node2.tag) : context.visit(node2.tag)
    );
    if (context.state.analysis.dev && node2.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", get_tag)));
    }
    const inner = inner_context.state.init;
    if (inner_context.state.update.length > 0 || inner_context.state.update_effects.length > 0) {
      if (inner_context.state.update_effects.length > 0) {
        for (const render of inner_context.state.update_effects) {
          inner.push(render);
        }
      }
      if (inner_context.state.update.length > 0) {
        let render;
        if (inner_context.state.update.length === 1 && inner_context.state.update[0].singular) {
          render = inner_context.state.update[0].singular;
        } else {
          render = stmt(
            call(
              "$.render_effect",
              thunk(
                block(
                  inner_context.state.update.map((n2) => {
                    if (n2.init) {
                      inner.push(n2.init);
                    }
                    return n2.grouped;
                  })
                )
              )
            )
          );
        }
        inner.push(render);
      }
    }
    inner.push(...inner_context.state.after_update);
    inner.push(...create_block2(node2, "dynamic_element", node2.fragment.nodes, context));
    context.state.after_update.push(
      stmt(
        call(
          "$.element",
          context.state.node,
          get_tag,
          arrow([element_id, id("$$anchor")], block(inner)),
          namespace === "http://www.w3.org/2000/svg" ? literal2(true) : void 0
        )
      )
    );
  },
  EachBlock(node2, context) {
    const each_node_meta = node2.metadata;
    const collection = context.visit(node2.expression);
    let each_item_is_reactive = true;
    if (!each_node_meta.is_controlled) {
      context.state.template.push("<!---->");
    }
    if (each_node_meta.array_name !== null) {
      context.state.init.push(const_builder(each_node_meta.array_name, thunk(collection)));
    }
    let each_type;
    if (node2.key) {
      each_type = 1 << 2;
      if (node2.key.type === "Identifier" && node2.context.type === "Identifier" && node2.context.name === node2.key.name && context.state.analysis.immutable) {
        each_item_is_reactive = false;
      } else {
        each_type |= 1;
      }
      if (node2.index || node2.context.type !== "Identifier") {
        each_type |= 1 << 1;
      }
    } else {
      each_type = 1;
    }
    if (each_node_meta.is_controlled) {
      each_type |= 1 << 3;
    }
    const indirect_dependencies = collect_parent_each_blocks(context).flatMap((block2) => {
      const array2 = context.visit(block2.expression);
      const transitive_dependencies = serialize_transitive_dependencies(
        block2.metadata.references,
        context
      );
      return [array2, ...transitive_dependencies];
    });
    if (each_node_meta.array_name) {
      indirect_dependencies.push(call(each_node_meta.array_name));
    } else {
      indirect_dependencies.push(collection);
      const transitive_dependencies = serialize_transitive_dependencies(
        each_node_meta.references,
        context
      );
      indirect_dependencies.push(...transitive_dependencies);
    }
    const create_mutation = (expression_for_id, expression_for_other) => {
      return (assignment2, { state, visit }) => {
        if (assignment2.left.type !== "Identifier" && assignment2.left.type !== "MemberExpression") {
          return serialize_set_binding2(assignment2, context, () => assignment2);
        }
        const left = object2(assignment2.left);
        const value2 = get_assignment_value2(assignment2, { state, visit });
        const invalidate = call(
          "$.invalidate_inner_signals",
          thunk(sequence(indirect_dependencies))
        );
        if (left === assignment2.left) {
          const assign = assignment("=", expression_for_id, value2);
          return context.state.analysis.runes ? assign : sequence([assign, invalidate]);
        } else {
          const original_left = assignment2.left;
          const left2 = member(
            expression_for_other,
            visit(original_left).property,
            original_left.computed
          );
          const assign = assignment(assignment2.operator, left2, value2);
          return context.state.analysis.runes ? assign : sequence([assign, invalidate]);
        }
      };
    };
    const index = each_node_meta.contains_group_binding || !node2.index ? each_node_meta.index : id(node2.index);
    const item = id(each_node_meta.item_name);
    const binding = context.state.scope.get(item.name);
    binding.expression = each_item_is_reactive ? call("$.unwrap", item) : item;
    const declarations = [];
    if (node2.context.type === "Identifier") {
      binding.mutation = create_mutation(
        member(
          each_node_meta.array_name ? call(each_node_meta.array_name) : collection,
          index,
          true
        ),
        binding.expression
      );
    } else {
      const unwrapped = binding.expression;
      const paths = extract_paths(node2.context);
      for (const path of paths) {
        const name8 = path.node.name;
        const binding2 = context.state.scope.get(name8);
        declarations.push(
          let_builder(path.node, thunk(context.visit(path.expression(unwrapped))))
        );
        binding2.expression = call(name8);
        binding2.mutation = create_mutation(
          path.update_expression(unwrapped),
          binding2.expression
        );
      }
    }
    const children = create_block2(node2, "each_block", node2.body.nodes, context);
    const else_block = node2.fallback ? arrow([id("$$anchor")], context.visit(node2.fallback)) : literal2(null);
    const key_function = node2.key && (each_type & 1) !== 0 ? arrow(
      [node2.context.type === "Identifier" ? node2.context : id("$$item")],
      block(declarations.concat(return_builder(context.visit(node2.key))))
    ) : literal2(null);
    if (node2.index && each_node_meta.contains_group_binding) {
      declarations.push(let_builder(node2.index, index));
    }
    context.state.after_update.push(
      stmt(
        call(
          "$.each",
          context.state.node,
          each_node_meta.array_name ? each_node_meta.array_name : thunk(collection),
          literal2(each_type),
          key_function,
          arrow([id("$$anchor"), item, index], block(declarations.concat(children))),
          else_block
        )
      )
    );
  },
  IfBlock(node2, context) {
    context.state.template.push("<!---->");
    const consequent = context.visit(node2.consequent);
    context.state.after_update.push(
      stmt(
        call(
          "$.if",
          context.state.node,
          thunk(context.visit(node2.test)),
          arrow([id("$$anchor")], consequent),
          node2.alternate ? arrow([id("$$anchor")], context.visit(node2.alternate)) : literal2(null)
        )
      )
    );
  },
  AwaitBlock(node2, context) {
    context.state.template.push("<!---->");
    context.state.after_update.push(
      stmt(
        call(
          "$.await",
          context.state.node,
          thunk(context.visit(node2.expression)),
          node2.pending ? arrow([id("$$anchor")], context.visit(node2.pending)) : literal2(null),
          node2.then ? arrow(
            node2.value ? [id("$$anchor"), context.visit(node2.value)] : [id("$$anchor")],
            context.visit(node2.then)
          ) : literal2(null),
          node2.catch ? arrow(
            node2.error ? [id("$$anchor"), context.visit(node2.error)] : [id("$$anchor")],
            context.visit(node2.catch)
          ) : literal2(null)
        )
      )
    );
  },
  KeyBlock(node2, context) {
    context.state.template.push("<!---->");
    const key2 = context.visit(node2.expression);
    const body = context.visit(node2.fragment);
    context.state.after_update.push(
      stmt(call("$.key", context.state.node, thunk(key2), arrow([id("$$anchor")], body)))
    );
  },
  FunctionExpression: function_visitor,
  ArrowFunctionExpression: function_visitor,
  OnDirective(node2, context) {
    const state = context.state;
    if (node2.expression) {
      let handler = serialize_event_handler(node2, context);
      const event_name = node2.name;
      if (node2.metadata.delegated) {
        if (node2.metadata.delegated === node2.expression) {
          const func_name = context.state.scope.root.unique("on_" + event_name);
          state.hoisted.push(declaration("const", func_name, handler));
          handler = func_name;
        }
        if (!state.events.has(event_name)) {
          state.events.add(event_name);
        }
        const delegated_params = node2.metadata.delegated.metadata.delegated_params;
        const args2 = [handler, ...delegated_params];
        state.after_update.push(
          stmt(
            assignment("=", member(context.state.node, id("__" + event_name)), array(args2))
          )
        );
        return;
      }
      const args = [
        literal2(event_name),
        context.state.node,
        handler,
        literal2(node2.modifiers.includes("capture"))
      ];
      if (node2.modifiers.includes("passive")) {
        args.push(literal2(true));
      } else if (node2.modifiers.includes("nonpassive")) {
        args.push(literal2(false));
      } else if (PassiveEvents.has(node2.name)) {
        args.push(literal2(true));
      }
      state.after_update.push(stmt(call("$.event", ...args)));
    } else {
      state.after_update.push(
        stmt(
          call(
            "$.event",
            literal2(node2.name),
            state.node,
            serialize_event_handler(node2, context)
          )
        )
      );
    }
  },
  UseDirective(node2, { state, next: next2, visit }) {
    const params = [id("$$node")];
    if (node2.expression) {
      params.push(id("$$props"));
    }
    const args = [
      state.node,
      arrow(params, call(serialize_get_binding2(id(node2.name), state), ...params))
    ];
    if (node2.expression) {
      args.push(thunk(visit(node2.expression)));
    }
    state.after_update.push(stmt(call("$.action", ...args)));
    next2();
  },
  BindDirective(node2, context) {
    const { state, path } = context;
    const properties = [];
    let expression = node2.expression;
    while (expression.type === "MemberExpression") {
      properties.unshift(
        expression.computed ? expression.property : literal2(expression.property.name)
      );
      expression = expression.object;
    }
    const getter = thunk(context.visit(node2.expression));
    const assignment2 = assignment("=", node2.expression, id("$$value"));
    const setter = arrow(
      [id("$$value")],
      serialize_set_binding2(assignment2, context, () => context.visit(assignment2))
    );
    let call_expr;
    if (node2.name in binding_properties) {
      const property = binding_properties[node2.name];
      call_expr = call(
        "$.bind_property",
        literal2(node2.name),
        literal2(property.event),
        literal2(property.type ?? "get"),
        state.node,
        getter,
        setter
      );
    } else {
      switch (node2.name) {
        case "value": {
          const parent = path.at(-1);
          if (parent?.type === "RegularElement" && parent.name === "select") {
            call_expr = call(`$.bind_select_value`, state.node, getter, setter);
          } else {
            call_expr = call(`$.bind_value`, state.node, getter, setter);
          }
          break;
        }
        case "checked":
          call_expr = call(`$.bind_checked`, state.node, getter, setter);
          break;
        case "this":
          call_expr = call(`$.bind_this`, state.node, setter);
          break;
        case "scrollX":
        case "scrollY":
          call_expr = call(
            "$.bind_scroll",
            literal2(node2.name === "scrollX" ? "x" : "y"),
            state.node,
            getter,
            setter
          );
          break;
        case "textContent":
        case "innerHTML":
        case "innerText":
          call_expr = call(
            "$.bind_content_editable",
            literal2(node2.name),
            state.node,
            getter,
            setter
          );
          break;
        case "group": {
          const indexes = [];
          for (const parent_each_block of node2.metadata.parent_each_blocks.slice(0, -1)) {
            indexes.push(call("$.unwrap", parent_each_block.metadata.index));
          }
          let group_getter = getter;
          const parent = path.at(-1);
          if (parent?.type === "RegularElement") {
            const value2 = parent.attributes.find(
              (a) => a.type === "Attribute" && a.name === "value" && !is_text_attribute(a) && a.value !== true
            )?.value;
            if (value2 !== void 0) {
              group_getter = thunk(
                block([
                  stmt(serialize_attribute_value2(value2, context)[1]),
                  return_builder(context.visit(node2.expression))
                ])
              );
            }
          }
          call_expr = call(
            "$.bind_group",
            node2.metadata.binding_group_name,
            array(indexes),
            state.node,
            group_getter,
            setter
          );
          break;
        }
        default:
          error(node2, "TODO", "implement binding");
      }
    }
    if (node2.name === "this") {
      state.init.push(stmt(call_expr));
    } else {
      state.after_update.push(stmt(call_expr));
    }
  },
  InlineComponent(node2, context) {
    context.state.template.push("<!---->");
    const binding = context.state.scope.get(
      node2.name.includes(".") ? node2.name.slice(0, node2.name.indexOf(".")) : node2.name
    );
    if (binding !== null && binding.kind !== "normal") {
      const component2 = serialize_inline_component2(node2, "$$component", context);
      context.state.after_update.push(
        stmt(
          call(
            "$.component",
            context.state.node,
            // TODO use untrack here to not update when binding changes?
            // Would align with Svelte 4 behavior, but it's arguably nicer/expected to update this
            thunk(context.visit(member_id(node2.name))),
            arrow([id("$$component")], component2)
          )
        )
      );
      return;
    }
    const component = serialize_inline_component2(node2, node2.name, context);
    context.state.after_update.push(stmt(component));
  },
  SelfElement(node2, context) {
    context.state.template.push("<!---->");
    const component = serialize_inline_component2(node2, context.state.analysis.name, context);
    context.state.after_update.push(stmt(component));
  },
  DynamicComponent(node2, context) {
    context.state.template.push("<!---->");
    let component = serialize_inline_component2(node2, "$$component", context);
    if (context.state.analysis.dev) {
      component = call("$.validate_dynamic_component", thunk(component));
    }
    context.state.after_update.push(
      stmt(
        call(
          "$.component",
          context.state.node,
          thunk(context.visit(node2.expression)),
          arrow([id("$$component")], component)
        )
      )
    );
  },
  Attribute(node2) {
    error(node2, "INTERNAL", `${node2.type} should be handled in parent node`);
  },
  LetDirective(node2, { state, path }) {
    const parent = path.at(-1);
    if (parent === void 0 || parent.type !== "InlineComponent" && parent.type !== "RegularElement" && parent.type !== "SlotTemplate") {
      error(node2, "INTERNAL", "let directive at invalid position");
    }
    if (node2.expression && node2.expression.type !== "Identifier") {
      const name8 = state.scope.generate(node2.name);
      const bindings2 = state.scope.get_bindings(node2);
      for (const binding of bindings2) {
        binding.expression = member(call("$.get", id(name8)), id(binding.node.name));
      }
      return const_builder(
        name8,
        call(
          "$.derived",
          thunk(
            block([
              let_builder(
                node2.expression.type === "ObjectExpression" ? (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  object_pattern(node2.expression.properties)
                ) : (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  array_pattern(node2.expression.elements)
                ),
                member(call("$.unwrap", id("$$slotProps")), id(node2.name))
              ),
              return_builder(object(bindings2.map((binding) => init(binding.node.name, binding.node))))
            ])
          )
        )
      );
    } else {
      const name8 = node2.expression === null ? node2.name : node2.expression.name;
      return const_builder(
        name8,
        call(
          "$.derived",
          thunk(member(call("$.unwrap", id("$$slotProps")), id(node2.name)))
        )
      );
    }
  },
  AttributeShorthand(node2) {
    error(node2, "INTERNAL", `${node2.type} should be handled in parent node`);
  },
  Spread(node2, { visit }) {
    return visit(node2.expression);
  },
  MustacheTag(node2) {
    error(node2, "INTERNAL", `${node2.type} should be handled in parent node`);
  },
  SlotTemplate(node2, context) {
    const lets = [];
    for (const attribute of node2.attributes) {
      if (attribute.type === "LetDirective") {
        lets.push(context.visit(attribute));
      }
    }
    const state = {
      ...context.state,
      // TODO this logic eventually belongs in create_block, when fragments are used everywhere
      scope: context.state.scopes.get(node2.fragment)
    };
    context.state.init.push(...lets);
    context.state.init.push(
      ...create_block2(node2, "slot_template", node2.fragment.nodes, {
        ...context,
        state
      })
    );
  },
  Slot(node2, context) {
    context.state.template.push("<!---->");
    const props = [];
    const spreads = [];
    let name8 = literal2("default");
    for (const attribute of node2.attributes) {
      if (attribute.type === "Spread") {
        spreads.push(context.visit(attribute));
      } else if (attribute.type === "Attribute") {
        const [, value2] = serialize_attribute_value2(attribute.value, context);
        if (attribute.name === "name") {
          name8 = value2;
        } else {
          if (context.state.analysis.dynamic_nodes.has(attribute)) {
            props.push(get(attribute.name, [return_builder(value2)]));
          } else {
            props.push(init(attribute.name, value2));
          }
        }
      }
    }
    const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", thunk(array([object(props), ...spreads])));
    const fallback = node2.fragment.nodes.length === 0 ? literal2(null) : arrow(
      [id("$$anchor")],
      block(create_block2(node2, "fallback", node2.fragment.nodes, context))
    );
    const slot = call(
      "$.slot",
      context.state.node,
      member(id("$$slots"), name8, true),
      props_expression,
      fallback
    );
    context.state.init.push(stmt(slot));
  },
  Head(node2, context) {
    context.state.init.push(
      stmt(
        call(
          "$.head",
          arrow(
            [id("$$anchor")],
            block(create_block2(node2, "head", node2.fragment.nodes, context))
          )
        )
      )
    );
  },
  Title(node2, { state, visit }) {
    if (node2.fragment.nodes.length === 1 && node2.fragment.nodes[0].type === "Text") {
      state.init.push(
        stmt(
          assignment(
            "=",
            member(id("$.document"), id("title")),
            literal2(node2.fragment.nodes[0].data)
          )
        )
      );
    } else {
      state.update.push({
        grouped: stmt(
          assignment(
            "=",
            member(id("$.document"), id("title")),
            serialize_template_literal(node2.fragment.nodes, visit)[1]
          )
        )
      });
    }
  },
  Body(node2, { state, visit }) {
    const next_state = { ...state, node: id("$.document.body") };
    for (const attribute of node2.attributes) {
      visit(attribute, next_state);
    }
  },
  Window(node2, { state, visit }) {
    const next_state = { ...state, node: id("$.window") };
    for (const attribute of node2.attributes) {
      visit(attribute, next_state);
    }
  },
  Document(node2, { state, visit }) {
    const next_state = { ...state, node: id("$.document") };
    for (const attribute of node2.attributes) {
      visit(attribute, next_state);
    }
  }
};
function add_select_to_spread_update(spread_id, node2, context, node_id) {
  if (spread_id !== null && node2.name === "select") {
    context.state.update.push({
      grouped: if_builder(
        binary("in", literal2("value"), id(spread_id)),
        block([
          stmt(call("$.select_option", node_id, member(id(spread_id), id("value"))))
        ])
      )
    });
  }
}
function serialize_transitive_dependencies(references, context) {
  const dependencies = /* @__PURE__ */ new Set();
  for (const ref2 of references) {
    const deps = collect_transitive_dependencies(ref2);
    for (const dep of deps) {
      dependencies.add(dep);
    }
  }
  return [...dependencies].map((dep) => serialize_get_binding2({ ...dep.node }, context.state));
}
function collect_transitive_dependencies(binding, seen = /* @__PURE__ */ new Set()) {
  if (binding.kind !== "legacy_reactive")
    return [];
  for (const dep of binding.legacy_dependencies) {
    if (!seen.has(dep)) {
      seen.add(dep);
      for (const transitive_dep of collect_transitive_dependencies(dep, seen)) {
        seen.add(transitive_dep);
      }
    }
  }
  return [...seen];
}
function collect_parent_each_blocks(context) {
  return context.path.filter((node2) => node2.type === "EachBlock");
}
function serialize_event_handler(node2, { state, visit }) {
  if (node2.expression) {
    let handler = node2.expression;
    const dynamic_handler = () => function_builder(
      null,
      [rest(id("$$args"))],
      block([
        const_builder("$$callback", visit(handler)),
        return_builder(
          call(member(id("$$callback"), id("apply"), false, true), this_instance, id("$$args"))
        )
      ])
    );
    if (handler.type === "Identifier" || handler.type === "MemberExpression") {
      const id2 = object2(handler);
      const binding = id2 === null ? null : state.scope.get(id2.name);
      if (binding !== null && (binding.kind === "state" || binding.kind === "legacy_reactive" || binding.kind === "derived" || binding.kind === "prop" || binding.kind === "store_sub")) {
        handler = dynamic_handler();
      } else {
        handler = visit(handler);
      }
    } else if (handler.type === "ConditionalExpression" || handler.type === "LogicalExpression") {
      handler = dynamic_handler();
    } else {
      handler = visit(handler);
    }
    if (node2.modifiers.includes("once")) {
      handler = call("$.once", handler);
    }
    if (node2.modifiers.includes("stopPropagation")) {
      handler = call("$.stopPropagation", handler);
    }
    if (node2.modifiers.includes("stopImmediatePropagation")) {
      handler = call("$.stopImmediatePropagation", handler);
    }
    if (node2.modifiers.includes("preventDefault")) {
      handler = call("$.preventDefault", handler);
    }
    if (node2.modifiers.includes("self")) {
      handler = call("$.self", handler);
    }
    if (node2.modifiers.includes("trusted")) {
      handler = call("$.trusted", handler);
    }
    return handler;
  } else {
    return function_builder(
      null,
      [id("$$arg")],
      block([stmt(call("$.bubble_event", id("$$events"), id("$$arg")))])
    );
  }
}
function serialize_inline_component2(node2, component_name, context) {
  const props_and_spreads = [];
  const default_lets = [];
  const children = {};
  const events = {};
  let bind_this = null;
  const push_prop = (prop2) => {
    const current2 = props_and_spreads.at(-1);
    const current_is_props = Array.isArray(current2);
    const props = current_is_props ? current2 : [];
    props.push(prop2);
    if (!current_is_props) {
      props_and_spreads.push(props);
    }
  };
  for (const attribute of node2.attributes) {
    if (attribute.type === "LetDirective") {
      default_lets.push(context.visit(attribute));
    } else if (attribute.type === "OnDirective") {
      events[attribute.name] = events[attribute.name] || [];
      events[attribute.name].push(serialize_event_handler(attribute, context));
    } else if (attribute.type === "Spread") {
      props_and_spreads.push(context.visit(attribute));
    } else if (attribute.type === "Attribute") {
      if (attribute.name === "slot")
        continue;
      const [, value2] = serialize_attribute_value2(attribute.value, context);
      if (context.state.analysis.dynamic_nodes.has(attribute)) {
        push_prop(get(attribute.name, [return_builder(value2)]));
      } else {
        push_prop(init(attribute.name, value2));
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "this") {
        bind_this = attribute.expression;
      } else {
        push_prop(
          get(attribute.name, [
            return_builder(
              call("$.exposable", thunk(context.visit(attribute.expression)))
            )
          ])
        );
        const binding = attribute.expression.type !== "Identifier" ? null : context.state.scope.get(attribute.expression.name);
        if (binding === null || binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "rest_prop") {
          const assignment2 = assignment("=", attribute.expression, id("$$value"));
          push_prop(
            set(attribute.name, [
              stmt(serialize_set_binding2(assignment2, context, () => assignment2))
            ])
          );
        }
      }
    }
  }
  for (const child of node2.fragment.nodes) {
    let slot_name = "default";
    if (is_element_node(child)) {
      const attribute = child.attributes.find(
        (attribute2) => attribute2.type === "Attribute" && attribute2.name === "slot"
      );
      if (attribute !== void 0) {
        slot_name = attribute.value[0].data;
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  const serialized_slots = [];
  for (const slot_name of Object.keys(children)) {
    const body = create_block2(node2, `${node2.name}_${slot_name}`, children[slot_name], context);
    if (body.length === 0)
      continue;
    const slot_name_valid_identifier = !/[^a-zA-Z0-9_$]/g.test(slot_name) && !/^[0-9]/.test(slot_name);
    const slot = prop(
      "init",
      slot_name_valid_identifier ? id(slot_name) : literal2(slot_name),
      arrow(
        [id("$$slotProps"), id("$$anchor")],
        block([...slot_name === "default" ? default_lets : [], ...body])
      ),
      !slot_name_valid_identifier
    );
    serialized_slots.push(slot);
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(props_and_spreads[0] || []) : call(
    "$.spread_props",
    thunk(array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p)))
  );
  const events_expression = object(
    Object.keys(events).map(
      (name8) => prop("init", id(name8), events[name8].length > 1 ? array(events[name8]) : events[name8][0])
    )
  );
  const component = call(
    component_name,
    context.state.node,
    props_expression,
    events_expression,
    object(serialized_slots)
  );
  if (bind_this !== null) {
    const assignment2 = assignment("=", bind_this, id("$$value"));
    return call(
      "$.bind_this",
      component,
      arrow(
        [id("$$value")],
        serialize_set_binding2(assignment2, context, () => context.visit(assignment2))
      )
    );
  } else {
    return component;
  }
}
function create_block2(parent, name8, nodes, context) {
  const template_name = context.state.scope.root.unique(name8);
  const body = [];
  const { hoisted, trimmed } = clean_nodes(
    parent,
    nodes,
    context.path,
    context.state.metadata.namespace,
    context.state.preserve_whitespace,
    false
  );
  if (hoisted.length === 0 && (trimmed.length === 0 || !context.state.analysis.preserve_comments && trimmed.every((node2) => node2.type === "Comment"))) {
    return [];
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === "SlotTemplate" || trimmed[0].type === "Title");
  let close2 = void 0;
  let id2 = void 0;
  const state = {
    ...context.state,
    init: [],
    update: [],
    update_effects: [],
    after_update: [],
    template: [],
    metadata: {
      namespace: context.state.metadata.namespace
    }
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_single_element) {
    const element = trimmed[0];
    id2 = id(context.state.scope.generate(element.name));
    context.visit(element, {
      ...state,
      node: id2
    });
    const callee = state.metadata.namespace === "svg" ? "$.svg_template" : "$.template";
    context.state.hoisted.push(
      const_builder(
        template_name,
        call(callee, template([quasi(state.template.join(""), true)], []))
      )
    );
    body.push(var_builder(id2.name, call("$.open", id("$$anchor"), template_name)), ...state.init);
    close2 = stmt(call("$.close", id("$$anchor"), id2));
  } else if (is_single_child_not_needing_template) {
    context.visit(trimmed[0], state);
    body.push(...state.init);
  } else {
    id2 = id(context.state.scope.generate("fragment"));
    process_children2(trimmed, call("$.child_frag", id2), {
      ...context,
      state
    });
    if (state.template.length > 0) {
      const callee = state.metadata.namespace === "svg" ? "$.svg_template" : "$.template";
      state.hoisted.push(
        var_builder(
          template_name,
          call(callee, template([quasi(state.template.join(""), true)], []), true_instance)
        )
      );
      body.push(
        var_builder(id2.name, call("$.open_frag", id("$$anchor"), template_name)),
        ...state.init
      );
      close2 = stmt(call("$.close_frag", id("$$anchor"), id2));
    } else {
      body.push(...state.init);
    }
  }
  if (state.update.length > 0 || state.update_effects.length > 0) {
    let update2;
    if (state.update_effects.length > 0) {
      for (const render of state.update_effects) {
        if (!update2) {
          update2 = render;
        }
        body.push(render);
      }
    }
    if (state.update.length > 0) {
      let render;
      if (state.update.length === 1 && state.update[0].singular) {
        render = state.update[0].singular;
      } else {
        render = stmt(
          call(
            "$.render_effect",
            thunk(
              block(
                state.update.map((n2) => {
                  if (n2.init) {
                    body.push(n2.init);
                  }
                  return n2.grouped;
                })
              )
            )
          )
        );
      }
      if (!update2) {
        update2 = render;
      }
      body.push(render);
    }
    update2.leadingComments = [
      {
        type: "Block",
        value: ` Update `,
        // @ts-expect-error
        has_trailing_newline: true
      }
    ];
  }
  body.push(...state.after_update);
  if (close2 !== void 0) {
    body.push(close2);
  }
  if (body[0]) {
    body[0].leadingComments = [
      {
        type: "Block",
        value: ` Init `,
        // @ts-expect-error
        has_trailing_newline: true
      }
    ];
  }
  return body;
}
function process_children2(nodes, parent, { visit, state, path }) {
  let contains_reactive_references = false;
  for (const [reference] of state.scope.references) {
    const binding = state.scope.get(reference);
    if (binding !== null && (binding.kind !== "normal" || binding.is_used_as_member)) {
      contains_reactive_references = true;
    }
  }
  let sequence2 = [];
  let expression = parent;
  function flush_sequence(sequence3, final) {
    if (sequence3.length === 1) {
      const node2 = sequence3[0];
      if (node2.type === "Text") {
        expression = call("$.sibling", expression);
        state.template.push(node2.raw);
        return;
      }
      state.template.push(" ");
      const name9 = state.scope.generate("text");
      state.init.push(var_builder(name9, expression));
      const singular2 = stmt(
        call("$.text", id(name9), thunk(visit(node2.expression)))
      );
      if (node2.metadata.contains_call_expression) {
        state.update_effects.push(singular2);
      } else if (!contains_reactive_references) {
        state.init.push(
          stmt(
            assignment(
              "=",
              id(`${name9}.nodeValue`),
              call("$.stringify", visit(node2.expression))
            )
          )
        );
      } else {
        state.update.push({
          singular: singular2,
          grouped: stmt(
            assignment(
              "=",
              id(`${name9}.nodeValue`),
              call("$.stringify", visit(node2.expression))
            )
          )
        });
      }
      return;
    }
    state.template.push(" ");
    const name8 = state.scope.generate("text");
    const contains_call_expression = sequence3.some(
      (n2) => n2.type === "MustacheTag" && n2.metadata.contains_call_expression
    );
    state.init.push(var_builder(name8, expression));
    const grouped = stmt(
      assignment("=", id(`${name8}.nodeValue`), serialize_template_literal(sequence3, visit)[1])
    );
    const singular = stmt(
      call("$.text", id(name8), thunk(serialize_template_literal(sequence3, visit)[1]))
    );
    if (!contains_reactive_references && !contains_call_expression) {
      state.init.push(grouped);
    } else if (contains_call_expression) {
      state.update_effects.push(singular);
    } else {
      state.update.push({
        singular,
        grouped
      });
    }
    expression = call("$.sibling", id(name8));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node2 = nodes[i];
    if (node2.type === "Text" || node2.type === "MustacheTag") {
      sequence2.push(node2);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2, false);
        sequence2 = [];
      }
      if (node2.type === "Head") {
        visit(node2, state);
      } else {
        const name8 = state.scope.generate(node2.type === "RegularElement" ? node2.name : "node");
        const id2 = id(name8);
        if (node2.type === "EachBlock" && nodes.length === 1 && parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "$.child") {
          node2.metadata.is_controlled = true;
          visit(node2, state);
        } else {
          state.init.push(var_builder(name8, expression));
          expression = call("$.sibling", id2);
          visit(node2, {
            ...state,
            node: id2
          });
        }
      }
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2, true);
  }
}
function create_state_declarators2(declarator2, scope, value2) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, call("$.source", value2))];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value2),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path) => {
      const value3 = path.expression(id(tmp));
      const binding = scope.get(path.node.name);
      return declarator(path.node, binding?.kind === "state" ? call("$.source", value3) : value3);
    })
  ];
}
function get_delegated_params(node2, context) {
  const scope = context.state.scope;
  const params = [];
  for (const [reference] of scope.references) {
    const binding = scope.get(reference);
    if (binding !== null && !scope.declarations.has(reference) && binding.initial !== node2) {
      if (binding.kind === "store_sub") {
        params.push(id(binding.node.name.slice(1)));
        params.push(id(binding.node.name));
      } else {
        params.push(binding.node);
      }
    }
  }
  return params;
}
function serialize_delegated_params(node2, context) {
  const delegated_params = get_delegated_params(node2, context);
  node2.metadata.delegated_params = delegated_params;
  const params = [];
  if (node2.params.length === 0) {
    if (delegated_params.length > 0) {
      params.push(id("_"));
    }
  } else {
    for (const param of node2.params) {
      params.push(context.visit(param));
    }
  }
  params.push(...delegated_params);
  return params;
}
function serialize_get_binding2(node2, state) {
  const binding = state.scope.get(node2.name);
  if (binding === null || node2 === binding.node) {
    return node2;
  }
  if (binding.kind === "store_sub") {
    return call(node2);
  }
  if (binding.expression) {
    return binding.expression;
  }
  if (binding.kind === "prop" && binding.node.name === "$$props") {
    return call("$.unwrap", node2);
  }
  if (binding.kind === "prop" && !binding.mutated && !state.analysis.accessors) {
    return call(node2);
  }
  if (binding.kind === "state" || binding.kind === "derived" || binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "legacy_reactive") {
    return call("$.get", node2);
  }
  return node2;
}
function serialize_attribute_value2(attribute_value, context) {
  let contains_call_expression = false;
  if (attribute_value === true) {
    return [contains_call_expression, literal2(true)];
  }
  if (attribute_value.length === 0) {
    return [contains_call_expression, literal2("")];
  }
  if (attribute_value.length === 1) {
    const value2 = attribute_value[0];
    if (value2.type === "Text") {
      return [contains_call_expression, literal2(value2.data)];
    } else {
      if (value2.type === "MustacheTag") {
        contains_call_expression = value2.metadata.contains_call_expression;
      }
      return [contains_call_expression, context.visit(value2.expression)];
    }
  }
  return serialize_template_literal(attribute_value, context.visit);
}
function serialize_template_literal(values, visit) {
  const quasis = [];
  const expressions = [];
  let contains_call_expression = false;
  quasis.push(quasi(""));
  for (let i = 0; i < values.length; i++) {
    const node2 = values[i];
    if (node2.type === "Text") {
      quasis.at(-1).value.raw += node2.data;
    } else {
      if (node2.type === "MustacheTag" && node2.metadata.contains_call_expression) {
        contains_call_expression = true;
      }
      expressions.push(call("$.stringify", visit(node2.expression)));
      quasis.push(quasi("", i + 1 === values.length));
    }
  }
  return [contains_call_expression, template(quasis, expressions)];
}
function dom_component(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    scopes: analysis.template.scopes,
    hoisted: [import_all("$", "svelte-experimental/internal")],
    node: null,
    // populated by the root node
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called outside create_block");
      return a;
    },
    get update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update.push should not be called outside create_block");
      return a;
    },
    get update_effects() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update_effects.push should not be called outside create_block");
      return a;
    },
    get after_update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "after_update.push should not be called outside create_block");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called outside create_block");
      return a;
    },
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      namespace: analysis.namespace
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = walk(analysis.module.ast, state, {
    ...set_scope(analysis.module.scopes),
    ...global_visitors2,
    ...javascript_visitors2,
    ...analysis.runes ? javascript_visitors_runes2 : javascript_visitors_legacy2
  });
  const instance_state = { ...state, scope: analysis.instance.scope };
  const instance = walk(analysis.instance.ast, instance_state, {
    ...set_scope(analysis.instance.scopes),
    ...global_visitors2,
    ...javascript_visitors2,
    ...analysis.runes ? javascript_visitors_runes2 : javascript_visitors_legacy2,
    ImportDeclaration(node2, { state: state2 }) {
      state2.hoisted.push(node2);
      return { type: "EmptyStatement" };
    },
    ExportNamedDeclaration(node2, { visit }) {
      if (node2.declaration) {
        return visit(node2.declaration);
      }
      return empty2;
    }
  });
  const template2 = walk(
    analysis.template.ast,
    { ...state, scope: analysis.instance.scope },
    {
      ...set_scope(analysis.template.scopes),
      ...global_visitors2,
      ...template_visitors2
    }
  );
  const store_setup = [];
  const legacy_reactive_declarations = [];
  for (const [name8, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(const_builder(name8, call("$.source")));
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        store_setup.push(
          const_builder("$$subscriptions", object([])),
          stmt(call("$.unsubscribe_on_destroy", id("$$subscriptions")))
        );
      }
      const store_reference = serialize_get_binding2(id(name8.slice(1)), instance_state);
      const store_get = call(
        "$.store_get",
        store_reference,
        literal2(name8),
        id("$$subscriptions")
      );
      store_setup.push(
        const_builder(
          binding.node,
          analysis.dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal2(name8.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node2] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node2);
    if (statement === void 0) {
      error(node2, "INTERNAL", "Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const static_bindings = analysis.exports.map(({ name: name8, alias }) => {
    const binding = analysis.instance.scope.get(name8);
    return stmt(
      call(
        "$.bind_prop",
        id("$$props"),
        literal2(alias ?? name8),
        binding?.kind === "state" ? call("$.get", id(name8)) : id(name8)
      )
    );
  });
  const component_block = block([
    stmt(
      call(
        "$.push",
        id("$$events"),
        literal2(analysis.runes),
        ...analysis.immutable ? [literal2(true)] : []
      )
    ),
    ...store_setup,
    ...legacy_reactive_declarations,
    ...group_binding_declarations,
    ...instance.body,
    ...template2.body,
    ...static_bindings,
    stmt(call("$.pop"))
  ]);
  const properties = analysis.exports.map(({ name: name8, alias }) => {
    const binding = analysis.instance.scope.get(name8);
    return get(alias ?? name8, [
      return_builder(binding?.kind === "state" ? call("$.get", id(name8)) : id(name8))
    ]);
  });
  if (analysis.accessors) {
    for (const [name8, binding] of analysis.instance.scope.declarations) {
      if (binding.kind !== "prop")
        continue;
      const key2 = binding.prop_alias ?? name8;
      properties.push(
        get(key2, [return_builder(call("$.get", id(name8)))]),
        set(key2, [stmt(call("$.set_sync", id(name8), id("$$value")))])
      );
    }
  }
  if (properties.length > 0) {
    component_block.body.push(return_builder(object(properties)));
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name: name8, alias }) => alias ?? name8);
    for (const [name8, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "prop")
        named_props.push(binding.prop_alias ?? name8);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call("$.rest_props", id("$$props"), array(named_props.map((name8) => literal2(name8))))
      )
    );
  }
  const body = [
    ...state.hoisted,
    ...module.body,
    export_default(
      function_declaration(
        id(analysis.name),
        [id("$$anchor"), id("$$props"), id("$$events"), id("$$slots")],
        component_block
      )
    )
  ];
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name8) => literal2(name8)))))
    );
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function dom_module(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    scopes: analysis.template.scopes,
    hoisted: [import_all("$", "svelte-experimental/internal")],
    node: null,
    // populated by the root node
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called");
      return a;
    },
    get update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update.push should not be called");
      return a;
    },
    get update_effects() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update_effects.push should not be called outside create_block");
      return a;
    },
    get after_update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "after_update.push should not be called");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called");
      return a;
    },
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      namespace: analysis.namespace
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = walk(analysis.module.ast, state, {
    ...set_scope(analysis.module.scopes),
    ...global_visitors2,
    ...javascript_visitors2,
    ...analysis.runes ? javascript_visitors_runes2 : javascript_visitors_legacy2
  });
  return {
    type: "Program",
    sourceType: "module",
    body: [...state.hoisted, ...module.body]
  };
}

// ../../node_modules/.pnpm/locate-character@3.0.0/node_modules/locate-character/src/index.js
function rangeContains(range, index) {
  return range.start <= index && index < range.end;
}
function getLocator2(source, options = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options;
  let start = 0;
  const ranges = source.split("\n").map((line, i2) => {
    const end = start + line.length + 1;
    const range = { start, end, line: i2 };
    start = end;
    return range;
  });
  let i = 0;
  function locator(search, index) {
    if (typeof search === "string") {
      search = source.indexOf(search, index ?? 0);
    }
    if (search === -1)
      return void 0;
    let range = ranges[i];
    const d2 = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search)) {
        return {
          line: offsetLine + range.line,
          column: offsetColumn + search - range.start,
          character: search
        };
      }
      i += d2;
      range = ranges[i];
    }
  }
  return locator;
}

// src/compiler/utils/frame.js
function frame(filename, source, start, end) {
  let out = "";
  if (filename) {
    out = `
${filename}:${start.line + 1}:${start.column + 1}`;
  }
  const lines = source.split("\n").slice(start.line, end.line + 1);
  if (lines.length === 1) {
    let num_tabs = 0;
    const line = lines[0].replace(/^\t+/, (m) => {
      num_tabs = m.length;
      return "  ".repeat(num_tabs);
    });
    const a = start.column + Math.min(start.column, num_tabs);
    const b2 = end.column + Math.min(end.column, num_tabs);
    out += `
${line}`;
    out += `
${" ".repeat(a) + "^".repeat(b2 - a)}`;
  } else {
    out += `
${lines.join("\n")}`;
  }
  return out;
}

// src/compiler/phases/3-transform/index.ts
function transform_component(analysis, source, options) {
  const program = options.generate === "ssr" ? ssr_component(analysis) : dom_component(analysis);
  const basename = (options.filename ?? "Component").split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Line",
        value: ` ${basename} (Svelte v${VERSION})`,
        // @ts-ignore
        has_trailing_newline: true
      },
      {
        type: "Line",
        value: " Note: compiler output will change before 5.0 is released!",
        // @ts-ignore
        has_trailing_newline: true
      }
    ];
  }
  return {
    js: print(program, { sourceMapSource: options.filename }),
    // TODO needs more logic to apply map from preprocess
    css: analysis.stylesheet.has_styles ? analysis.stylesheet.render(options.filename ?? "TODO", source, analysis.dev) : null,
    warnings: transform_warnings(source, analysis)
  };
}
function transform_module(analysis, source, options) {
  const program = options.generate === "ssr" ? ssr_module(analysis) : dom_module(analysis);
  const basename = (options.filename ?? "Module").split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Block",
        value: ` ${basename} generated by Svelte v${VERSION} `,
        // @ts-ignore
        has_trailing_newline: true
      }
    ];
  }
  return {
    js: print(program, {}),
    css: null,
    warnings: transform_warnings(source, analysis)
  };
}
function transform_warnings(source, analysis) {
  if (analysis.warnings.length === 0)
    return [];
  const locate = getLocator2(source);
  const result = [];
  for (const warning of analysis.warnings) {
    const start = warning.start ? locate(warning.start) : void 0;
    const end = warning.end ? locate(warning.end) : void 0;
    result.push({
      start: start && { line: start.line + 1, column: start.column + 1 },
      end: end && { line: end.line + 1, column: end.column + 1 },
      filename: analysis.name,
      frame: start && end && frame(analysis.name, source, start, end),
      message: warning.message,
      code: warning.code
    });
  }
  return result;
}

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/aliases.mjs
var clean = (obj) => Object.assign(/* @__PURE__ */ Object.create(null), obj);
var aliases = clean({
  Function: clean({
    FunctionDeclaration: 0,
    FunctionExpression: 0,
    ArrowFunctionExpression: 0
  }),
  Statement: clean({
    FunctionDeclaration: 0,
    ExpressionStatement: 0,
    BlockStatement: 0,
    EmptyStatement: 0,
    DebuggerStatement: 0,
    WithStatement: 0,
    ReturnStatement: 0,
    LabeledStatement: 0,
    BreakStatement: 0,
    ContinueStatement: 0,
    IfStatement: 0,
    SwitchStatement: 0,
    ThrowStatement: 0,
    TryStatement: 0,
    WhileStatement: 0,
    DoWhileStatement: 0,
    ForStatement: 0,
    ForInStatement: 0,
    ForOfStatement: 0,
    VariableDeclaration: 0,
    ClassDeclaration: 0,
    StaticBlock: 0
  }),
  Declaration: clean({
    FunctionDeclaration: 0,
    VariableDeclaration: 0,
    ClassDeclaration: 0
  }),
  Expression: clean({
    FunctionExpression: 0,
    ArrowFunctionExpression: 0,
    ClassExpression: 0,
    CallExpression: 0,
    ConditionalExpression: 0,
    ChainExpression: 0,
    Identifier: 0,
    Literal: 0,
    ThisExpression: 0,
    ArrayExpression: 0,
    ObjectExpression: 0,
    YieldExpression: 0,
    UnaryExpression: 0,
    UpdateExpression: 0,
    BinaryExpression: 0,
    AssignmentExpression: 0,
    LogicalExpression: 0,
    MemberExpression: 0,
    NewExpression: 0,
    SequenceExpression: 0,
    TemplateLiteral: 0,
    TaggedTemplateExpression: 0,
    MetaProperty: 0,
    AwaitExpression: 0,
    ImportExpression: 0,
    JSXElement: 0
  }),
  Pattern: clean({
    Identifier: 0,
    MemberExpression: 0,
    ObjectPattern: 0,
    ArrayPattern: 0,
    RestElement: 0,
    AssignmentPattern: 0
  }),
  Class: clean({
    ClassDeclaration: 0,
    ClassExpression: 0
  }),
  ExportDeclaration: clean({
    ExportNamedDeclaration: 0,
    ExportDefaultDeclaration: 0,
    ExportAllDeclaration: 0
  }),
  Loop: clean({
    ForStatement: 0,
    ForInStatement: 0,
    ForOfStatement: 0,
    WhileStatement: 0,
    DoWhileStatement: 0
  }),
  ModuleDeclaration: clean({
    ExportAllDeclaration: 0,
    ExportDefaultDeclaration: 0,
    ExportNamedDeclaration: 0,
    ImportDeclaration: 0
  })
});

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/assert.mjs
var runValidation = (validateFn, value2) => {
  const errorMsg = validateFn(value2);
  if (errorMsg != null) {
    throw new Error(errorMsg);
  }
};
var chain = (...validateFns) => validateFns.reduce((prevFn, fn2) => (val) => prevFn(val) || fn2(val));
var OR = (...validateFns) => (value2) => {
  const errorMsgs = [];
  for (let i = 0; i < validateFns.length; i++) {
    const errorMsg = validateFns[i](value2);
    if (errorMsg != null) {
      errorMsgs.push(errorMsg);
    } else {
      break;
    }
  }
  if (errorMsgs.length === validateFns.length) {
    return `The value is not compatible with the required type.

Messages:
${errorMsgs.join("\n")}`;
  }
  return null;
};
var meaningfulType = (value2) => {
  if (value2 === null) {
    return "null";
  } else if (Array.isArray(value2)) {
    return "array";
  } else {
    return typeof value2;
  }
};
var value = (...types2) => {
  if (types2.length === 1) {
    const type = types2[0];
    return function validate(value2) {
      if (typeof value2 !== type) {
        return `Expected the value to be a \`${type}\` but got a \`${meaningfulType(value2)}\`. The value is ${JSON.stringify(value2)}.`;
      }
      return null;
    };
  } else {
    return function validate(value2) {
      for (let i = 0; i < types2.length; i++) {
        const type = types2[i];
        if (typeof value2 === type || type === "null" && value2 === null) {
          return null;
        }
      }
      return `Expected the value to be one of \`${JSON.stringify(types2)}\` but got a \`${meaningfulType(value2)}\`. The value is ${JSON.stringify(value2)}.`;
    };
  }
};
var reservedKeywords = new Set(`
do if in for let new try var case else enum
eval false null undefined NaN this true void
with break catch class const super throw while
yield delete export import public return static
switch typeof default extends finally package
private continue debugger function arguments
interface protected implements instanceof
`.trim().split(/[ \n]/).map((s) => s.trim()));
var isReserved = (name8) => reservedKeywords.has(name8);
var validIdentifier = (jsx) => (name8) => {
  if ((jsx ? /[\s]/ : /[-\s]/).test(name8) || /^\d/.test(name8) || name8.length === 0) {
    return `${JSON.stringify(name8)} is not a valid identifier.`;
  }
  return null;
};
var nonNull = (value2) => {
  if (value2 == null) {
    return "Expected the value to be non-null but got null or undefined value.";
  }
  return null;
};
var node = (...types2) => {
  if (types2.length === 1) {
    const type = types2[0];
    return (value2) => {
      if (value2 == null || value2.type !== type) {
        return `Expected a "${type}" node but got a \`${meaningfulType(value2)}\`. The value is ${JSON.stringify(value2)}.`;
      }
      return null;
    };
  } else {
    return (value2) => {
      if (types2.indexOf(value2.type) === -1) {
        return `Expected one of (${types2.join()}) node but got a \`${meaningfulType(value2)}\`. The value is ${JSON.stringify(value2)}.`;
      }
      return null;
    };
  }
};
var nodeAlias = (alias) => (value2) => {
  if (value2 == null || !(value2.type in aliases[alias])) {
    return `Expected one of (${Object.keys(aliases[alias]).join()}) node but got a \`${meaningfulType(value2)}\`. The value is ${JSON.stringify(value2)}.`;
  }
  return null;
};
var any = () => null;
var arrayOf = (validateFn) => (value2) => {
  if (Array.isArray(value2)) {
    let errorMsg;
    for (let i = 0; i < value2.length; i++) {
      errorMsg = validateFn(value2[i]);
      if (errorMsg != null)
        return `Got unexpected value at index ${i}:
  ${errorMsg}`;
    }
    return null;
  } else {
    return `Expected the value to be an array but got a \`${meaningfulType(value2)}\`. The value is ${JSON.stringify(value2)}.`;
  }
};
var oneOf = (items) => (value2) => {
  if (!items.includes(value2)) {
    return `Expected the value to be one of ${JSON.stringify(items)}, but got ${JSON.stringify(value2)}`;
  }
  return null;
};
var nullable = (validateFn) => (value2) => {
  if (value2 === null) {
    return null;
  }
  return validateFn(value2);
};

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/definitions.mjs
var anyValidate = {
  validate: any
};
var definitions = Object.assign(/* @__PURE__ */ Object.create(null), {
  Identifier: {
    indices: {
      name: [0, false]
    },
    fields: {
      name: {
        validate: chain(value("string"), validIdentifier(false))
      }
    },
    insertionValidate(node2, key2, listKey, parent) {
      if (parent.type === "MemberExpression" && !parent.computed && key2 === "property" || (parent.type === "Property" || parent.type === "MethodDefinition") && !parent.computed && key2 === "key" || parent.type === "ExportSpecifier" && key2 === "exported" || parent.type === "ImportSpecifier" && key2 === "imported" || parent.type === "MetaProperty" && (key2 === "meta" && node2.name === "import" || key2 === "property" && node2.name === "meta")) {
        return null;
      }
      if (isReserved(node2.name)) {
        return `${JSON.stringify(node2.name)} is not a valid identifier.`;
      }
      return null;
    }
  },
  Literal: {
    indices: {
      value: [0, false],
      raw: false
    },
    fields: {
      value: {
        // ts-expect-error Practically RegExp would never appear here
        validate: value("string", "number", "bigint", "boolean", "null")
      },
      raw: anyValidate
    }
  },
  Program: {
    indices: {
      body: 0,
      sourceType: [1, false],
      comments: [2, false]
    },
    fields: {
      body: {
        validate: arrayOf(OR(nodeAlias("Statement"), nodeAlias("ModuleDeclaration")))
      },
      sourceType: {
        default: "module",
        validate: value("string")
      },
      comments: { default: [], ...anyValidate }
    }
  },
  FunctionDeclaration: {
    indices: {
      id: 0,
      params: 1,
      body: 2,
      generator: [3, false],
      async: [4, false]
    },
    fields: {
      id: {
        validate: nullable(node("Identifier"))
      },
      params: {
        validate: arrayOf(nodeAlias("Pattern"))
      },
      body: {
        validate: node("BlockStatement")
      },
      generator: {
        default: false,
        validate: value("boolean")
      },
      async: {
        default: false,
        validate: value("boolean")
      }
    }
  },
  FunctionExpression: {
    indices: {
      id: 0,
      params: 1,
      body: 2,
      generator: [3, false],
      async: [4, false]
    },
    fields: {
      id: {
        validate: nullable(node("Identifier"))
      },
      params: {
        validate: arrayOf(nodeAlias("Pattern"))
      },
      body: {
        validate: node("BlockStatement")
      },
      generator: {
        default: false,
        validate: value("boolean")
      },
      async: {
        default: false,
        validate: value("boolean")
      }
    }
  },
  ArrowFunctionExpression: {
    indices: {
      params: 0,
      body: 1,
      expression: [2, false],
      async: [3, false],
      generator: false
    },
    fields: {
      params: {
        validate: arrayOf(nodeAlias("Pattern"))
      },
      body: {
        validate: OR(node("BlockStatement"), nodeAlias("Expression"))
      },
      expression: {
        default: false,
        validate: value("boolean")
      },
      async: {
        default: false,
        validate: value("boolean")
      },
      generator: anyValidate
    }
  },
  SwitchCase: {
    indices: {
      test: 0,
      consequent: 1
    },
    fields: {
      test: {
        validate: nullable(nodeAlias("Expression"))
      },
      consequent: {
        validate: arrayOf(nodeAlias("Statement"))
      }
    }
  },
  CatchClause: {
    indices: {
      param: 0,
      body: 1
    },
    fields: {
      param: {
        validate: nullable(nodeAlias("Pattern"))
      },
      body: {
        validate: node("BlockStatement")
      }
    }
  },
  VariableDeclarator: {
    indices: {
      id: 0,
      init: 1
    },
    fields: {
      id: {
        validate: nodeAlias("Pattern")
      },
      init: {
        default: null,
        validate: nullable(nodeAlias("Expression"))
      }
    }
  },
  ExpressionStatement: {
    indices: {
      expression: 0
    },
    fields: {
      expression: {
        validate: nodeAlias("Expression")
      }
    }
  },
  BlockStatement: {
    indices: {
      body: 0,
      innerComments: false
    },
    fields: {
      body: {
        validate: arrayOf(nodeAlias("Statement"))
      },
      innerComments: anyValidate
    }
  },
  EmptyStatement: {
    indices: {},
    fields: {}
  },
  DebuggerStatement: {
    indices: {},
    fields: {}
  },
  WithStatement: {
    indices: {
      object: 0,
      body: 1
    },
    fields: {
      object: {
        validate: nodeAlias("Expression")
      },
      body: {
        validate: nodeAlias("Statement")
      }
    }
  },
  ReturnStatement: {
    indices: {
      argument: 0
    },
    fields: {
      argument: {
        default: null,
        validate: nullable(nodeAlias("Expression"))
      }
    }
  },
  LabeledStatement: {
    indices: {
      label: 0,
      body: 1
    },
    fields: {
      label: {
        validate: node("Identifier")
      },
      body: {
        validate: nodeAlias("Statement")
      }
    }
  },
  BreakStatement: {
    indices: {
      label: 0
    },
    fields: {
      label: {
        default: null,
        validate: nullable(node("Identifier"))
      }
    }
  },
  ContinueStatement: {
    indices: {
      label: 0
    },
    fields: {
      label: {
        default: null,
        validate: nullable(node("Identifier"))
      }
    }
  },
  IfStatement: {
    indices: {
      test: 0,
      consequent: 1,
      alternate: 2
    },
    fields: {
      test: {
        validate: nodeAlias("Expression")
      },
      consequent: {
        validate: nodeAlias("Statement")
      },
      alternate: {
        default: null,
        validate: nullable(nodeAlias("Statement"))
      }
    }
  },
  SwitchStatement: {
    indices: {
      discriminant: 0,
      cases: 1
    },
    fields: {
      discriminant: {
        validate: nodeAlias("Expression")
      },
      cases: {
        validate: arrayOf(node("SwitchCase"))
      }
    }
  },
  ThrowStatement: {
    indices: {
      argument: 0
    },
    fields: {
      argument: {
        validate: nodeAlias("Expression")
      }
    }
  },
  TryStatement: {
    indices: {
      block: 0,
      handler: 1,
      finalizer: 2
    },
    fields: {
      block: {
        validate: node("BlockStatement")
      },
      handler: {
        validate: nullable(node("CatchClause"))
      },
      finalizer: {
        default: null,
        validate: nullable(node("BlockStatement"))
      }
    },
    finalValidate(node2) {
      if (node2.handler == null && node2.finalizer == null) {
        return "If `handler` is null then `finalizer` must be not null";
      }
      return null;
    }
  },
  WhileStatement: {
    indices: {
      test: 0,
      body: 1
    },
    fields: {
      test: {
        validate: nodeAlias("Expression")
      },
      body: {
        validate: nodeAlias("Statement")
      }
    }
  },
  DoWhileStatement: {
    indices: {
      test: 0,
      body: 1
    },
    fields: {
      test: {
        validate: nodeAlias("Expression")
      },
      body: {
        validate: nodeAlias("Statement")
      }
    }
  },
  ForStatement: {
    indices: {
      init: 0,
      test: 1,
      update: 2,
      body: 3
    },
    fields: {
      init: {
        validate: nullable(OR(node("VariableDeclaration"), nodeAlias("Expression")))
      },
      test: {
        validate: nullable(nodeAlias("Expression"))
      },
      update: {
        validate: nullable(nodeAlias("Expression"))
      },
      body: {
        validate: nodeAlias("Statement")
      }
    }
  },
  ForInStatement: {
    indices: {
      left: 0,
      right: 1,
      body: 2
    },
    fields: {
      left: {
        validate: OR(node("VariableDeclaration"), nodeAlias("Pattern"))
      },
      right: {
        validate: nodeAlias("Expression")
      },
      body: {
        validate: nodeAlias("Statement")
      }
    }
  },
  ForOfStatement: {
    indices: {
      left: 0,
      right: 1,
      body: 2,
      await: [3, false]
    },
    fields: {
      left: {
        validate: OR(node("VariableDeclaration"), nodeAlias("Pattern"))
      },
      right: {
        validate: nodeAlias("Expression")
      },
      body: {
        validate: nodeAlias("Statement")
      },
      await: {
        validate: value("boolean")
      }
    }
  },
  VariableDeclaration: {
    indices: {
      kind: [0, false],
      declarations: 1
    },
    fields: {
      kind: {
        validate: oneOf(["var", "let", "const"])
      },
      declarations: {
        validate: arrayOf(node("VariableDeclarator"))
      }
    }
  },
  ClassDeclaration: {
    indices: {
      id: 0,
      body: 2,
      superClass: [3, 1]
    },
    fields: {
      id: {
        validate: nullable(node("Identifier"))
      },
      body: {
        validate: node("ClassBody")
      },
      superClass: {
        default: null,
        validate: nullable(nodeAlias("Expression"))
      }
    }
  },
  ThisExpression: {
    indices: {},
    fields: {}
  },
  ArrayExpression: {
    indices: {
      elements: 0
    },
    fields: {
      elements: {
        validate: arrayOf(nullable(OR(nodeAlias("Expression"), node("SpreadElement"))))
      }
    }
  },
  ObjectExpression: {
    indices: {
      properties: 0
    },
    fields: {
      properties: {
        validate: arrayOf(node("Property", "SpreadElement"))
      }
    }
  },
  YieldExpression: {
    indices: {
      argument: 0,
      delegate: [1, false]
    },
    fields: {
      argument: {
        validate: nullable(nodeAlias("Expression"))
      },
      delegate: {
        default: false,
        validate: value("boolean")
      }
    }
  },
  UnaryExpression: {
    indices: {
      operator: [0, false],
      argument: 1,
      prefix: [2, false]
    },
    fields: {
      operator: {
        validate: oneOf(["-", "+", "!", "~", "typeof", "void", "delete"])
      },
      argument: {
        validate: nodeAlias("Expression")
      },
      prefix: {
        default: true,
        validate: value("boolean")
      }
    }
  },
  UpdateExpression: {
    indices: {
      operator: [0, false],
      argument: 1,
      prefix: [2, false]
    },
    fields: {
      operator: {
        validate: oneOf(["++", "--"])
      },
      argument: {
        validate: nodeAlias("Expression")
      },
      prefix: {
        validate: value("boolean")
      }
    }
  },
  BinaryExpression: {
    indices: {
      operator: [0, false],
      left: 1,
      right: 2
    },
    fields: {
      operator: {
        validate: oneOf([
          "==",
          "!=",
          "===",
          "!==",
          "<",
          "<=",
          ">",
          ">=",
          "<<",
          ">>",
          ">>>",
          "+",
          "-",
          "*",
          "/",
          "%",
          "**",
          "|",
          "^",
          "&",
          "in",
          "instanceof"
        ])
      },
      left: {
        validate: nodeAlias("Expression")
      },
      right: {
        validate: nodeAlias("Expression")
      }
    }
  },
  AssignmentExpression: {
    indices: {
      operator: [0, false],
      left: 1,
      right: 2
    },
    fields: {
      operator: {
        validate: oneOf([
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "**=",
          "<<=",
          ">>=",
          ">>>=",
          "|=",
          "^=",
          "&=",
          "||=",
          "&&=",
          "??="
        ])
      },
      left: {
        validate: nodeAlias("Pattern")
      },
      right: {
        validate: nodeAlias("Expression")
      }
    }
  },
  LogicalExpression: {
    indices: {
      operator: [0, false],
      left: 1,
      right: 2
    },
    fields: {
      operator: {
        validate: oneOf(["||", "&&", "??"])
      },
      left: {
        validate: nodeAlias("Expression")
      },
      right: {
        validate: nodeAlias("Expression")
      }
    }
  },
  MemberExpression: {
    indices: {
      object: 0,
      property: 1,
      computed: [2, false],
      optional: [3, false]
    },
    fields: {
      object: {
        validate: OR(nodeAlias("Expression"), node("Super"))
      },
      property: {
        validate: OR(nodeAlias("Expression"), node("PrivateIdentifier"))
      },
      computed: {
        default: false,
        validate: value("boolean")
      },
      optional: {
        default: false,
        validate: value("boolean")
      }
    }
  },
  ConditionalExpression: {
    indices: {
      test: 0,
      consequent: 1,
      alternate: 2
    },
    fields: {
      test: {
        validate: nodeAlias("Expression")
      },
      consequent: {
        validate: nodeAlias("Expression")
      },
      alternate: {
        validate: nodeAlias("Expression")
      }
    }
  },
  CallExpression: {
    indices: {
      callee: 0,
      arguments: 1,
      optional: [2, false]
    },
    fields: {
      callee: {
        validate: OR(nodeAlias("Expression"), node("Super"))
      },
      arguments: {
        validate: arrayOf(OR(nodeAlias("Expression"), node("SpreadElement")))
      },
      optional: {
        type: "boolean",
        default: false,
        validate: value("boolean")
      }
    }
  },
  NewExpression: {
    indices: {
      callee: 0,
      arguments: 1
    },
    fields: {
      callee: {
        validate: OR(nodeAlias("Expression"), node("Super"))
      },
      arguments: {
        validate: arrayOf(OR(nodeAlias("Expression"), node("SpreadElement")))
      }
    }
  },
  SequenceExpression: {
    indices: {
      expressions: 0
    },
    fields: {
      expressions: {
        validate: arrayOf(nodeAlias("Expression"))
      }
    }
  },
  TemplateLiteral: {
    indices: {
      quasis: 0,
      expressions: 1
    },
    fields: {
      quasis: {
        validate: arrayOf(node("TemplateElement"))
      },
      expressions: {
        validate: arrayOf(nodeAlias("Expression"))
      }
    }
  },
  TaggedTemplateExpression: {
    indices: {
      tag: 0,
      quasi: 1
    },
    fields: {
      tag: {
        validate: nodeAlias("Expression")
      },
      quasi: {
        validate: node("TemplateLiteral")
      }
    }
  },
  ClassExpression: {
    indices: {
      id: 0,
      body: 2,
      superClass: [3, 1]
    },
    fields: {
      id: {
        validate: nullable(node("Identifier"))
      },
      body: {
        validate: node("ClassBody")
      },
      superClass: {
        default: null,
        validate: nullable(nodeAlias("Expression"))
      }
    }
  },
  MetaProperty: {
    indices: {
      meta: 0,
      property: 1
    },
    fields: {
      meta: {
        validate: node("Identifier")
      },
      property: {
        validate: node("Identifier")
      }
    }
  },
  AwaitExpression: {
    indices: {
      argument: 0
    },
    fields: {
      argument: {
        validate: nodeAlias("Expression")
      }
    }
  },
  ImportExpression: {
    indices: {
      source: 0
    },
    fields: {
      source: {
        validate: nodeAlias("Expression")
      }
    }
  },
  ChainExpression: {
    indices: {
      expression: 0
    },
    fields: {
      expression: {
        validate: node("CallExpression", "MemberExpression")
      }
    }
  },
  Property: {
    indices: {
      kind: [0, false],
      key: 1,
      value: 2,
      computed: [3, false],
      shorthand: [4, false],
      method: false
    },
    fields: {
      kind: {
        validate: oneOf(["init", "get", "set"])
      },
      key: {
        validate: OR(nodeAlias("Expression"), node("PrivateIdentifier"))
      },
      value: {
        validate: OR(nodeAlias("Expression"), nodeAlias("Pattern"), node("Property"))
      },
      computed: {
        default: false,
        validate: value("boolean")
      },
      shorthand: {
        default: false,
        validate: value("boolean")
      },
      method: {
        validate: value("boolean")
      }
    }
  },
  Super: {
    indices: {},
    fields: {}
  },
  TemplateElement: {
    indices: {
      value: [0, false],
      tail: [1, false]
    },
    fields: {
      value: {
        validate: nonNull
      },
      tail: {
        validate: value("boolean")
      }
    }
  },
  SpreadElement: {
    indices: {
      argument: 0
    },
    fields: {
      argument: {
        validate: nodeAlias("Expression")
      }
    }
  },
  ObjectPattern: {
    indices: {
      properties: 0
    },
    fields: {
      properties: {
        validate: arrayOf(node("Property", "RestElement"))
      }
    }
  },
  ArrayPattern: {
    indices: {
      elements: 0
    },
    fields: {
      elements: {
        validate: arrayOf(nullable(nodeAlias("Pattern")))
      }
    }
  },
  RestElement: {
    indices: {
      argument: 0
    },
    fields: {
      argument: {
        validate: nodeAlias("Pattern")
      }
    },
    insertionValidate(node2, key2, listKey, parent) {
      if (parent[listKey].length > key2) {
        return `RestElement should be the last children of "${listKey}"`;
      }
      return null;
    }
  },
  AssignmentPattern: {
    indices: {
      left: 0,
      right: 1
    },
    fields: {
      left: {
        validate: nodeAlias("Pattern")
      },
      right: {
        validate: nodeAlias("Expression")
      }
    }
  },
  ClassBody: {
    indices: {
      body: 0
    },
    fields: {
      body: {
        validate: arrayOf(node("StaticBlock", "PropertyDefinition", "MethodDefinition"))
      }
    }
  },
  MethodDefinition: {
    indices: {
      kind: [0, false],
      key: 1,
      value: 2,
      computed: [3, false],
      static: [4, false]
    },
    fields: {
      kind: {
        validate: oneOf(["method", "get", "set", "constructor"])
      },
      key: {
        validate: OR(nodeAlias("Expression"), node("PrivateIdentifier"))
      },
      value: {
        validate: node("FunctionExpression")
      },
      computed: {
        default: false,
        validate: value("boolean")
      },
      static: {
        default: false,
        validate: value("boolean")
      }
    }
  },
  ImportDeclaration: {
    indices: {
      specifiers: 0,
      source: 1
    },
    fields: {
      specifiers: {
        validate: arrayOf(node("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))
      },
      source: {
        validate: node("Literal")
      }
    }
  },
  ExportNamedDeclaration: {
    indices: {
      declaration: 0,
      specifiers: 1,
      source: 2
    },
    fields: {
      declaration: {
        validate: nullable(nodeAlias("Declaration"))
      },
      specifiers: {
        default: [],
        validate: arrayOf(node("ExportSpecifier"))
      },
      source: {
        default: null,
        validate: nullable(node("Literal"))
      }
    }
  },
  ExportDefaultDeclaration: {
    indices: {
      declaration: 0
    },
    fields: {
      declaration: {
        validate: OR(nodeAlias("Declaration"), nodeAlias("Expression"))
      }
    }
  },
  ExportAllDeclaration: {
    indices: {
      source: 0,
      exported: 1
    },
    fields: {
      source: {
        validate: node("Literal")
      },
      exported: {
        default: null,
        validate: nullable(node("Identifier"))
      }
    }
  },
  ImportSpecifier: {
    indices: {
      imported: 0,
      local: 1
    },
    fields: {
      imported: {
        validate: node("Identifier")
      },
      local: {
        default: (node2) => ({ type: "Identifier", name: node2.imported.name }),
        validate: node("Identifier")
      }
    }
  },
  ImportDefaultSpecifier: {
    indices: {
      local: 0
    },
    fields: {
      local: {
        validate: node("Identifier")
      }
    }
  },
  ImportNamespaceSpecifier: {
    indices: {
      local: 0
    },
    fields: {
      local: {
        validate: node("Identifier")
      }
    }
  },
  ExportSpecifier: {
    indices: {
      local: 0,
      exported: 1
    },
    fields: {
      local: {
        validate: node("Identifier")
      },
      exported: {
        default: (node2) => ({ type: "Identifier", name: node2.local.name }),
        validate: node("Identifier")
      }
    }
  },
  PrivateIdentifier: {
    indices: {
      name: [1, false]
    },
    fields: {
      name: {
        validate: chain(value("string"), validIdentifier(false))
      }
    }
  },
  PropertyDefinition: {
    indices: {
      key: 0,
      value: 1,
      computed: [2, false],
      static: [3, false]
    },
    fields: {
      key: {
        validate: OR(nodeAlias("Expression"), node("PrivateIdentifier"))
      },
      value: {
        validate: nullable(nodeAlias("Expression"))
      },
      computed: {
        default: false,
        validate: value("boolean")
      },
      static: {
        default: false,
        validate: value("boolean")
      }
    }
  },
  StaticBlock: {
    indices: {
      body: 0,
      innerComments: false
    },
    fields: {
      body: {
        validate: arrayOf(nodeAlias("Statement"))
      },
      innerComments: anyValidate
    }
  },
  /// JSX
  JSXIdentifier: {
    indices: {
      name: false
    },
    fields: {
      name: {
        validate: chain(value("string"), validIdentifier(true))
      }
    }
  },
  JSXNamespacedName: {
    indices: {
      namespace: 0,
      name: 1
    },
    fields: {
      namespace: {
        validate: node("JSXIdentifier")
      },
      name: {
        validate: node("JSXIdentifier")
      }
    }
  },
  JSXMemberExpression: {
    indices: {
      object: 0,
      property: 0
    },
    fields: {
      object: {
        validate: node("JSXIdentifier", "JSXMemberExpression")
      },
      property: {
        validate: node("JSXIdentifier")
      }
    }
  },
  JSXEmptyExpression: {
    indices: {},
    fields: {}
  },
  JSXExpressionContainer: {
    indices: {
      expression: 0
    },
    fields: {
      expression: {
        validate: OR(nodeAlias("Expression"), node("JSXEmptyExpression"))
      }
    }
  },
  JSXSpreadAttribute: {
    indices: {
      argument: 0
    },
    fields: {
      argument: {
        validate: nodeAlias("Expression")
      }
    }
  },
  JSXAttribute: {
    indices: {
      name: 0,
      value: 1
    },
    fields: {
      name: {
        validate: node("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        validate: nullable(node("Literal", "JSXExpressionContainer", "JSXElement", "JSXFragment"))
      }
    }
  },
  JSXClosingElement: {
    indices: {
      name: 0
    },
    fields: {
      name: {
        validate: node("JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression")
      }
    }
  },
  JSXClosingFragment: {
    indices: {},
    fields: {}
  },
  JSXElement: {
    indices: {
      openingElement: 0,
      children: [2, 1],
      closingElement: [1, 2]
    },
    fields: {
      openingElement: {
        validate: node("JSXOpeningElement")
      },
      children: {
        validate: arrayOf(node("JSXExpressionContainer", "JSXElement", "JSXFragment", "JSXText", "JSXSpreadChild")),
        default: []
      },
      closingElement: {
        validate: nullable(node("JSXClosingElement"))
      }
    }
  },
  JSXFragment: {
    indices: {
      openingFragment: 0,
      children: [2, 1],
      closingFragment: [1, 2]
    },
    fields: {
      openingFragment: {
        validate: node("JSXOpeningFragment")
      },
      children: {
        validate: arrayOf(node("JSXExpressionContainer", "JSXElement", "JSXFragment", "JSXText", "JSXSpreadChild")),
        default: []
      },
      closingFragment: {
        validate: node("JSXClosingFragment")
      }
    }
  },
  JSXOpeningElement: {
    indices: {
      name: 0,
      attributes: 1,
      selfClosing: [2, false]
    },
    fields: {
      name: {
        validate: node("JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression")
      },
      attributes: {
        validate: arrayOf(node("JSXSpreadAttribute", "JSXAttribute")),
        default: []
      },
      selfClosing: {
        validate: value("boolean"),
        default: false
      }
    }
  },
  JSXOpeningFragment: {
    indices: {},
    fields: {}
  },
  JSXSpreadChild: {
    indices: {
      expression: 0
    },
    fields: {
      expression: {
        validate: nodeAlias("Expression")
      }
    }
  },
  JSXText: {
    indices: {
      value: [0, false],
      raw: false
    },
    fields: {
      value: {
        validate: value("string")
      },
      raw: anyValidate
    }
  }
});
var getFieldsOf = ({ indices }, type) => {
  const fields = [];
  Object.keys(indices).forEach((fieldName) => {
    const indexValue = indices[fieldName];
    if (indexValue === false)
      return;
    switch (typeof indexValue) {
      case "number":
        return fields.push({ name: fieldName, index: indexValue });
      case "object": {
        const index = indexValue[type === "builder" ? 0 : 1];
        if (index === false)
          return;
        return fields.push({ name: fieldName, index });
      }
    }
  });
  return fields.sort((a, b2) => a.index - b2.index).map(({ name: name8 }) => name8);
};
var visitorKeys = (() => {
  const record = /* @__PURE__ */ Object.create(null);
  for (const nodeType in definitions) {
    record[nodeType] = getFieldsOf(definitions[nodeType], "visitor");
  }
  return record;
})();

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/builders.mjs
var shouldValidateNodes = true;
var setNodeValidationEnabled = (state) => {
  shouldValidateNodes = state;
};
var getNodeValidationEnabled = () => shouldValidateNodes;
var builders = {};
for (const key2 in definitions) {
  const nodeType = key2;
  const lowerCasedNodeType = nodeType[0].toLowerCase() + nodeType.slice(1);
  const definition = definitions[nodeType];
  const { fields } = definition;
  const fieldNames = getFieldsOf(definition, "builder");
  builders[lowerCasedNodeType] = (...args) => {
    const node2 = { type: nodeType };
    fieldNames.forEach((fieldName, index) => {
      const field = fields[fieldName];
      node2[fieldName] = args[index] !== void 0 ? args[index] : "default" in field ? typeof field.default == "function" ? field.default(node2) : field.default : (
        /* istanbul ignore next */
        args[index]
      );
      if (shouldValidateNodes && field.validate != null) {
        runValidation(field.validate, node2[fieldName]);
      }
    });
    if (shouldValidateNodes && definition.finalValidate != null) {
      runValidation(definition.finalValidate, node2);
    }
    return node2;
  };
}

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/is.mjs
var matches = (object3, toMatch) => {
  for (const key2 in toMatch) {
    const value2 = toMatch[key2];
    if (typeof value2 == "function") {
      if (!value2(object3[key2], object3))
        return false;
    } else if (value2 !== object3[key2]) {
      return false;
    }
  }
  return true;
};
var lowerCase = (str) => str[0].toLowerCase() + str.slice(1);
var is2 = {};
for (const nodeType in definitions) {
  is2[lowerCase(nodeType)] = (nodeOrNodePath, toMatch) => {
    if (nodeOrNodePath == null)
      return false;
    const node2 = nodeOrNodePath.ctx != null ? nodeOrNodePath.node : nodeOrNodePath;
    return node2 != null && node2.type === nodeType && (toMatch != null ? matches(node2, toMatch) : true);
  };
}
for (const aliasName in aliases) {
  is2[lowerCase(aliasName)] = (nodeOrNodePath, toMatch) => {
    if (nodeOrNodePath == null)
      return false;
    const node2 = nodeOrNodePath.ctx != null ? nodeOrNodePath.node : nodeOrNodePath;
    return node2 != null && node2.type in aliases[aliasName] && (toMatch != null ? matches(node2, toMatch) : true);
  };
}

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/estree.mjs
var assertNever = (x2) => x2;

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/binding.mjs
var BaseBinding = class {
  constructor() {
    this.references = [];
    this.constantViolations = [];
  }
  addReference(path) {
    this.references.push(path);
  }
  // Splice is performance intensive, I guess it wouldn't matter for small
  // arrays, anyway someone's hardly gonna use this remove* methods
  removeReference(path) {
    const idx = this.references.findIndex((x2) => x2 === path);
    if (idx > -1)
      this.references.splice(idx, 1);
  }
  addConstantViolation(path) {
    this.constantViolations.push(path);
  }
  removeConstantViolation(path) {
    const idx = this.constantViolations.findIndex((x2) => x2 === path);
    if (idx > -1)
      this.constantViolations.splice(idx, 1);
  }
};
var Binding = class extends BaseBinding {
  constructor(data2) {
    super();
    this.kind = data2.kind;
    this.name = data2.name;
    this.scope = data2.scope;
    this.identifierPath = data2.identifierPath;
    this.path = data2.path;
  }
  get constant() {
    return this.constantViolations.length === 0;
  }
};
var GlobalBinding = class extends BaseBinding {
  constructor(data2) {
    super();
    this.kind = "global";
    this.constant = false;
    this.name = data2.name;
  }
};

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/scope.mjs
var scopedNodeTypes = [
  "ArrowFunctionExpression",
  "BlockStatement",
  "CatchClause",
  "ClassDeclaration",
  "ClassExpression",
  "DoWhileStatement",
  "ForInStatement",
  "ForOfStatement",
  "ForStatement",
  "FunctionDeclaration",
  "FunctionExpression",
  "Program",
  "SwitchStatement",
  "WhileStatement"
];
var scopedNodesTypesSet = new Set(scopedNodeTypes);
var shouldBlockStatementMakeScope = (parent) => {
  if (parent != null && parent.type !== "BlockStatement" && parent.type !== "Program" && scopedNodesTypesSet.has(parent.type)) {
    return false;
  }
  return true;
};
var shouldMakeScope = (path) => {
  if (path.node == null)
    return false;
  if (path.node.type === "BlockStatement" && !shouldBlockStatementMakeScope(path.parent)) {
    return false;
  }
  return scopedNodesTypesSet.has(path.node.type);
};
var isIdentifierJSX = (name8) => !/^[a-z]/.test(name8);
var identifierCrawlers = {
  ArrowFunctionExpression(key2, path, state) {
    switch (key2) {
      case "body":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  AssignmentExpression(key2, path, state) {
    switch (key2) {
      case "left":
        throw new Error("This should be handled by `crawlerVisitor.AssignmentExpression`");
      case "right":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  AssignmentPattern(key2, path, state) {
    switch (key2) {
      case "left":
        throw new Error("`identifierCrawlers.AssignmentPattern` is not implemented");
      case "right":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  AwaitExpression(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  /* istanbul ignore next */
  FunctionDeclaration(key2) {
    switch (key2) {
      case "id":
        break;
      default:
        assertNever(key2);
    }
  },
  /* istanbul ignore next */
  FunctionExpression(key2) {
    switch (key2) {
      case "id":
        throw new Error("This should be handled by `scopePathCrawlers.FunctionExpression`");
      default:
        assertNever(key2);
    }
  },
  SwitchCase(key2, path, state) {
    switch (key2) {
      case "test":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  /* istanbul ignore next */
  CatchClause(key2) {
    switch (key2) {
      case "param":
        throw new Error("This should be handled by `scopePathCrawlers.CatchClause`");
      default:
        assertNever(key2);
    }
  },
  VariableDeclarator(key2, path, state) {
    switch (key2) {
      case "id":
        throw new Error("This should be handled by `scopePathCrawlers.VariableDeclarator`");
      case "init":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ExpressionStatement(key2, path, state) {
    switch (key2) {
      case "expression":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  /* istanbul ignore next */
  WithStatement(key2, path, state) {
    switch (key2) {
      case "object":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ReturnStatement(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  LabeledStatement() {
  },
  BreakStatement(key2, path, state) {
    switch (key2) {
      case "label":
        state.labelReferences.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ContinueStatement(key2, path, state) {
    switch (key2) {
      case "label":
        state.labelReferences.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  IfStatement(key2, path, state) {
    switch (key2) {
      case "test":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  SwitchStatement(key2, path, state) {
    switch (key2) {
      case "discriminant":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ThrowStatement(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  WhileStatement(key2, path, state) {
    switch (key2) {
      case "test":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  DoWhileStatement(key2, path, state) {
    switch (key2) {
      case "test":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ForStatement(key2, path, state) {
    switch (key2) {
      case "init":
      case "test":
      case "update":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ForInStatement(key2, path, state) {
    switch (key2) {
      case "left":
        throw new Error("This should be handled by `scopePathCrawlers.ForInStatement`");
      case "right":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ForOfStatement(key2, path, state) {
    switch (key2) {
      case "left":
        throw new Error("This should be handled by `scopePathCrawlers.ForOfStatement`");
      case "right":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ClassDeclaration(key2, path, state) {
    switch (key2) {
      case "id":
        break;
      case "superClass":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  YieldExpression(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  UnaryExpression(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  UpdateExpression(key2, path, state) {
    switch (key2) {
      case "argument":
        state.constantViolations.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  BinaryExpression(key2, path, state) {
    switch (key2) {
      case "left":
      case "right":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  LogicalExpression(key2, path, state) {
    switch (key2) {
      case "left":
      case "right":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  MemberExpression(key2, path, state) {
    switch (key2) {
      case "object":
        state.references.push(path);
        break;
      case "property":
        if (path.parent.computed) {
          state.references.push(path);
        }
        break;
      default:
        assertNever(key2);
    }
  },
  ConditionalExpression(key2, path, state) {
    switch (key2) {
      case "test":
      case "consequent":
      case "alternate":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  CallExpression(key2, path, state) {
    switch (key2) {
      case "callee":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  NewExpression(key2, path, state) {
    switch (key2) {
      case "callee":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  TaggedTemplateExpression(key2, path, state) {
    switch (key2) {
      case "tag":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ClassExpression(key2, path, state) {
    switch (key2) {
      case "id":
        throw new Error("This should be handled by `scopePathCrawlers.ClassExpression`");
      case "superClass":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  MetaProperty(key2) {
    switch (key2) {
      case "meta":
      case "property":
        break;
      default:
        assertNever(key2);
    }
  },
  ImportExpression(key2, path, state) {
    switch (key2) {
      case "source":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  Property(key2, path, state) {
    switch (key2) {
      case "key":
        if (path.parent.computed) {
          state.references.push(path);
        }
        break;
      case "value":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  SpreadElement(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  /* istanbul ignore next */
  RestElement(key2) {
    switch (key2) {
      case "argument":
        throw new Error("This should be handled by `findVisiblePathsInPattern`");
      default:
        assertNever(key2);
    }
  },
  MethodDefinition(key2, path, state) {
    switch (key2) {
      case "key":
        if (path.parent.computed) {
          state.references.push(path);
        }
        break;
      default:
        assertNever(key2);
    }
  },
  ExportDefaultDeclaration(key2, path, state) {
    switch (key2) {
      case "declaration":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  ImportSpecifier(key2, path, state) {
    switch (key2) {
      case "imported":
        if (path.parent.local == null) {
          state.scope.registerBinding("module", path, path.parentPath);
        }
        if (path.parent.local === path.parent.imported) {
          const ctx = path.ctx;
          let parentPath = path.parentPath;
          const parentNode = parentPath.node;
          ctx.newQueue();
          parentPath = parentPath.replaceWith(Object.assign({}, parentNode, {
            local: Object.assign({}, parentNode.local),
            imported: Object.assign({}, parentNode.imported)
          }));
          ctx.popQueue();
          state.scope.registerBinding("module", parentPath.get("local"), parentPath);
        }
        break;
      case "local":
        state.scope.registerBinding("module", path, path.parentPath);
        break;
      default:
        assertNever(key2);
    }
  },
  ImportDefaultSpecifier(key2, path, state) {
    switch (key2) {
      case "local":
        state.scope.registerBinding("module", path, path.parentPath);
        break;
      default:
        assertNever(key2);
    }
  },
  ImportNamespaceSpecifier(key2, path, state) {
    switch (key2) {
      case "local":
        state.scope.registerBinding("module", path, path.parentPath);
        break;
      default:
        assertNever(key2);
    }
  },
  ExportSpecifier(key2, path, state) {
    switch (key2) {
      case "local":
        if (path.parent.local === path.parent.exported) {
          const ctx = path.ctx;
          let parentPath = path.parentPath;
          const parentNode = parentPath.node;
          ctx.newQueue();
          parentPath = parentPath.replaceWith(Object.assign({}, parentNode, {
            local: Object.assign({}, parentNode.local),
            exported: Object.assign({}, parentNode.exported)
          }));
          ctx.popQueue();
          state.references.push(parentPath.get("local"));
        } else {
          state.references.push(path);
        }
        break;
      case "exported":
        break;
      default:
        assertNever(key2);
    }
  },
  ExportAllDeclaration(key2) {
    switch (key2) {
      case "exported":
        break;
      default:
        assertNever(key2);
    }
  },
  PropertyDefinition(key2, path, state) {
    switch (key2) {
      case "key":
        break;
      case "value":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  /// JSX
  JSXExpressionContainer(key2, path, state) {
    switch (key2) {
      case "expression":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  JSXSpreadAttribute(key2, path, state) {
    switch (key2) {
      case "argument":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  },
  JSXSpreadChild(key2, path, state) {
    switch (key2) {
      case "expression":
        state.references.push(path);
        break;
      default:
        assertNever(key2);
    }
  }
};
var jsxIdentifierCrawlers = {
  JSXNamespacedName(key2, path, state) {
    switch (key2) {
      case "namespace":
        if (isIdentifierJSX(path.node.name)) {
          state.references.push(path);
        }
        break;
      case "name":
        break;
      default:
        assertNever(key2);
    }
  },
  JSXAttribute(key2) {
    switch (key2) {
      case "name":
        break;
      default:
        assertNever(key2);
    }
  },
  JSXClosingElement(key2, path, state) {
    switch (key2) {
      case "name":
        if (isIdentifierJSX(path.node.name)) {
          state.references.push(path);
        }
        break;
      default:
        assertNever(key2);
    }
  },
  JSXMemberExpression(key2, path, state) {
    switch (key2) {
      case "object":
        state.references.push(path);
        break;
      case "property":
        break;
      default:
        assertNever(key2);
    }
  },
  JSXOpeningElement(key2, path, state) {
    switch (key2) {
      case "name":
        if (isIdentifierJSX(path.node.name)) {
          state.references.push(path);
        }
        break;
      default:
        assertNever(key2);
    }
  }
};
var inListIdentifierCrawlers = {
  ArrayExpression(listKey, path, state) {
    switch (listKey) {
      case "elements":
        state.references.push(path);
        break;
      default:
        assertNever(listKey);
    }
  },
  CallExpression(listKey, path, state) {
    switch (listKey) {
      case "arguments":
        state.references.push(path);
        break;
      default:
        assertNever(listKey);
    }
  },
  NewExpression(listKey, path, state) {
    switch (listKey) {
      case "arguments":
        state.references.push(path);
        break;
      default:
        assertNever(listKey);
    }
  },
  SequenceExpression(listKey, path, state) {
    switch (listKey) {
      case "expressions":
        state.references.push(path);
        break;
      default:
        assertNever(listKey);
    }
  },
  TemplateLiteral(listKey, path, state) {
    switch (listKey) {
      case "expressions":
        state.references.push(path);
        break;
      default:
        assertNever(listKey);
    }
  },
  /* istanbul ignore next */
  ArrayPattern(listKey) {
    switch (listKey) {
      case "elements":
        throw new Error("`inListIdentifierCrawler.ArrayPattern` is not implemented");
      default:
        assertNever(listKey);
    }
  },
  /* istanbul ignore next */
  FunctionDeclaration(listKey) {
    switch (listKey) {
      case "params":
        throw new Error("This should be handled by `scopePathCrawlers.FunctionDeclaration`");
      default:
        assertNever(listKey);
    }
  },
  /* istanbul ignore next */
  FunctionExpression(listKey) {
    switch (listKey) {
      case "params":
        throw new Error("This should be handled by `scopePathCrawlers.FunctionExpression`");
      default:
        assertNever(listKey);
    }
  },
  /* istanbul ignore next */
  ArrowFunctionExpression(listKey) {
    switch (listKey) {
      case "params":
        throw new Error("This should be handled by `scopePathCrawlers.ArrowFunctionExpression`");
      default:
        assertNever(listKey);
    }
  }
};
var inListJSXIdentifierCrawlers = {};
var findVisiblePathsInPattern = (path, result) => {
  switch (path.node.type) {
    case "Identifier":
      result.push(path);
      path.skip();
      break;
    case "ObjectPattern": {
      const properties = path.get("properties");
      for (let i = 0; i < properties.length; i++) {
        const property = properties[i];
        const propertyNode = property.node;
        switch (propertyNode.type) {
          case "RestElement":
            findVisiblePathsInPattern(property, result);
            break;
          case "Property":
            if (propertyNode.value != null) {
              let propertyPath = property;
              if (propertyNode.value === propertyNode.key) {
                const ctx = path.ctx;
                ctx.newQueue();
                propertyPath = propertyPath.replaceWith(Object.assign({}, propertyNode, {
                  key: Object.assign({}, propertyNode.key),
                  value: Object.assign({}, propertyNode.value)
                }));
                ctx.popQueue();
              }
              findVisiblePathsInPattern(propertyPath.get("value"), result);
            } else if (!propertyNode.computed && propertyNode.key.type === "Identifier") {
              const keyPath = property.get("key");
              result.push(keyPath);
              keyPath.skip();
            }
            break;
        }
      }
      break;
    }
    case "ArrayPattern": {
      const aPath = path;
      const elementPaths = aPath.get("elements");
      const elements2 = aPath.node.elements;
      for (let i = 0; i < elementPaths.length; i++) {
        if (elements2[i] == null)
          continue;
        findVisiblePathsInPattern(elementPaths[i], result);
      }
      break;
    }
    case "RestElement":
      findVisiblePathsInPattern(path.get("argument"), result);
      break;
    case "AssignmentPattern":
      findVisiblePathsInPattern(path.get("left"), result);
      break;
    case "MemberExpression":
      break;
    default:
      assertNever(path.node);
  }
};
var registerBindingFromPattern = (path, scope, kind, bindingPath) => {
  const identifierPaths = [];
  findVisiblePathsInPattern(path, identifierPaths);
  for (let i = 0; i < identifierPaths.length; i++) {
    scope.registerBinding(kind, identifierPaths[i], bindingPath);
  }
};
var registerConstantViolationFromPattern = (path, state) => {
  const identifierPaths = [];
  findVisiblePathsInPattern(path, identifierPaths);
  for (let i = 0; i < identifierPaths.length; i++) {
    state.constantViolations.push(identifierPaths[i]);
  }
};
var registerVariableDeclaration = (path, scope) => {
  const kind = path.node.kind;
  const declarators = path.get("declarations");
  for (let i = 0; i < declarators.length; i++) {
    const declarator2 = declarators[i];
    registerBindingFromPattern(declarator2.get("id"), scope, kind, declarator2);
  }
};
var crawlerVisitor = {
  Identifier: {
    enter(path, state) {
      var _a2;
      const parentType = (_a2 = path.parentPath.node) === null || _a2 === void 0 ? void 0 : _a2.type;
      if (path.listKey != null) {
        const crawler = inListIdentifierCrawlers[parentType];
        if (crawler != null) {
          crawler(path.listKey, path, state);
        }
      } else {
        const crawler = identifierCrawlers[parentType];
        if (crawler != null) {
          crawler(path.key, path, state);
        }
      }
    }
  },
  JSXIdentifier: {
    enter(path, state) {
      var _a2;
      const parentType = (_a2 = path.parentPath.node) === null || _a2 === void 0 ? void 0 : _a2.type;
      if (path.listKey != null) {
        const crawler = inListJSXIdentifierCrawlers[parentType];
        if (crawler != null) {
          crawler(path.listKey, path, state);
        }
      } else {
        const crawler = jsxIdentifierCrawlers[parentType];
        if (crawler != null) {
          crawler(path.key, path, state);
        }
      }
    }
  },
  AssignmentExpression: {
    enter(path, state) {
      registerConstantViolationFromPattern(path.get("left"), state);
    }
  },
  VariableDeclaration: {
    enter(path, state) {
      registerVariableDeclaration(path, state.scope);
    }
  }
};
{
  const cVisitors = crawlerVisitor;
  const skipToChildNodeVisitor = {
    enter(path, state) {
      state.childScopedPaths.push(path);
      path.skip();
    }
  };
  for (let i = 0; i < scopedNodeTypes.length; i++) {
    cVisitors[scopedNodeTypes[i]] = skipToChildNodeVisitor;
  }
  cVisitors.FunctionDeclaration = cVisitors.ClassDeclaration = {
    enter(path, state) {
      if (path.node.id != null) {
        const id2 = path.get("id");
        state.scope.registerBinding("hoisted", id2, path);
        id2.skip();
      }
      skipToChildNodeVisitor.enter.call({}, path, state);
    }
  };
  cVisitors.BlockStatement = {
    enter(path, state) {
      if (shouldBlockStatementMakeScope(path.parent)) {
        skipToChildNodeVisitor.enter.call({}, path, state);
      }
    }
  };
}
var registerFunctionParams = (paths, scope) => {
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    registerBindingFromPattern(path, scope, "param", path);
  }
};
var scopePathCrawlers = {
  Program: null,
  FunctionDeclaration(path, { scope }) {
    registerFunctionParams(path.get("params"), scope);
  },
  ClassDeclaration: null,
  FunctionExpression(path, { scope }) {
    if (path.node.id != null) {
      const id2 = path.get("id");
      scope.registerBinding("local", id2, path);
      id2.skip();
    }
    registerFunctionParams(path.get("params"), scope);
  },
  ClassExpression(path, { scope }) {
    if (path.node.id != null) {
      const id2 = path.get("id");
      scope.registerBinding("local", id2, path);
      id2.skip();
    }
  },
  ArrowFunctionExpression(path, { scope }) {
    registerFunctionParams(path.get("params"), scope);
  },
  CatchClause(path, { scope }) {
    registerBindingFromPattern(path.get("param"), scope, "let", path);
  },
  BlockStatement(path, { scope }) {
    if (path.parent != null && path.parent.type === "LabeledStatement") {
      scope.registerLabel(path.parentPath.get("label"));
    }
  },
  SwitchStatement: null,
  WhileStatement: null,
  DoWhileStatement: null,
  ForStatement(path, state) {
    if (path.parent != null && path.parent.type === "LabeledStatement") {
      state.scope.registerLabel(path.parentPath.get("label"));
    }
    if (path.node.init != null && path.node.init.type === "VariableDeclaration") {
      registerVariableDeclaration(path.get("init"), state.scope);
    }
  },
  ForXStatement(path, state) {
    if (path.parent != null && path.parent.type === "LabeledStatement") {
      state.scope.registerLabel(path.parentPath.get("label"));
    }
    if (path.node.left.type === "VariableDeclaration") {
      registerVariableDeclaration(path.get("left"), state.scope);
    } else if (is2.pattern(path.node.left)) {
      registerConstantViolationFromPattern(path.get("left"), state);
    }
  },
  ForInStatement(path, state) {
    scopePathCrawlers.ForXStatement(path, state);
  },
  ForOfStatement(path, state) {
    scopePathCrawlers.ForXStatement(path, state);
  }
};
var Scope5 = class _Scope {
  constructor(path, parentScope) {
    this.children = [];
    this.initialized = false;
    this.bindings = /* @__PURE__ */ Object.create(null);
    this.globalBindings = /* @__PURE__ */ Object.create(null);
    this.labels = /* @__PURE__ */ Object.create(null);
    this.priv = {
      prevState: null,
      memoizedBindings: /* @__PURE__ */ Object.create(null),
      memoizedLabels: /* @__PURE__ */ Object.create(null),
      idMap: /* @__PURE__ */ Object.create(null),
      declaration: null
    };
    this.path = path;
    this.parent = parentScope;
    if (this.parent != null)
      this.parent.children.push(this);
  }
  static for(path, parentScope) {
    if (shouldMakeScope(path)) {
      if (path.ctx.scopeCache.has(path)) {
        return path.ctx.scopeCache.get(path);
      }
      const scope = new _Scope(path, parentScope);
      path.ctx.scopeCache.set(path, scope);
      return scope;
    }
    return parentScope;
  }
  init() {
    if (this.initialized)
      return;
    if (this.path.type !== "Program") {
      this.priv.idMap = this.getProgramScope().priv.idMap;
    }
    this.crawl();
  }
  // Temporarily memoize stuffs. Improves performance in deep tree
  getMemoBinding(bindingName) {
    const { memoizedBindings } = this.priv;
    return bindingName in memoizedBindings ? memoizedBindings[bindingName] : memoizedBindings[bindingName] = this.getBinding(bindingName);
  }
  getMemoLabel(labelName) {
    const { memoizedLabels } = this.priv;
    return labelName in memoizedLabels ? memoizedLabels[labelName] : memoizedLabels[labelName] = this.getLabel(labelName);
  }
  clearMemo() {
    this.priv.memoizedBindings = /* @__PURE__ */ Object.create(null);
    this.priv.memoizedLabels = /* @__PURE__ */ Object.create(null);
  }
  getProgramScope() {
    if (this.path.type === "Program") {
      return this;
    } else {
      return this.path.findParent((p) => p.type === "Program").scope;
    }
  }
  crawl() {
    var _a2, _b;
    if (this.path.node == null)
      return;
    if (this.path.removed) {
      throw Error("This scope is no longer part of the AST, the containing path has been removed");
    }
    _Scope.rollbackState(this);
    this.bindings = /* @__PURE__ */ Object.create(null);
    this.globalBindings = this.path.type === "Program" ? /* @__PURE__ */ Object.create(null) : this.getProgramScope().globalBindings;
    this.labels = /* @__PURE__ */ Object.create(null);
    const state = {
      references: [],
      constantViolations: [],
      labelReferences: [],
      scope: this,
      childScopedPaths: []
    };
    this.path.ctx.makeScope = false;
    this.path.ctx.newSkipPathStack();
    {
      const scopePathCrawler = scopePathCrawlers[this.path.node.type];
      if (scopePathCrawler != null) {
        scopePathCrawler(this.path, state);
      }
    }
    Traverser.traverseNode({
      node: this.path.node,
      parentPath: this.path.parentPath,
      ctx: this.path.ctx,
      state,
      visitors: crawlerVisitor,
      expand: false,
      visitOnlyChildren: true
    });
    this.path.ctx.makeScope = true;
    this.path.ctx.restorePrevSkipPathStack();
    this.clearMemo();
    {
      for (let i = 0; i < state.references.length; i++) {
        const path = state.references[i];
        const bindingName = path.node.name;
        const binding = this.getMemoBinding(bindingName);
        if (binding != null) {
          binding.addReference(path);
        } else {
          ((_a2 = this.globalBindings)[bindingName] || (_a2[bindingName] = new GlobalBinding({ name: bindingName }))).addReference(path);
        }
      }
      for (let i = 0; i < state.constantViolations.length; i++) {
        const path = state.constantViolations[i];
        const bindingName = path.node.name;
        const binding = this.getMemoBinding(bindingName);
        if (binding != null) {
          binding.addConstantViolation(path);
        } else {
          ((_b = this.globalBindings)[bindingName] || (_b[bindingName] = new GlobalBinding({ name: bindingName }))).addConstantViolation(path);
        }
      }
      for (let i = 0; i < state.labelReferences.length; i++) {
        const path = state.labelReferences[i];
        const labelName = path.node.name;
        const label = this.getMemoLabel(labelName);
        if (label != null) {
          label.references.push(path);
        }
      }
    }
    this.initialized = true;
    this.priv.prevState = {
      references: state.references,
      constantViolations: state.constantViolations,
      labelReferences: state.labelReferences
    };
    this.clearMemo();
    for (let i = 0; i < state.childScopedPaths.length; i++) {
      state.childScopedPaths[i].init(this);
    }
  }
  /** Rollback all the changes contributed by this scope
   * @internal
   */
  static rollbackState(scope) {
    const { prevState: state } = scope.priv;
    if (state == null)
      return;
    scope.clearMemo();
    for (let i = 0; i < state.references.length; i++) {
      const path = state.references[i];
      const bindingName = path.node.name;
      const binding = scope.getMemoBinding(bindingName);
      if (binding != null) {
        binding.removeReference(path);
      } else {
        const globalBinding = scope.globalBindings[bindingName];
        if (globalBinding != null) {
          globalBinding.removeReference(path);
        }
      }
    }
    for (let i = 0; i < state.constantViolations.length; i++) {
      const path = state.constantViolations[i];
      const bindingName = path.node.name;
      const binding = scope.getMemoBinding(bindingName);
      if (binding != null) {
        binding.removeConstantViolation(path);
      } else {
        const globalBinding = scope.globalBindings[bindingName];
        if (globalBinding != null) {
          globalBinding.removeConstantViolation(path);
        }
      }
    }
    for (let i = 0; i < state.labelReferences.length; i++) {
      const path = state.labelReferences[i];
      const labelName = path.node.name;
      const label = scope.getMemoLabel(labelName);
      if (label != null) {
        const idx = label.references.findIndex((x2) => x2 === path);
        if (idx > -1)
          label.references.splice(idx, 1);
      }
    }
    const globalNames = Object.keys(scope.globalBindings);
    for (let i = 0; i < globalNames.length; i++) {
      const name8 = globalNames[i];
      const global = scope.globalBindings[name8];
      if (global.references.length === 0 && global.constantViolations.length === 0) {
        scope.globalBindings[name8] = void 0;
        delete scope.globalBindings[name8];
      }
    }
  }
  /** @internal */
  static recursiveRollback(scope) {
    for (let i = 0; i < scope.children.length; i++) {
      _Scope.recursiveRollback(scope.children[i]);
    }
    _Scope.rollbackState(scope);
  }
  /** @internal */
  static handleRemoval(scope, path) {
    if (path === scope.path) {
      _Scope.recursiveRollback(scope);
      if (scope.parent != null) {
        const { children } = scope.parent;
        const idx = children.indexOf(scope);
        if (idx > -1)
          children.splice(idx, 1);
      }
    } else {
      for (let i = 0; i < scope.children.length; i++) {
        const child = scope.children[i];
        if (child.path.isDescendantOf(path)) {
          _Scope.recursiveRollback(child);
          const idx = scope.children.indexOf(child);
          if (idx > -1)
            scope.children.splice(idx, 1);
        }
      }
    }
  }
  registerBinding(kind, identifierPath, bindingPath) {
    const bindingName = identifierPath.node.name;
    const binding = this.getOwnBinding(bindingName);
    if (binding != null) {
      binding.addConstantViolation(identifierPath);
      return;
    }
    this.bindings[bindingName] = new Binding({
      kind,
      name: bindingName,
      scope: this,
      identifierPath,
      path: bindingPath
    });
  }
  hasOwnBinding(name8) {
    return name8 in this.bindings;
  }
  getOwnBinding(name8) {
    return this.bindings[name8];
  }
  hasBinding(name8) {
    return this.getBinding(name8) != null;
  }
  getBinding(name8) {
    let scope = this;
    while (scope != null) {
      if (scope.hasOwnBinding(name8)) {
        return scope.getOwnBinding(name8);
      }
      scope = scope.parent;
    }
  }
  getAllBindings(...kind) {
    const result = /* @__PURE__ */ Object.create(null);
    const kindLength = kind.length;
    const kindSet = new Set(kind);
    let scope = this;
    while (scope != null) {
      for (const name8 in scope.bindings) {
        if (!(name8 in result)) {
          if (kindLength === 0 || kindLength && kindSet.has(scope.bindings[name8].kind)) {
            result[name8] = scope.bindings[name8];
          }
        }
      }
      scope = scope.parent;
    }
    return result;
  }
  hasGlobalBinding(name8) {
    return this.getGlobalBinding(name8) != null;
  }
  getGlobalBinding(name8) {
    return this.getProgramScope().globalBindings[name8];
  }
  /** @internal */
  registerLabel(path) {
    const labelName = path.node.name;
    if (this.hasLabel(labelName)) {
      return;
    }
    this.labels[labelName] = {
      path,
      references: []
    };
  }
  hasLabel(name8) {
    return this.getLabel(name8) != null;
  }
  getLabel(name8) {
    let scope = this;
    while (scope != null) {
      if (scope.labels[name8] != null) {
        return scope.labels[name8];
      }
      scope = scope.parent;
    }
  }
  generateUid(name8 = "_tmp") {
    var _a2;
    const allIDs = Object.keys(this.getAllBindings()).concat(Object.keys(this.globalBindings)).concat(Object.keys(this.priv.idMap));
    (_a2 = this.priv.idMap)[name8] || (_a2[name8] = 1);
    let fName = name8 = name8.replace(/[^a-zA-Z_]+/g, "");
    while (allIDs.includes(fName)) {
      fName = name8 + ++this.priv.idMap[name8];
    }
    return fName;
  }
  generateUidIdentifier(name8) {
    return builders.identifier(this.generateUid(name8));
  }
  generateDeclaredUidIdentifier(name8) {
    let declaratorPath;
    const { ctx } = this.path;
    ctx.newSkipPathStack();
    ctx.newQueue();
    if (this.priv.declaration == null) {
      let block2 = null;
      switch (this.path.type) {
        case "ArrowFunctionExpression":
          {
            const path = this.path;
            const body = path.get("body");
            if (body.type === "BlockStatement") {
              block2 = body;
            } else {
              const bodyNode = Object.assign({}, body.node);
              block2 = body.replaceWith(builders.blockStatement([builders.returnStatement(bodyNode)]));
            }
          }
          break;
        case "Program":
        case "BlockStatement":
          block2 = this.path;
          break;
        case "SwitchStatement":
        case "ClassDeclaration":
        case "ClassExpression":
          ctx.restorePrevSkipPathStack();
          ctx.popQueue();
          return this.parent.generateDeclaredUidIdentifier(name8);
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
        case "ForStatement":
        case "WhileStatement":
          {
            const path = this.path;
            const body = path.get("body");
            if (body.type === "BlockStatement") {
              block2 = body;
            } else {
              const bodyNode = Object.assign({}, body.node);
              block2 = body.replaceWith(builders.blockStatement([bodyNode]));
            }
          }
          break;
        case "CatchClause":
        case "FunctionDeclaration":
        case "FunctionExpression":
          block2 = this.path.get("body");
          break;
        case null:
          break;
        default:
          assertNever(this.path.type);
      }
      const declarationNode = builders.variableDeclaration("var", [builders.variableDeclarator(this.generateUidIdentifier(name8))]);
      const [declarationPath] = block2.unshiftContainer("body", [declarationNode]);
      this.priv.declaration = declarationPath;
      declaratorPath = declarationPath.get("declarations")[0];
    } else {
      [declaratorPath] = this.priv.declaration.pushContainer("declarations", [builders.variableDeclarator(this.generateUidIdentifier(name8))]);
    }
    const identifier = declaratorPath.get("id");
    this.registerBinding("var", identifier, declaratorPath);
    ctx.restorePrevSkipPathStack();
    ctx.popQueue();
    return Object.assign({}, identifier.node);
  }
  /** @internal */
  renameConsideringParent(path, newName) {
    var _a2, _b;
    const parent = path.parent;
    if (parent.type === "Property" && ((_b = (_a2 = path.parentPath) === null || _a2 === void 0 ? void 0 : _a2.parent) === null || _b === void 0 ? void 0 : _b.type) === "ObjectPattern") {
      parent.value.name = newName;
      parent.shorthand = parent.value.name === parent.key.name;
    } else {
      path.node.name = newName;
    }
  }
  renameBinding(oldName, newName) {
    var _a2;
    if (this.bindings[oldName] != null) {
      const binding = this.bindings[oldName];
      this.renameConsideringParent(binding.identifierPath, newName);
      for (let i = 0; i < binding.references.length; i++) {
        binding.references[i].node.name = newName;
      }
      for (let i = 0; i < binding.constantViolations.length; i++) {
        this.renameConsideringParent(binding.constantViolations[i], newName);
      }
      this.bindings[oldName] = void 0;
      delete this.bindings[oldName];
      this.bindings[newName] = binding;
    } else {
      (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.renameBinding(oldName, newName);
    }
  }
};

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/nodepath.mjs
var mapSet = (map, key2, value2) => {
  map.set(key2, value2);
  return value2;
};
var Context = class {
  constructor(options) {
    this.pathCache = /* @__PURE__ */ new Map();
    this.scopeCache = /* @__PURE__ */ new Map();
    this.makeScope = false;
    this.shouldValidateNodes = getNodeValidationEnabled();
    this.cloneFunction = (node2) => structuredClone(node2);
    this.currentSkipPaths = /* @__PURE__ */ new Set();
    this.skipPathSetStack = [this.currentSkipPaths];
    this.queueStack = [];
    this.makeScope = (options === null || options === void 0 ? void 0 : options.scope) === true;
    if ((options === null || options === void 0 ? void 0 : options.validateNodes) != null) {
      this.shouldValidateNodes = options.validateNodes;
    }
    if (typeof (options === null || options === void 0 ? void 0 : options.cloneFunction) === "function") {
      this.cloneFunction = options.cloneFunction;
    }
  }
  setSkipped(path) {
    this.currentSkipPaths.add(path);
  }
  setNotSkipped(path) {
    this.currentSkipPaths.delete(path);
  }
  shouldSkip(path) {
    return this.currentSkipPaths.has(path);
  }
  updateCurrentSkipPaths() {
    this.currentSkipPaths = this.skipPathSetStack[this.skipPathSetStack.length - 1];
  }
  newSkipPathStack() {
    this.skipPathSetStack.push(/* @__PURE__ */ new Set());
    this.updateCurrentSkipPaths();
  }
  restorePrevSkipPathStack() {
    this.skipPathSetStack.pop();
    this.updateCurrentSkipPaths();
  }
  pushToQueue(paths, stackName) {
    const last = this.queueStack[this.queueStack.length - 1];
    if (last != null)
      last[stackName].push(...paths);
  }
  newQueue() {
    this.queueStack.push({
      new: [],
      unSkipped: []
    });
  }
  popQueue() {
    return this.queueStack.pop();
  }
};
var runInsertionValidation = (node2, key2, listKey, parent) => {
  if (!getNodeValidationEnabled())
    return;
  const definition = definitions[node2.type];
  if (definition != null && definition.insertionValidate != null) {
    const errorMsg = definition.insertionValidate(node2, key2, listKey, parent);
    if (errorMsg != null) {
      throw new Error(errorMsg);
    }
  }
};
var NodePath = class _NodePath {
  // accessKey = '';
  constructor(data2) {
    this.node = data2.node;
    this.type = this.node && this.node.type;
    this.key = data2.key;
    this.listKey = data2.listKey;
    this.parentPath = data2.parentPath;
    this.parent = this.parentPath && this.parentPath.node;
    this.container = this.listKey ? this.parent[this.listKey] : this.parent;
    this.removed = false;
    this.ctx = data2.ctx;
    this.scope = void 0;
  }
  /** Get the cached NodePath object or create new if cache is not available */
  static for(data2) {
    if (data2.node == null) {
      return new this(data2);
    }
    const { ctx: { pathCache }, parentPath } = data2;
    const children = pathCache.get(parentPath) || mapSet(pathCache, parentPath, /* @__PURE__ */ new Map());
    return children.get(data2.node) || mapSet(children, data2.node, new _NodePath(data2));
  }
  init(parentScope) {
    var _a2;
    if (this.ctx.makeScope) {
      this.scope = Scope5.for(this, parentScope || ((_a2 = this.parentPath) === null || _a2 === void 0 ? void 0 : _a2.scope) || null);
      if (this.scope != null)
        this.scope.init();
    }
    return this;
  }
  throwNoParent(methodName) {
    throw new Error(`Can not use \`${methodName}\` on a NodePath which does not have a parent`);
  }
  assertNotRemoved() {
    if (this.removed) {
      throw new Error("Path is removed and it is now read-only");
    }
  }
  assertNotNull(methodName) {
    if (this.node == null) {
      throw new Error(`Can not use method \`${methodName}\` on a null NodePath`);
    }
  }
  get parentKey() {
    return this.listKey != null ? this.listKey : this.key;
  }
  cloneNode() {
    return this.ctx.cloneFunction(this.node);
  }
  //#region Traversal
  skip() {
    this.ctx.setSkipped(this);
  }
  skipChildren() {
    this.assertNotNull("skipChildren");
    const node2 = this.node;
    const keys = visitorKeys[this.type] || Object.keys(node2);
    for (let i = 0; i < keys.length; i++) {
      const key2 = keys[i];
      const value2 = node2[key2];
      if (Array.isArray(value2)) {
        this.get(key2).forEach((p) => p.skip());
      } else if (typeof value2.type === "string") {
        this.get(key2).skip();
      }
    }
  }
  unSkip() {
    this.assertNotRemoved();
    this.ctx.setNotSkipped(this);
    this.ctx.pushToQueue([this], "unSkipped");
  }
  unskip() {
    this.unSkip();
  }
  unSkipChildren() {
    var _a2;
    this.assertNotRemoved();
    this.assertNotNull("unSkipChildren");
    (_a2 = this.ctx.pathCache.get(this)) === null || _a2 === void 0 ? void 0 : _a2.forEach((p) => p.unSkip());
  }
  unskipChildren() {
    this.unSkipChildren();
  }
  traverse(visitors, state) {
    this.assertNotNull("traverse");
    Traverser.traverseNode({
      node: this.node,
      parentPath: this.parentPath,
      visitors,
      state,
      ctx: this.ctx,
      expand: true
    });
  }
  //#endregion
  //#region Ancestry
  findParent(predicate) {
    let parent = this.parentPath;
    while (parent != null) {
      if (predicate(parent))
        return parent;
      parent = parent.parentPath;
    }
    return null;
  }
  find(predicate) {
    let nodePath = this;
    while (nodePath != null) {
      if (predicate(nodePath))
        return nodePath;
      nodePath = nodePath.parentPath;
    }
    return null;
  }
  getFunctionParent() {
    return this.findParent((p) => is2.function(p));
  }
  getAncestry() {
    const ancestors = [];
    let ancestor = this;
    while (ancestor != null) {
      ancestors.push(ancestor);
      ancestor = ancestor.parentPath;
    }
    return ancestors;
  }
  isAncestorOf(path) {
    return path.isDescendantOf(this);
  }
  isDescendantOf(path) {
    return this.findParent((p) => p === path) != null;
  }
  //#endregion
  //#region Modification
  updateSiblingIndex(fromIndex, incrementBy) {
    var _a2;
    if (this.container.length === 0)
      return;
    (_a2 = this.ctx.pathCache.get(this.parentPath)) === null || _a2 === void 0 ? void 0 : _a2.forEach((path) => {
      if (path.key >= fromIndex) {
        path.key += incrementBy;
      }
    });
  }
  insertBefore(nodes) {
    this.assertNotRemoved();
    if (!Array.isArray(this.container)) {
      throw new Error("Can not insert before a node where `container` is not an Array");
    }
    const key2 = this.key;
    for (let i = 0; i < nodes.length; i++) {
      runInsertionValidation(nodes[i], key2 + i, this.listKey, this.parent);
    }
    this.container.splice(key2, 0, ...nodes);
    this.updateSiblingIndex(key2, nodes.length);
    const newPaths = nodes.map((node2, idx) => _NodePath.for({
      node: node2,
      key: key2 + idx,
      listKey: this.listKey,
      parentPath: this.parentPath,
      ctx: this.ctx
    }).init());
    this.ctx.pushToQueue(newPaths, "new");
    return newPaths;
  }
  insertAfter(nodes) {
    this.assertNotRemoved();
    if (!Array.isArray(this.container)) {
      throw new Error("Can not insert after a node where `container` is not an Array");
    }
    const key2 = this.key;
    for (let i = 0; i < nodes.length; i++) {
      runInsertionValidation(nodes[i], key2 + i + 1, this.listKey, this.parent);
    }
    this.container.splice(key2 + 1, 0, ...nodes);
    this.updateSiblingIndex(key2 + 1, nodes.length);
    const newPaths = nodes.map((node2, idx) => _NodePath.for({
      node: node2,
      key: key2 + idx + 1,
      listKey: this.listKey,
      parentPath: this.parentPath,
      ctx: this.ctx
    }).init());
    this.ctx.pushToQueue(newPaths, "new");
    return newPaths;
  }
  unshiftContainer(listKey, nodes) {
    this.assertNotRemoved();
    const firstNode = this.node[listKey][0];
    const lastNodePath = _NodePath.for({
      node: firstNode,
      key: 0,
      listKey,
      parentPath: this,
      ctx: this.ctx
    });
    const newPaths = lastNodePath.insertBefore(nodes);
    return newPaths;
  }
  pushContainer(listKey, nodes) {
    this.assertNotRemoved();
    const container = this.node[listKey];
    const lastNode = container[container.length - 1];
    const lastNodePath = _NodePath.for({
      node: lastNode,
      key: container.length - 1,
      listKey,
      parentPath: this,
      ctx: this.ctx
    });
    const newPaths = lastNodePath.insertAfter(nodes);
    return newPaths;
  }
  get(key2) {
    if (this.node == null) {
      throw new Error("Can not use method `get` on a null NodePath");
    }
    const value2 = this.node[key2];
    if (Array.isArray(value2)) {
      return value2.map((node2, index) => _NodePath.for({
        node: node2,
        key: index,
        listKey: key2,
        parentPath: this,
        ctx: this.ctx
      }).init());
    } else if (value2 != null && typeof value2.type == "string") {
      return _NodePath.for({
        node: value2,
        key: key2,
        listKey: null,
        parentPath: this,
        ctx: this.ctx
      }).init();
    }
    return _NodePath.for({
      node: null,
      key: key2,
      listKey: null,
      parentPath: this,
      ctx: this.ctx
    }).init();
  }
  getSibling(key2) {
    if (this.parentPath == null) {
      this.throwNoParent("getSibling");
    }
    if (typeof key2 === "string") {
      return this.parentPath.get(key2);
    } else if (this.listKey != null) {
      return this.parentPath.get(this.listKey)[key2];
    }
  }
  getOpposite() {
    switch (this.key) {
      case "left":
        return this.getSibling("right");
      case "right":
        return this.getSibling("left");
    }
  }
  getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  getAllPrevSiblings() {
    if (this.parentPath == null) {
      this.throwNoParent("getAllPrevSiblings");
    }
    return this.parentPath.get(this.listKey).slice(0, this.key).reverse();
  }
  getAllNextSiblings() {
    if (this.parentPath == null) {
      this.throwNoParent("getAllNextSiblings");
    }
    return this.parentPath.get(this.listKey).slice(this.key + 1);
  }
  has(key2) {
    var _a2;
    const value2 = (_a2 = this.node) === null || _a2 === void 0 ? void 0 : _a2[key2];
    if (value2 != null && Array.isArray(value2) && value2.length === 0) {
      return false;
    }
    return !!value2;
  }
  is(key2) {
    var _a2;
    return !!((_a2 = this.node) === null || _a2 === void 0 ? void 0 : _a2[key2]);
  }
  //#endregion
  //#region Removal
  onRemove() {
    const { parent, key: key2, listKey } = this;
    const parentT = parent.type;
    const parentPath = this.parentPath;
    this.ctx.newSkipPathStack();
    switch (true) {
      case (parentT === "ExpressionStatement" && key2 === "expression"):
      case (is2.exportDeclaration(parent) && key2 === "declaration"):
      case ((parentT === "WhileStatement" || parentT === "SwitchCase") && key2 === "test"):
      case (parentT === "LabeledStatement" && key2 === "body"):
      case (parentT === "VariableDeclaration" && listKey === "declarations" && parent.declarations.length === 1):
        parentPath.remove();
        return true;
      case parentT === "BinaryExpression":
        parentPath.replaceWith(parent[key2 === "right" ? "left" : "right"]);
        return true;
      case (parentT === "IfStatement" && key2 === "consequent"):
      case ((parentT === "ArrowFunctionExpression" || is2.loop(parent)) && key2 === "body"):
        if (parentT === "ArrowFunctionExpression") {
          parent.expression = false;
        }
        this.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
    }
    this.ctx.restorePrevSkipPathStack();
    if (this.scope != null)
      Scope5.handleRemoval(this.scope, this);
    return false;
  }
  markRemoved() {
    var _a2;
    (_a2 = this.ctx.pathCache.get(this.parentPath)) === null || _a2 === void 0 ? void 0 : _a2.delete(this.node);
    this.removed = true;
  }
  remove() {
    if (this.removed) {
      throw new Error("Node is already removed");
    }
    if (this.container == null) {
      this.throwNoParent("remove");
    }
    if (this.onRemove()) {
      return this.markRemoved();
    }
    if (this.listKey != null) {
      const key2 = this.key;
      const container = this.container;
      container.splice(key2, 1);
      this.markRemoved();
      this.updateSiblingIndex(key2 + 1, -1);
    } else if (this.key != null) {
      this.container[this.key] = null;
      this.markRemoved();
    }
  }
  //#endregion
  //#region Replacement
  replaceWith(node2) {
    if (this.container == null) {
      this.throwNoParent("replaceWith");
    }
    if (this.removed) {
      throw new Error("Node is already removed");
    }
    runInsertionValidation(node2, this.key, this.listKey, this.parent);
    this.container[this.key] = node2;
    this.markRemoved();
    const newPath = _NodePath.for({
      node: node2,
      key: this.key,
      listKey: this.listKey,
      parentPath: this.parentPath,
      ctx: this.ctx
    }).init();
    this.ctx.pushToQueue([newPath], "new");
    return newPath;
  }
  replaceWithMultiple(nodes) {
    if (this.container == null) {
      this.throwNoParent("replaceWith");
    }
    if (this.removed) {
      throw new Error("Node is already removed");
    }
    const newPath = this.replaceWith(nodes[0]);
    return [newPath].concat(newPath.insertAfter(nodes.slice(1)));
  }
};

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/traverse.mjs
var Traverser = class _Traverser {
  constructor(visitors) {
    this.visitors = visitors;
  }
  visitPath(visitorCtx, path, state, visitedPaths, visitOnlyChildren = false) {
    const { node: node2, ctx } = path;
    if (visitedPaths.has(path) || path.removed || node2 == null) {
      return;
    }
    const nodeType = node2.type;
    const visitor = this.visitors[nodeType] || {};
    ctx.newQueue();
    const cleanup = () => ctx.popQueue();
    if (!visitOnlyChildren) {
      path.init();
      if (ctx.shouldSkip(path))
        return cleanup();
      if (visitor.enter != null) {
        visitor.enter.call(visitorCtx, path, state);
        if (ctx.shouldSkip(path) || visitorCtx.stopped)
          return cleanup();
      }
    }
    const keys = visitorKeys[nodeType] || Object.keys(node2);
    for (let i = 0; i < keys.length; i++) {
      const key2 = keys[i];
      const value2 = node2[key2];
      if (value2 == null)
        continue;
      if (Array.isArray(value2)) {
        const childNodePaths = value2.map((childNode, index) => NodePath.for({
          node: childNode,
          key: index,
          listKey: key2,
          parentPath: path,
          ctx
        }).init());
        for (let i2 = 0; i2 < childNodePaths.length; i2++) {
          this.visitPath(visitorCtx, childNodePaths[i2], state, visitedPaths);
          if (visitorCtx.stopped)
            return cleanup();
        }
      } else if (typeof value2.type === "string") {
        this.visitPath(visitorCtx, NodePath.for({
          node: value2,
          key: key2,
          listKey: null,
          parentPath: path,
          ctx
        }).init(), state, visitedPaths);
        if (visitorCtx.stopped)
          return cleanup();
      }
    }
    if (!visitOnlyChildren && visitor.leave != null) {
      visitor.leave.call(visitorCtx, path, state);
      if (visitorCtx.stopped)
        return cleanup();
    }
    visitedPaths.add(path);
    const { new: newPaths, unSkipped: unSkippedPaths } = cleanup();
    for (let i = 0; i < newPaths.length; i++) {
      if (visitorCtx.stopped)
        break;
      this.visitPath(visitorCtx, newPaths[i], state, visitedPaths);
    }
    for (let i = 0; i < unSkippedPaths.length; i++) {
      if (visitorCtx.stopped)
        break;
      this.visitPath(visitorCtx, unSkippedPaths[i], state, visitedPaths);
    }
  }
  static expandVisitors(visitors) {
    const expandedVisitors = /* @__PURE__ */ Object.create(null);
    Object.keys(visitors).forEach((keyName) => {
      const keys = [].concat(...keyName.split("|").map((key2) => key2 in aliases ? Object.keys(aliases[key2]) : [key2]));
      const visitor = visitors[keyName];
      if (typeof visitor == "function") {
        keys.forEach((key2) => {
          expandedVisitors[key2] = { enter: visitor };
        });
      } else if (typeof visitor == "object") {
        keys.forEach((key2) => {
          expandedVisitors[key2] = {
            enter: visitor.enter,
            leave: visitor.leave
          };
        });
      }
    });
    return expandedVisitors;
  }
  static traverseNode(data2) {
    const visitorCtx = {
      stopped: false,
      stop() {
        this.stopped = true;
      }
    };
    const prevNodeValidationEnabled = getNodeValidationEnabled();
    setNodeValidationEnabled(data2.ctx.shouldValidateNodes);
    new _Traverser(data2.expand ? this.expandVisitors(data2.visitors) : data2.visitors).visitPath(visitorCtx, NodePath.for({
      node: data2.node,
      key: null,
      listKey: null,
      parentPath: data2.parentPath,
      ctx: data2.ctx
    }), data2.state, /* @__PURE__ */ new WeakSet(), data2.visitOnlyChildren);
    setNodeValidationEnabled(prevNodeValidationEnabled);
  }
};
var traverse = (node2, visitors, state) => {
  const ctx = new Context(visitors.$);
  if (node2.type !== "Program") {
    ctx.makeScope = false;
  }
  Traverser.traverseNode({
    node: node2,
    parentPath: null,
    visitors,
    state,
    ctx,
    expand: true
  });
};

// ../../node_modules/.pnpm/estree-toolkit@1.7.1/node_modules/estree-toolkit/dist-es/utils/hasBinding.mjs
var hasBinding = (() => {
  const findInPattern = (node2, bindingName) => {
    switch (node2.type) {
      case "Identifier":
        return node2.name === bindingName;
      case "ObjectPattern": {
        const { properties } = node2;
        for (let i = 0; i < properties.length; i++) {
          const property = properties[i];
          if (property.type === "RestElement") {
            if (findInPattern(property.argument, bindingName))
              return true;
          } else {
            if (property.value != null) {
              if (findInPattern(property.value, bindingName))
                return true;
            } else {
              if (!property.computed && property.key.type === "Identifier" && property.key.name === bindingName) {
                return true;
              }
            }
          }
        }
        break;
      }
      case "ArrayPattern": {
        const { elements: elements2 } = node2;
        for (let i = 0; i < elements2.length; i++) {
          const element = elements2[i];
          if (element == null)
            continue;
          if (findInPattern(element, bindingName))
            return true;
        }
        break;
      }
      case "RestElement":
        return findInPattern(node2.argument, bindingName);
      case "AssignmentPattern":
        return findInPattern(node2.left, bindingName);
    }
    return false;
  };
  const findInVariableDeclaration = (node2, bindingName) => {
    const { declarations } = node2;
    for (let i = 0; i < declarations.length; i++) {
      if (findInPattern(declarations[i].id, bindingName))
        return true;
    }
    return false;
  };
  const findInImportDeclaration = (node2, bindingName) => {
    for (let i = 0; i < node2.specifiers.length; i++) {
      const specifier = node2.specifiers[i];
      switch (specifier.type) {
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
          if (specifier.local.name === bindingName)
            return true;
          break;
        case "ImportSpecifier":
          if (specifier.local != null) {
            if (specifier.local.name === bindingName)
              return true;
          } else {
            if (specifier.imported.name === bindingName)
              return true;
          }
          break;
      }
    }
    return false;
  };
  const findInStatements = (statements, bindingName) => {
    var _a2;
    for (let i = 0; i < statements.length; i++) {
      const statement = statements[i];
      switch (statement.type) {
        case "ImportDeclaration": {
          if (findInImportDeclaration(statement, bindingName)) {
            return true;
          }
          break;
        }
        case "VariableDeclaration": {
          if (findInVariableDeclaration(statement, bindingName)) {
            return true;
          }
          break;
        }
        case "FunctionDeclaration":
        case "ClassDeclaration": {
          if (((_a2 = statement.id) === null || _a2 === void 0 ? void 0 : _a2.name) === bindingName)
            return true;
          break;
        }
      }
    }
    return false;
  };
  const parentTypes = [
    "BlockStatement",
    "ForStatement",
    "ForInStatement",
    "ForOfStatement",
    "FunctionDeclaration",
    "FunctionExpression",
    "ArrowFunctionExpression",
    "ClassDeclaration",
    "ClassExpression",
    "Program"
  ];
  const findInParent = (path, bindingName) => {
    var _a2, _b;
    const parent = path.findParent((p) => parentTypes.includes(p.type));
    if (parent != null && parent.node != null) {
      const { node: node2 } = parent;
      switch (node2.type) {
        case "BlockStatement": {
          if (findInStatements(node2.body, bindingName)) {
            return true;
          }
          break;
        }
        case "ForStatement": {
          if (node2.init != null && node2.init.type === "VariableDeclaration") {
            if (findInVariableDeclaration(node2.init, bindingName)) {
              return true;
            }
          }
          break;
        }
        case "ForInStatement":
        case "ForOfStatement": {
          if (node2.left.type === "VariableDeclaration") {
            if (findInVariableDeclaration(node2.left, bindingName)) {
              return true;
            }
          }
          break;
        }
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression": {
          if (node2.type !== "ArrowFunctionExpression" && ((_a2 = node2.id) === null || _a2 === void 0 ? void 0 : _a2.name) === bindingName)
            return true;
          for (let i = 0; i < node2.params.length; i++) {
            if (findInPattern(node2.params[i], bindingName)) {
              return true;
            }
          }
          break;
        }
        case "ClassExpression":
        case "ClassDeclaration": {
          if (((_b = node2.id) === null || _b === void 0 ? void 0 : _b.name) === bindingName)
            return true;
          break;
        }
        case "Program": {
          if (findInStatements(node2.body, bindingName)) {
            return true;
          }
          break;
        }
      }
      return findInParent(parent, bindingName);
    }
    return false;
  };
  return (path, bindingName) => {
    return findInParent(path, bindingName);
  };
})();

// src/compiler/optimizer/optimize.ts
function visit_component(component, parent_component, props, state) {
  let component_state = state.components.get(component);
  let initial_visit = true;
  if (component_state === void 0) {
    component_state = {
      props,
      references: [],
      is_static: true,
      needs_template: state.context.needs_template,
      template: {
        open: null,
        traverse: [],
        close: null,
        components: [],
        blocks: /* @__PURE__ */ new Map(),
        render_effects: /* @__PURE__ */ new Map()
      }
    };
    if (parent_component !== null) {
      component_state.references.push(parent_component);
    }
    state.components.set(component, component_state);
  } else {
    initial_visit = false;
    if (state.context.needs_template && !component_state.needs_template) {
      component_state.needs_template = true;
      component_state.is_static = false;
    }
  }
  const template2 = component_state.template;
  const visitor = {
    CallExpression(path) {
      const callee = path.node.callee;
      const callee_path = path.get("callee");
      if (!is2.identifier(callee)) {
        return;
      }
      const callee_name = callee.name;
      const args = path.node.arguments;
      const grand_path = path.parentPath?.parentPath;
      const blocks = component_state.template.blocks;
      if (initial_visit) {
        if (is2.variableDeclaration(grand_path) && is_svelte_import(callee_path) && (callee_name === "open" || callee_name === "open_frag") && // TODO: this won't optimize slots, needs some thought
        state.context.type === "component") {
          template2.open = grand_path;
        }
        if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && (callee_name === "close" || callee_name === "close_frag") && // TODO: this won't optimize slots, needs some thought
        state.context.type === "component") {
          template2.close = path;
        }
        if (is2.variableDeclaration(grand_path) && is_svelte_import(callee_path) && (callee_name === "child" || callee_name === "child_frag" || callee_name === "sibling") && state.context.type === "component") {
          template2.traverse.push(grand_path);
        }
        if (is_svelte_import(callee_path) && (callee_name === "delegated_event" || callee_name === "transition" || callee_name === "in_fn" || callee_name === "out" || callee_name === "event" || callee_name === "action" || callee_name === "slot" || callee_name === "auto_focus" || callee_name === "component" || callee_name === "element") && state.context.type === "component") {
          component_state.is_static = false;
        }
        if (is_svelte_import(callee_path) && (callee_name === "bind_value" || callee_name === "bind_content_editable" || callee_name === "bind_group" || callee_name === "bind_property" || callee_name === "bind_scroll" || callee_name === "bind_checked" || callee_name === "bind_this" || callee_name === "bind_online") && state.context.type === "component") {
          component_state.is_static = false;
        }
        if (is2.variableDeclaration(grand_path) && is_svelte_import(callee_path) && (callee_name === "source" || callee_name === "prop_source" || callee_name === "derived") && state.context.type === "component") {
          component_state.is_static = false;
        }
        if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && (callee_name === "effect" || callee_name === "pre_effect") && state.context.type === "component") {
          component_state.is_static = false;
        }
        if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && callee_name === "render_effect" && state.context.type === "component") {
          const closure = path.get("arguments")[0];
          let render_effect = template2.render_effects.get(path);
          if (render_effect === void 0) {
            render_effect = {
              is_static: true,
              anchors: /* @__PURE__ */ new Set(),
              expressions: /* @__PURE__ */ new Set()
            };
            template2.render_effects.set(path, render_effect);
          }
          let is_render_effect_static = true;
          closure.traverse({
            Identifier(path2) {
              if (is_reactive(path2, props, false)) {
                is_render_effect_static = false;
              } else if (path2.node.name.includes("_anchor")) {
                const binding = path2.scope.getBinding(path2.node.name);
                if (binding != null && is2.variableDeclarator(binding.path) && is2.variableDeclaration(binding.path.parentPath)) {
                  render_effect.anchors.add(binding.path.parentPath);
                }
              } else if (path2.node.name.includes("_expression")) {
                const binding = path2.scope.getBinding(path2.node.name);
                if (binding != null && is2.variableDeclarator(binding.path) && is2.variableDeclaration(binding.path.parentPath)) {
                  render_effect.expressions.add(binding.path.parentPath);
                }
              }
            }
          });
          if (!is_render_effect_static) {
            render_effect.is_static = false;
            component_state.is_static = false;
          }
          path.skipChildren();
        }
        if (is2.variableDeclaration(grand_path) && is_svelte_import(callee_path) && callee_name === "prop" && state.context.type === "component") {
          const prop_key = args[1];
          if (is2.literal(prop_key) && props !== "unknown") {
            const prop2 = props.get(prop_key.value);
            if (prop2 !== void 0) {
              prop2.path = grand_path;
              if (prop2.type === "dynamic") {
                component_state.is_static = false;
              }
            }
          } else {
            component_state.is_static = false;
          }
        }
      }
      if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && callee_name.startsWith("if_block")) {
        let condition = path.get("arguments")[1];
        if (is2.arrowFunctionExpression(condition)) {
          condition = condition.get("body");
        }
        const is_static = !state.context.needs_template && !is_reactive(condition, props, false);
        let if_block = blocks.get(path);
        if (if_block === void 0) {
          if_block = {
            condition: condition.node,
            is_static,
            type: "if"
          };
          blocks.set(path, if_block);
        } else if (!is_static) {
          if_block.is_static = false;
        }
        path.skipChildren();
        if (!if_block.is_static) {
          component_state.is_static = false;
          const consequent_fn = path.get("arguments")[0];
          const alternate_fn = path.get("arguments")[1];
          const prev_needs_template = state.context.needs_template;
          state.context.needs_template = true;
          if (is2.function(consequent_fn)) {
            consequent_fn.traverse(visitor);
          }
          if (is2.function(alternate_fn)) {
            alternate_fn.traverse(visitor);
          }
          state.context.needs_template = prev_needs_template;
        }
      }
      if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && callee_name === "await_block") {
        component_state.is_static = false;
      }
      if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && callee_name === "key") {
        component_state.is_static = false;
      }
      if (is2.expressionStatement(path.parentPath) && is_svelte_import(callee_path) && callee_name === "each") {
        let collection = path.get("arguments")[1];
        if (is2.arrowFunctionExpression(collection)) {
          collection = collection.get("body");
        }
        const is_static = !state.context.needs_template && !is_reactive(collection, props, false);
        let each_block = blocks.get(path);
        if (each_block === void 0) {
          each_block = {
            collection: collection.node,
            is_static,
            type: "each"
          };
          blocks.set(path, each_block);
        } else {
          error(null, "TODO", "");
        }
        path.skipChildren();
        if (!each_block.is_static) {
          component_state.is_static = false;
          const each_fn = path.get("arguments")[4];
          const else_fn = path.get("arguments")[5];
          const prev_needs_template = state.context.needs_template;
          state.context.needs_template = true;
          if (is2.function(each_fn)) {
            each_fn.traverse(visitor);
          }
          if (is2.function(else_fn)) {
            else_fn.traverse(visitor);
          }
          state.context.needs_template = prev_needs_template;
        }
      }
      if (callee_name[0] === callee_name[0].toUpperCase() && is2.expressionStatement(path.parentPath)) {
        const binding = path.scope.getBinding(callee_name);
        if (binding != null && is2.functionDeclaration(binding.path) && binding.path.node.params.length === 3 && is2.identifier(binding.path.node.params[1]) && binding.path.node.params[1].name === "$$props") {
          const context = {
            parent: state.context,
            needs_template: state.context.needs_template,
            type: "component"
          };
          state.context = context;
          const child_props = get_props(path.get("arguments")[1], props);
          const child_component_state = visit_component(
            binding.path,
            component_state,
            child_props,
            state
          );
          if (!child_component_state.is_static) {
            component_state.is_static = false;
          }
          template2.components.push({
            path,
            state: child_component_state
          });
          state.context = state.context.parent;
        }
      }
    },
    Function: {
      enter(path) {
        if (path !== component) {
          const context = {
            needs_template: state.context.needs_template,
            parent: state.context,
            type: "function"
          };
          state.context = context;
        }
      },
      leave(path) {
        if (path !== component) {
          state.context = state.context.parent;
        }
      }
    }
  };
  component.traverse(visitor);
  return component_state;
}
function get_props(props_arg, parent_props) {
  const props = /* @__PURE__ */ new Map();
  if (is2.objectExpression(props_arg)) {
    for (const property of props_arg.get("properties")) {
      if (is2.property(property) && (is2.identifier(property.node.key) || is2.literal(property.node.key))) {
        const value2 = property.get("value");
        const kind = property.node.kind;
        if (kind === "init") {
          const dynamic = is_reactive(value2, parent_props, true);
          props.set(
            is2.literal(property.node.key) ? property.node.key.value : property.node.key.name,
            {
              type: dynamic ? "dynamic" : "static",
              path: null
            }
          );
        } else if (kind === "get" && is2.functionExpression(value2) && value2.node.body.body.length === 1 && is2.returnStatement(value2.node.body.body[0])) {
          const expression = value2.get("body").get("body")[0].get("argument");
          const dynamic = is_reactive(expression, parent_props, true);
          props.set(
            is2.literal(property.node.key) ? property.node.key.value : property.node.key.name,
            {
              type: dynamic ? "dynamic" : "static",
              path: null
            }
          );
        } else {
          return "unknown";
        }
      } else {
        error(null, "TODO", "");
        return "unknown";
      }
    }
  } else {
    error(null, "TODO", "");
    return "unknown";
  }
  return props;
}
function is_reactive(path, props, functions_are_reactive) {
  if (is2.identifier(path)) {
    const binding = path.scope.getBinding(path.node.name);
    if (binding != null && is2.variableDeclarator(binding.path)) {
      const init2 = binding.path.get("init");
      if (init2.node !== null && is_reactive(init2, props, functions_are_reactive)) {
        return true;
      }
    }
  } else if (is2.literal(path)) {
    return false;
  } else if (is2.unaryExpression(path)) {
    if (is_reactive(path.get("argument"), props, functions_are_reactive)) {
      return true;
    }
  } else if (is2.updateExpression(path)) {
    if (is_reactive(path.get("argument"), props, functions_are_reactive)) {
      return true;
    }
  } else if (is2.assignmentExpression(path)) {
    if (is_reactive(path.get("left"), props, functions_are_reactive)) {
      return true;
    }
    if (is_reactive(path.get("right"), props, functions_are_reactive)) {
      return true;
    }
  } else if (is2.sequenceExpression(path)) {
    for (const expression of path.get("expressions")) {
      if (is_reactive(expression, props, functions_are_reactive)) {
        return true;
      }
    }
  } else if (is2.conditionalExpression(path)) {
    if (is_reactive(path.get("test"), props, functions_are_reactive)) {
      return true;
    }
    if (is_reactive(path.get("consequent"), props, functions_are_reactive)) {
      return true;
    }
    if (is_reactive(path.get("alternate"), props, functions_are_reactive)) {
      return true;
    }
  } else if (is2.binaryExpression(path)) {
    if (is_reactive(path.get("left"), props, functions_are_reactive)) {
      return true;
    }
    if (is_reactive(path.get("right"), props, functions_are_reactive)) {
      return true;
    }
  } else if (is2.logicalExpression(path)) {
    if (is_reactive(path.get("left"), props, functions_are_reactive)) {
      return true;
    }
    if (is_reactive(path.get("right"), props, functions_are_reactive)) {
      return true;
    }
  } else if (is2.arrayExpression(path)) {
    for (const element of path.get("elements")) {
      if (element !== null && is_reactive(element, props, functions_are_reactive)) {
        return true;
      }
    }
  } else if (is2.objectExpression(path)) {
    for (const property of path.get("properties")) {
      if (is_reactive(property, props, functions_are_reactive)) {
        return true;
      }
    }
  } else if (is2.function(path)) {
    return functions_are_reactive;
  } else if (is2.callExpression(path)) {
    if (is2.identifier(path.node.callee)) {
      const prop_key = path.node.arguments[1];
      const callee_name = path.node.callee.name;
      if (is2.variableDeclaration(path.parentPath?.parentPath) && is_svelte_import(path.get("callee")) && callee_name === "prop" && is2.literal(prop_key) && props !== "unknown" && props !== null) {
        const prop2 = props.get(prop_key.value);
        if (prop2 !== void 0 && prop2.type === "static") {
          return false;
        }
      }
      const binding = path.scope.getBinding(callee_name);
      if (binding != null) {
        if (is2.variableDeclarator(binding.path) && is2.variableDeclaration(binding.path.parentPath) && is2.callExpression(binding.path.node.init) && is2.identifier(binding.path.node.init.callee) && binding.path.node.init.callee.name === "prop" && is_svelte_import(binding.path.get("init").get("callee")) && is2.literal(binding.path.node.init.arguments[1]) && props !== "unknown" && props !== null) {
          const prop2 = props.get(binding.path.node.init.arguments[1].value);
          if (prop2 !== void 0 && prop2.type === "static") {
            return false;
          }
        }
      }
      if (is2.variableDeclaration(path.parentPath?.parentPath) && is_svelte_import(path.get("callee")) && (callee_name === "child" || callee_name === "child_frag" || callee_name === "sibling")) {
        return false;
      }
    }
    return true;
  } else if (is2.memberExpression(path)) {
    return true;
  } else {
    error(null, "TODO", "");
  }
  return false;
}
function is_svelte_import(path) {
  if (is2.identifier(path)) {
    const binding = path.scope.getBinding(path.node.name);
    if (binding != null && is2.importSpecifier(binding.path)) {
      const import_declaration = binding.path.parentPath;
      if (import_declaration.node.source.value.includes("vendor")) {
        return true;
      }
    }
  }
  return false;
}
function is_removed(path) {
  let current_path = path;
  while (current_path !== null) {
    if (current_path.removed) {
      return true;
    }
    current_path = current_path.parentPath;
  }
  return false;
}
function has_references(name8, scope) {
  const binding = scope.getBinding(name8);
  let has_references2 = false;
  for (const reference of binding.references) {
    if (!is_removed(reference)) {
      has_references2 = true;
      break;
    }
  }
  return has_references2;
}
function optimize_component(component_state) {
  const template2 = component_state.template;
  const is_static = component_state.is_static;
  if (template2.open !== null) {
    const arg_to_remove = template2.open.get("declarations")[0].get("init").get("arguments")[1];
    const template_path = arg_to_remove.scope.getBinding(arg_to_remove.node.name).path.parentPath;
    template_path.remove();
    if (is_static) {
      template2.open.remove();
    } else {
      arg_to_remove.remove();
    }
  }
  if (is_static && template2.close !== null) {
    template2.close.remove();
  }
  for (const [path, render_effect] of template2.render_effects) {
    if (render_effect.is_static) {
      path.remove();
      for (const anchor of render_effect.anchors) {
        anchor.remove();
      }
      for (const expression of render_effect.expressions) {
        expression.remove();
      }
    }
  }
  for (const [block_path, block2] of template2.blocks) {
    if (is_static || block2.is_static) {
      if (block2.type === "each") {
        const collection = block2.collection;
        if (is2.identifier(collection)) {
          const binding = block_path.scope.getBinding(collection.name);
          if (binding != null && binding.references.length === 1) {
            binding.path.remove();
          }
        }
      }
      block_path.remove();
    }
  }
  const reverse_template = template2.traverse.slice().reverse();
  for (const path of reverse_template) {
    const id2 = path.node.declarations[0].id;
    if (is_static || !has_references(id2.name, path.scope)) {
      if (!path.removed) {
        path.remove();
      }
    }
  }
  for (const { path, state } of template2.components) {
    if (state.is_static) {
      path.parentPath?.getPrevSibling()?.remove();
    }
  }
  if (component_state.props !== "unknown") {
    for (const [prop2, { path, type }] of component_state.props) {
      if (type === "static" && path !== null && !has_references(prop2, path.scope)) {
        path.remove();
      }
    }
  }
}
function is_optimizable(component_state) {
  if (component_state.needs_template || component_state.props === "unknown") {
    return false;
  }
  for (const [, { type }] of component_state.props) {
    if (type === "dynamic") {
      return false;
    }
  }
  return true;
}
function optimize_chunk(source, options) {
  const ast = parse3(source, {
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  });
  const context = {
    parent: null,
    needs_template: !options.hydrate,
    type: "module"
  };
  const state = {
    components: /* @__PURE__ */ new Map(),
    context
  };
  traverse(ast, {
    $: { scope: true },
    CallExpression(path) {
      const node2 = path.node;
      const callee = node2.callee;
      const args = node2.arguments;
      const first_arg = path.get("arguments")[0];
      if (is2.identifier(callee) && callee.name === "mount" && args.length === 2 && is2.arrowFunctionExpression(first_arg) && is2.callExpression(first_arg.node.body)) {
        if (!is_svelte_import(path.get("callee"))) {
          return;
        }
        const body = first_arg.get("body");
        const component_callee = body.node.callee;
        const component_args = body.node.arguments[1];
        if (!is2.identifier(component_callee) || component_args == null) {
          return;
        }
        const component_binding = path.scope.getBinding(component_callee.name);
        if (component_binding == null || !is2.functionDeclaration(component_binding.path) || component_binding.references.length !== 1) {
          return;
        }
        const component = component_binding.path;
        const component_node = component.node;
        if (component_node.params.length !== 3 || !is2.identifier(component_node.params[1]) || component_node.params[1].name !== "$$props") {
          return;
        }
        const context2 = {
          parent: state.context,
          needs_template: state.context.needs_template,
          type: "component"
        };
        state.context = context2;
        const props = get_props(body.get("arguments")[1], null);
        visit_component(component, null, props, state);
        state.context = state.context.parent;
      }
    }
  });
  for (const [, component_state] of state.components) {
    if (is_optimizable(component_state)) {
      optimize_component(component_state);
    }
  }
  return print(ast).code;
}

// src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);

// src/compiler/utils/push_array.js
function push_array3(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// src/compiler/utils/mapped_code.js
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset2, source_index) {
  if (map.mappings.length == 0)
    return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset2.column;
        }
        seg[2] += offset2.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\d\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  /**
   * @type {string}
   */
  string = (
    /** @type {any} */
    void 0
  );
  /**
   * @type {import('@ampproject/remapping').DecodedSourceMap}
   */
  map = (
    /** @type {any} */
    void 0
  );
  /**
   * @param {string} string
   * @param {import('@ampproject/remapping').DecodedSourceMap | null} map
   */
  constructor(string = "", map = null) {
    this.string = string;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "")
      return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0)
      return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed)
      m1.sources = sources;
    if (names_changed)
      m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array3(
      m1.mappings[m1.mappings.length - 1],
      /** @type {import('@ampproject/remapping').SourceMapSegment[]} */
      m2.mappings.shift()
    );
    push_array3(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {import('@ampproject/remapping').DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string, map) {
    const line_count = string.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string, map);
    }
    if (string == "")
      return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++)
      map.mappings.push([]);
    return new _MappedCode(string, map);
  }
  /**
   * @static
   * @param {import('../preprocess/private.js').Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source, file_basename, get_location }) {
    let offset2 = get_location(0);
    if (!offset2)
      offset2 = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source == "")
      return new _MappedCode(source, map);
    const line_list = source.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "")
          continue;
        map.mappings[line].push([column, 0, offset2.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset2.column;
    }
    return new _MappedCode(source, map);
  }
};
function combine_sourcemaps(filename, sourcemap_list) {
  if (sourcemap_list.length == 0)
    return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file)
    delete map.file;
  if (!map.sources.length)
    map.sources = [filename];
  return map;
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_2, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = atob(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}

// src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec3 = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line = converted_mappings[0];
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec3.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset2, { file_basename, filename, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset2),
    file_basename,
    filename
  };
}
function calculate_replacements(re2, get_replacement, source) {
  const replacements = [];
  source.replace(re2, (...match) => {
    replacements.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset2 = match[match.length - 2];
        return { offset: offset2, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements);
}
function perform_replacements(replacements, source) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset: offset2, length, replacement } of replacements) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source.source.slice(last_end, offset2), last_end, source)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset2 + length;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source.source.slice(last_end), last_end, source)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements, location);
}

// src/compiler/preprocess/index.js
var regex_filepath_separator = /[/\\]/;
function get_file_basename(filename) {
  return (
    /** @type {string} */
    filename.split(regex_filepath_separator).pop()
  );
}
var PreprocessResult = class {
  /** @type {string} */
  source;
  /** @type {string | undefined} */
  filename;
  // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
  // so we use sourcemap_list.unshift() to add new maps
  // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
  /**
   * @default []
   * @type {Array<import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap>}
   */
  sourcemap_list = [];
  /**
   * @default []
   * @type {string[]}
   */
  dependencies = [];
  /**
   * @type {string | null  }
   */
  file_basename = (
    /** @type {any} */
    void 0
  );
  /**
   * @type {ReturnType<typeof getLocator>}
   */
  get_location = (
    /** @type {any} */
    void 0
  );
  /**
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source, filename) {
    this.source = source;
    this.filename = filename;
    this.update_source({ string: source });
    this.file_basename = filename == null ? null : get_file_basename(filename);
  }
  /**
   * @param {import('./private.js').SourceUpdate} opts
   */
  update_source({ string: source, map, dependencies }) {
    if (source != null) {
      this.source = source;
      this.get_location = getLocator2(source);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {import('./public.js').Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      // @ts-expect-error TODO there might be a bug in hiding here
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map = void 0;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map?.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source) {
  const { file_basename, get_location } = source;
  const build_mapped_code = (code, offset2) => MappedCode.from_source(slice_source(code, offset2, source));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name8 = match[1];
    const value2 = match[2] || match[3] || match[4];
    attrs[name8] = !value2 || value2;
  }
  return attrs;
}
function stringify_tag_attributes(attributes2) {
  if (!attributes2)
    return;
  let value2 = Object.entries(attributes2).map(([key2, value3]) => value3 === true ? key2 : `${key2}="${value3}"`).join(" ");
  if (value2) {
    value2 = " " + value2;
  }
  return value2;
}
var regex_style_tags = /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi;
var regex_script_tags = /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
async function process_tag(tag_name, preprocessor, source) {
  const { filename, source: markup } = source;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes2 = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
    if (!attributes2 && !content)
      return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes2 || ""),
      markup,
      filename
    });
    if (!processed)
      return no_change();
    if (processed.dependencies)
      dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content)
      return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes2,
      stringify_tag_attributes(processed.attributes) ?? attributes2,
      slice_source(content, tag_offset, source)
    );
  }
  const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
  return { string, map, dependencies };
}
async function process_markup(process, source) {
  const processed = await process({
    content: source.source,
    filename: source.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source, preprocessor, options) {
  const filename = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source, filename);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}

// src/compiler/version.ts
var VERSION = "5.0.0-preview";

// src/compiler/index.ts
function map_start_end(source, start, end) {
  const locate = getLocator2(source, { offsetLine: 1 });
  return { start: locate(start), end: locate(end) };
}
function attach_pretty_error(error2, message, source, options) {
  const entries = [];
  const start = error2.start;
  if (start !== void 0) {
    const lines = source.split("\n");
    for (let i = Math.max(start.line - 5, 0); i < Math.min(start.line + 5, lines.length); i++) {
      entries.push({
        line: i,
        highlight: i === start.line,
        source: lines[i - 1]
      });
    }
  }
  error2.pretty_error = {
    entries,
    filename: options.filename,
    message
  };
}
function compile(source, options) {
  try {
    const parsed = parse14(source, {
      filename: options.filename ?? "<unknown>"
    });
    const analysis = analyze_component(parsed, options);
    const result = transform_component(analysis, source, options);
    return result;
  } catch (e) {
    const error2 = e;
    const message = error2.message;
    const node2 = error2.node;
    if (node2 && node2.start !== void 0 && node2.end !== void 0) {
      const { start, end } = map_start_end(source, node2.start, node2.end);
      error2.start = start;
      error2.end = end;
      error2.frame = frame(options.filename, source, start, end);
    }
    attach_pretty_error(error2, message, source, options);
    throw error2;
  }
}
function compileModule(source, options) {
  if (options.runes === false || !Runes.some((r) => source.includes(r))) {
    return null;
  }
  try {
    const analysis = analyze_module(parse4(source), options);
    if (analysis === null)
      return null;
    return transform_module(analysis, source, options);
  } catch (e) {
    const error2 = e;
    const message = error2.message;
    const node2 = error2.node;
    if (node2 && node2.start !== void 0 && node2.end !== void 0) {
      const { start, end } = map_start_end(source, node2.start, node2.end);
      error2.start = start;
      error2.end = end;
      error2.frame = frame(options.filename, source, start, end);
    }
    attach_pretty_error(error2, message, source, options);
    throw error2;
  }
}
function optimize(source, options) {
  return optimize_chunk(source, options);
}
export {
  VERSION,
  compile,
  compileModule,
  optimize,
  preprocess
};
//# sourceMappingURL=compiler.js.map
