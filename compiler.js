import {
  __commonJS,
  __toESM
} from "./chunk-LQ2VYIYD.js";

// ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.sourcemapCodec = {}));
    })(exports, function(exports2) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c2 = chars.charCodeAt(i);
        intToChar[i] = c2;
        charToInt[c2] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf(mappings, index);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state, j) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c2 = mappings.charCodeAt(pos++);
          integer = charToInt[c2];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        state[j] += value;
        return pos;
      }
      function hasMoreVlq(mappings, i, length) {
        if (i >= length)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode3(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon;
          }
          if (line.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 1);
            pos = encodeInteger(buf, pos, state, segment, 2);
            pos = encodeInteger(buf, pos, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state, segment, j) {
        const next2 = segment[j];
        let num = next2 - state[j];
        state[j] = next2;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports2.decode = decode;
      exports2.encode = encode3;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var properties = [["aria-activedescendant", {
      "type": "id"
    }], ["aria-atomic", {
      "type": "boolean"
    }], ["aria-autocomplete", {
      "type": "token",
      "values": ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      "type": "string"
    }], ["aria-brailleroledescription", {
      "type": "string"
    }], ["aria-busy", {
      "type": "boolean"
    }], ["aria-checked", {
      "type": "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      "type": "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      "type": "idlist"
    }], ["aria-description", {
      "type": "string"
    }], ["aria-details", {
      "type": "id"
    }], ["aria-disabled", {
      "type": "boolean"
    }], ["aria-dropeffect", {
      "type": "tokenlist",
      "values": ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      "type": "id"
    }], ["aria-expanded", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-flowto", {
      "type": "idlist"
    }], ["aria-grabbed", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-haspopup", {
      "type": "token",
      "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-invalid", {
      "type": "token",
      "values": ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      "type": "string"
    }], ["aria-labelledby", {
      "type": "idlist"
    }], ["aria-level", {
      "type": "integer"
    }], ["aria-live", {
      "type": "token",
      "values": ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      "type": "boolean"
    }], ["aria-multiselectable", {
      "type": "boolean"
    }], ["aria-orientation", {
      "type": "token",
      "values": ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      "type": "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      "type": "integer"
    }], ["aria-pressed", {
      "type": "tristate"
    }], ["aria-readonly", {
      "type": "boolean"
    }], ["aria-relevant", {
      "type": "tokenlist",
      "values": ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      "type": "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-setsize", {
      "type": "integer"
    }], ["aria-sort", {
      "type": "token",
      "values": ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      "type": "number"
    }], ["aria-valuemin", {
      "type": "number"
    }], ["aria-valuenow", {
      "type": "number"
    }], ["aria-valuetext", {
      "type": "string"
    }]];
    var ariaPropsMap = {
      entries: function entries() {
        return properties;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(properties), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key2, properties);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get2(key2) {
        var item = properties.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!ariaPropsMap.get(key2);
      },
      keys: function keys() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var dom = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]];
    var domMap = {
      entries: function entries() {
        return dom;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(dom), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key2, dom);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get2(key2) {
        var item = dom.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!domMap.get(key2);
      },
      keys: function keys() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(domMap, domMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = commandRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = compositeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = inputRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = landmarkRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = rangeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = roletypeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = sectionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = sectionheadRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    var _default = selectRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = structureRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = widgetRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = windowRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole());
    var _compositeRole = _interopRequireDefault(require_compositeRole());
    var _inputRole = _interopRequireDefault(require_inputRole());
    var _landmarkRole = _interopRequireDefault(require_landmarkRole());
    var _rangeRole = _interopRequireDefault(require_rangeRole());
    var _roletypeRole = _interopRequireDefault(require_roletypeRole());
    var _sectionRole = _interopRequireDefault(require_sectionRole());
    var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
    var _selectRole = _interopRequireDefault(require_selectRole());
    var _structureRole = _interopRequireDefault(require_structureRole());
    var _widgetRole = _interopRequireDefault(require_widgetRole());
    var _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    var _default = ariaAbstractRoles;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = alertRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    var _default = alertdialogRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = applicationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = articleRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = bannerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = blockquoteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = buttonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = captionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = cellRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = checkboxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = codeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = columnheaderRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = comboboxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = complementaryRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = contentinfoRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = definitionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = deletionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    var _default = dialogRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = directoryRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = documentRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = emphasisRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = feedRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = figureRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = formRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = genericRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    var _default = gridRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    var _default = gridcellRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = groupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = headingRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = imgRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = insertionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = linkRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = listRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = listboxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = listitemRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = logRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = mainRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = markRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = marqueeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = mathRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = menuRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    var _default = menubarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = menuitemRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    var _default = menuitemcheckboxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    var _default = menuitemradioRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    var _default = meterRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = navigationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = noneRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = noteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = optionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = paragraphRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = presentationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = progressbarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = radioRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = radiogroupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = regionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    var _default = rowRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = rowgroupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = rowheaderRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = scrollbarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = searchRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    var _default = searchboxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = separatorRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = sliderRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = spinbuttonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = statusRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = strongRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = subscriptRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = superscriptRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    var _default = switchRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    var _default = tabRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = tableRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    var _default = tablistRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = tabpanelRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = termRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = textboxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = timeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    var _default = timerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = toolbarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = tooltipRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = treeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    var _default = treegridRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    var _default = treeitemRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole());
    var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
    var _applicationRole = _interopRequireDefault(require_applicationRole());
    var _articleRole = _interopRequireDefault(require_articleRole());
    var _bannerRole = _interopRequireDefault(require_bannerRole());
    var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
    var _buttonRole = _interopRequireDefault(require_buttonRole());
    var _captionRole = _interopRequireDefault(require_captionRole());
    var _cellRole = _interopRequireDefault(require_cellRole());
    var _checkboxRole = _interopRequireDefault(require_checkboxRole());
    var _codeRole = _interopRequireDefault(require_codeRole());
    var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
    var _comboboxRole = _interopRequireDefault(require_comboboxRole());
    var _complementaryRole = _interopRequireDefault(require_complementaryRole());
    var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
    var _definitionRole = _interopRequireDefault(require_definitionRole());
    var _deletionRole = _interopRequireDefault(require_deletionRole());
    var _dialogRole = _interopRequireDefault(require_dialogRole());
    var _directoryRole = _interopRequireDefault(require_directoryRole());
    var _documentRole = _interopRequireDefault(require_documentRole());
    var _emphasisRole = _interopRequireDefault(require_emphasisRole());
    var _feedRole = _interopRequireDefault(require_feedRole());
    var _figureRole = _interopRequireDefault(require_figureRole());
    var _formRole = _interopRequireDefault(require_formRole());
    var _genericRole = _interopRequireDefault(require_genericRole());
    var _gridRole = _interopRequireDefault(require_gridRole());
    var _gridcellRole = _interopRequireDefault(require_gridcellRole());
    var _groupRole = _interopRequireDefault(require_groupRole());
    var _headingRole = _interopRequireDefault(require_headingRole());
    var _imgRole = _interopRequireDefault(require_imgRole());
    var _insertionRole = _interopRequireDefault(require_insertionRole());
    var _linkRole = _interopRequireDefault(require_linkRole());
    var _listRole = _interopRequireDefault(require_listRole());
    var _listboxRole = _interopRequireDefault(require_listboxRole());
    var _listitemRole = _interopRequireDefault(require_listitemRole());
    var _logRole = _interopRequireDefault(require_logRole());
    var _mainRole = _interopRequireDefault(require_mainRole());
    var _markRole = _interopRequireDefault(require_markRole());
    var _marqueeRole = _interopRequireDefault(require_marqueeRole());
    var _mathRole = _interopRequireDefault(require_mathRole());
    var _menuRole = _interopRequireDefault(require_menuRole());
    var _menubarRole = _interopRequireDefault(require_menubarRole());
    var _menuitemRole = _interopRequireDefault(require_menuitemRole());
    var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
    var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
    var _meterRole = _interopRequireDefault(require_meterRole());
    var _navigationRole = _interopRequireDefault(require_navigationRole());
    var _noneRole = _interopRequireDefault(require_noneRole());
    var _noteRole = _interopRequireDefault(require_noteRole());
    var _optionRole = _interopRequireDefault(require_optionRole());
    var _paragraphRole = _interopRequireDefault(require_paragraphRole());
    var _presentationRole = _interopRequireDefault(require_presentationRole());
    var _progressbarRole = _interopRequireDefault(require_progressbarRole());
    var _radioRole = _interopRequireDefault(require_radioRole());
    var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
    var _regionRole = _interopRequireDefault(require_regionRole());
    var _rowRole = _interopRequireDefault(require_rowRole());
    var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
    var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
    var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
    var _searchRole = _interopRequireDefault(require_searchRole());
    var _searchboxRole = _interopRequireDefault(require_searchboxRole());
    var _separatorRole = _interopRequireDefault(require_separatorRole());
    var _sliderRole = _interopRequireDefault(require_sliderRole());
    var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
    var _statusRole = _interopRequireDefault(require_statusRole());
    var _strongRole = _interopRequireDefault(require_strongRole());
    var _subscriptRole = _interopRequireDefault(require_subscriptRole());
    var _superscriptRole = _interopRequireDefault(require_superscriptRole());
    var _switchRole = _interopRequireDefault(require_switchRole());
    var _tabRole = _interopRequireDefault(require_tabRole());
    var _tableRole = _interopRequireDefault(require_tableRole());
    var _tablistRole = _interopRequireDefault(require_tablistRole());
    var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
    var _termRole = _interopRequireDefault(require_termRole());
    var _textboxRole = _interopRequireDefault(require_textboxRole());
    var _timeRole = _interopRequireDefault(require_timeRole());
    var _timerRole = _interopRequireDefault(require_timerRole());
    var _toolbarRole = _interopRequireDefault(require_toolbarRole());
    var _tooltipRole = _interopRequireDefault(require_tooltipRole());
    var _treeRole = _interopRequireDefault(require_treeRole());
    var _treegridRole = _interopRequireDefault(require_treegridRole());
    var _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    var _default = ariaLiteralRoles;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docAbstractRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docAcknowledgmentsRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docAfterwordRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docAppendixRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docBacklinkRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = docBiblioentryRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docBibliographyRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docBibliorefRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docChapterRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docColophonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docConclusionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = docCoverRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docCreditRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docCreditsRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docDedicationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = docEndnoteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docEndnotesRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docEpigraphRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docEpilogueRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docErrataRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docExampleRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docFootnoteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docForewordRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docGlossaryRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docGlossrefRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = docIndexRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docIntroductionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = docNoterefRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = docNoticeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    var _default = docPagebreakRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = docPagelistRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docPartRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docPrefaceRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = docPrologueRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    var _default = docPullquoteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = docQnaRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = docSubtitleRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = docTipRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = docTocRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
    var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
    var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
    var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
    var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
    var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
    var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
    var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
    var _docChapterRole = _interopRequireDefault(require_docChapterRole());
    var _docColophonRole = _interopRequireDefault(require_docColophonRole());
    var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
    var _docCoverRole = _interopRequireDefault(require_docCoverRole());
    var _docCreditRole = _interopRequireDefault(require_docCreditRole());
    var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
    var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
    var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
    var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
    var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
    var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
    var _docErrataRole = _interopRequireDefault(require_docErrataRole());
    var _docExampleRole = _interopRequireDefault(require_docExampleRole());
    var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
    var _docForewordRole = _interopRequireDefault(require_docForewordRole());
    var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
    var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
    var _docIndexRole = _interopRequireDefault(require_docIndexRole());
    var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
    var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
    var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
    var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
    var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
    var _docPartRole = _interopRequireDefault(require_docPartRole());
    var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
    var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
    var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
    var _docQnaRole = _interopRequireDefault(require_docQnaRole());
    var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
    var _docTipRole = _interopRequireDefault(require_docTipRole());
    var _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    var _default = ariaDpubRoles;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = graphicsDocumentRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = graphicsObjectRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = graphicsSymbolRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
    var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
    var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    var _default = ariaGraphicsRoles;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
    var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
    var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
    var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles.find(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              });
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                  var prop2 = _Object$keys[_i2];
                  if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop2)
                  ) {
                    Object.assign(roleDefinition.props, _defineProperty({}, prop2, superClassDefinition.props[prop2]));
                  }
                }
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function entries() {
        return roles;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key2 = _step3$value[0], values = _step3$value[1];
            fn.call(thisArg, values, key2, roles);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function get2(key2) {
        var item = roles.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!rolesMap.get(key2);
      },
      keys: function keys() {
        return roles.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
          return key2;
        });
      },
      values: function values() {
        return roles.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/lite/index.js
var require_lite = __commonJS({
  "../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/lite/index.js"(exports) {
    var has = Object.prototype.hasOwnProperty;
    function dequal(foo, bar) {
      var ctor, len;
      if (foo === bar)
        return true;
      if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date)
          return foo.getTime() === bar.getTime();
        if (ctor === RegExp)
          return foo.toString() === bar.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar.length) {
            while (len-- && dequal(foo[len], bar[len]))
              ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
              return false;
            if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
              return false;
          }
          return Object.keys(bar).length === len;
        }
      }
      return foo !== foo && bar !== bar;
    }
    exports.dequal = dequal;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _lite = require_lite();
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i2 >= o.length)
              return { done: true };
            return { done: false, value: o[i2++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var elementRoles2 = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key2 = keys[i];
      role = _rolesMap.default.get(key2);
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            (function() {
              var concept = relation.concept;
              if (concept) {
                var elementRoleRelation = elementRoles2.find(function(relation2) {
                  return (0, _lite.dequal)(relation2, concept);
                });
                var roles;
                if (elementRoleRelation) {
                  roles = elementRoleRelation[1];
                } else {
                  roles = [];
                }
                var isUnique = true;
                for (var _i = 0; _i < roles.length; _i++) {
                  if (roles[_i] === key2) {
                    isUnique = false;
                    break;
                  }
                }
                if (isUnique) {
                  roles.push(key2);
                }
                elementRoles2.push([concept, roles]);
              }
            })();
          }
        }
      }
    }
    var key2;
    var role;
    var concepts;
    var relation;
    var k;
    var i;
    var elementRoleMap = {
      entries: function entries() {
        return elementRoles2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(elementRoles2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, _key, elementRoles2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get2(key3) {
        var item = elementRoles2.find(function(tuple) {
          return key3.name === tuple[0].name && (0, _lite.dequal)(key3.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key3) {
        return !!elementRoleMap.get(key3);
      },
      keys: function keys2() {
        return elementRoles2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return elementRoles2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i2 >= o.length)
              return { done: true };
            return { done: false, value: o[i2++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    var roleElement = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key2 = keys[i];
      role = _rolesMap.default.get(key2);
      relationConcepts = [];
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            concept = relation.concept;
            if (concept != null) {
              relationConcepts.push(concept);
            }
          }
        }
        if (relationConcepts.length > 0) {
          roleElement.push([key2, relationConcepts]);
        }
      }
    }
    var key2;
    var role;
    var relationConcepts;
    var concepts;
    var relation;
    var concept;
    var k;
    var i;
    var roleElementMap = {
      entries: function entries() {
        return roleElement;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(roleElement), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, _key, roleElement);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get2(key3) {
        var item = roleElement.find(function(tuple) {
          return tuple[0] === key3 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key3) {
        return !!roleElementMap.get(key3);
      },
      keys: function keys2() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/aria-query@5.3.0/node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
    var _domMap = _interopRequireDefault(require_domMap());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
    var _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var aria2 = _ariaPropsMap.default;
    exports.aria = aria2;
    var dom = _domMap.default;
    exports.dom = dom;
    var roles = _rolesMap.default;
    exports.roles = roles;
    var elementRoles2 = _elementRoleMap.default;
    exports.elementRoles = elementRoles2;
    var roleElements = _roleElementMap.default;
    exports.roleElements = roleElements;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/util/iteratorProxy.js
var require_iteratorProxy2 = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/util/iterationDecorator.js
var require_iterationDecorator2 = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AbbrRole.js
var require_AbbrRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AbbrRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbbrRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "abbr"
        }
      }],
      type: "structure"
    };
    var _default = AbbrRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js
var require_AlertDialogRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertDialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alertdialog"
        }
      }],
      type: "window"
    };
    var _default = AlertDialogRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AlertRole.js
var require_AlertRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AlertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alert"
        }
      }],
      type: "structure"
    };
    var _default = AlertRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AnnotationRole.js
var require_AnnotationRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AnnotationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AnnotationRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = AnnotationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ApplicationRole.js
var require_ApplicationRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ApplicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ApplicationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "application"
        }
      }],
      type: "window"
    };
    var _default = ApplicationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ArticleRole.js
var require_ArticleRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ArticleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ArticleRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "article"
        }
      }, {
        module: "HTML",
        concept: {
          name: "article"
        }
      }],
      type: "structure"
    };
    var _default = ArticleRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AudioRole.js
var require_AudioRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/AudioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AudioRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "audio"
        }
      }],
      type: "widget"
    };
    var _default = AudioRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/BannerRole.js
var require_BannerRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/BannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BannerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "banner"
        }
      }],
      type: "structure"
    };
    var _default = BannerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js
var require_BlockquoteRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BlockquoteRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "blockquote"
        }
      }],
      type: "structure"
    };
    var _default = BlockquoteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js
var require_BusyIndicatorRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BusyIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-busy",
            value: "true"
          }]
        }
      }],
      type: "widget"
    };
    var _default = BusyIndicatorRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ButtonRole.js
var require_ButtonRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "button"
        }
      }, {
        module: "HTML",
        concept: {
          name: "button"
        }
      }],
      type: "widget"
    };
    var _default = ButtonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CanvasRole.js
var require_CanvasRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CanvasRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CanvasRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "canvas"
        }
      }],
      type: "widget"
    };
    var _default = CanvasRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CaptionRole.js
var require_CaptionRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "caption"
        }
      }],
      type: "structure"
    };
    var _default = CaptionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CellRole.js
var require_CellRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CellRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "cell"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "gridcell"
        }
      }, {
        module: "HTML",
        concept: {
          name: "td"
        }
      }],
      type: "widget"
    };
    var _default = CellRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js
var require_CheckBoxRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "checkbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = CheckBoxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ColorWellRole.js
var require_ColorWellRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ColorWellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColorWellRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "color"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ColorWellRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js
var require_ColumnHeaderRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "columnheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th"
        }
      }],
      type: "widget"
    };
    var _default = ColumnHeaderRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ColumnRole.js
var require_ColumnRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ColumnRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ColumnRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js
var require_ComboBoxRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComboBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "combobox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ComboBoxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js
var require_ComplementaryRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComplementaryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "complementary"
        }
      }],
      type: "structure"
    };
    var _default = ComplementaryRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js
var require_ContentInfoRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ContentInfoRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "structureinfo"
        }
      }],
      type: "structure"
    };
    var _default = ContentInfoRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DateRole.js
var require_DateRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DateRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "date"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DateTimeRole.js
var require_DateTimeRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DateTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "datetime"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateTimeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DefinitionRole.js
var require_DefinitionRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DefinitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DefinitionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dfn"
        }
      }],
      type: "structure"
    };
    var _default = DefinitionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js
var require_DescriptionListDetailRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListDetailRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dd"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListDetailRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js
var require_DescriptionListRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dl"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js
var require_DescriptionListTermRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListTermRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dt"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListTermRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DetailsRole.js
var require_DetailsRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DetailsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DetailsRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "details"
        }
      }],
      type: "structure"
    };
    var _default = DetailsRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DialogRole.js
var require_DialogRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "dialog"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dialog"
        }
      }],
      type: "window"
    };
    var _default = DialogRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DirectoryRole.js
var require_DirectoryRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DirectoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DirectoryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "directory"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dir"
        }
      }],
      type: "structure"
    };
    var _default = DirectoryRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js
var require_DisclosureTriangleRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DisclosureTriangleRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          constraints: ["scoped to a details element"],
          name: "summary"
        }
      }],
      type: "widget"
    };
    var _default = DisclosureTriangleRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DivRole.js
var require_DivRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DivRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DivRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "div"
        }
      }],
      type: "generic"
    };
    var _default = DivRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DocumentRole.js
var require_DocumentRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/DocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DocumentRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "document"
        }
      }],
      type: "structure"
    };
    var _default = DocumentRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js
var require_EmbeddedObjectRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var EmbeddedObjectRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "embed"
        }
      }],
      type: "widget"
    };
    var _default = EmbeddedObjectRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FeedRole.js
var require_FeedRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FeedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FeedRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "feed"
        }
      }],
      type: "structure"
    };
    var _default = FeedRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js
var require_FigcaptionRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigcaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "figcaption"
        }
      }],
      type: "structure"
    };
    var _default = FigcaptionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FigureRole.js
var require_FigureRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FigureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigureRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "figure"
        }
      }, {
        module: "HTML",
        concept: {
          name: "figure"
        }
      }],
      type: "structure"
    };
    var _default = FigureRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FooterRole.js
var require_FooterRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FooterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "footer"
        }
      }],
      type: "structure"
    };
    var _default = FooterRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FormRole.js
var require_FormRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/FormRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FormRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "form"
        }
      }, {
        module: "HTML",
        concept: {
          name: "form"
        }
      }],
      type: "structure"
    };
    var _default = FormRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/GridRole.js
var require_GridRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/GridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "grid"
        }
      }],
      type: "widget"
    };
    var _default = GridRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/GroupRole.js
var require_GroupRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/GroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "group"
        }
      }],
      type: "structure"
    };
    var _default = GroupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/HeadingRole.js
var require_HeadingRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/HeadingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var HeadingRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "heading"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h1"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h2"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h3"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h4"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h5"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h6"
        }
      }],
      type: "structure"
    };
    var _default = HeadingRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js
var require_IframePresentationalRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframePresentationalRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = IframePresentationalRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/IframeRole.js
var require_IframeRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/IframeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "iframe"
        }
      }],
      type: "window"
    };
    var _default = IframeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/IgnoredRole.js
var require_IgnoredRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/IgnoredRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IgnoredRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = IgnoredRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js
var require_ImageMapLinkRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapLinkRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = ImageMapLinkRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ImageMapRole.js
var require_ImageMapRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ImageMapRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "img",
          attributes: [{
            name: "usemap"
          }]
        }
      }],
      type: "structure"
    };
    var _default = ImageMapRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ImageRole.js
var require_ImageRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ImageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "HTML",
        concept: {
          name: "img"
        }
      }],
      type: "structure"
    };
    var _default = ImageRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js
var require_InlineTextBoxRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InlineTextBoxRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input"
        }
      }],
      type: "widget"
    };
    var _default = InlineTextBoxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/InputTimeRole.js
var require_InputTimeRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/InputTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InputTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "time"
          }]
        }
      }],
      type: "widget"
    };
    var _default = InputTimeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LabelRole.js
var require_LabelRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LabelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LabelRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "label"
        }
      }],
      type: "structure"
    };
    var _default = LabelRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LegendRole.js
var require_LegendRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LegendRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LegendRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "legend"
        }
      }],
      type: "structure"
    };
    var _default = LegendRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LineBreakRole.js
var require_LineBreakRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LineBreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LineBreakRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "br"
        }
      }],
      type: "structure"
    };
    var _default = LineBreakRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LinkRole.js
var require_LinkRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LinkRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "link"
        }
      }, {
        module: "HTML",
        concept: {
          name: "a",
          attributes: [{
            name: "href"
          }]
        }
      }],
      type: "widget"
    };
    var _default = LinkRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js
var require_ListBoxOptionRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxOptionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "option"
        }
      }, {
        module: "HTML",
        concept: {
          name: "option"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxOptionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListBoxRole.js
var require_ListBoxRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "datalist"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListItemRole.js
var require_ListItemRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "li"
        }
      }],
      type: "structure"
    };
    var _default = ListItemRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js
var require_ListMarkerRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListMarkerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ListMarkerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListRole.js
var require_ListRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "list"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ul"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ol"
        }
      }],
      type: "structure"
    };
    var _default = ListRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LogRole.js
var require_LogRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/LogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "log"
        }
      }],
      type: "structure"
    };
    var _default = LogRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MainRole.js
var require_MainRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MainRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "main"
        }
      }, {
        module: "HTML",
        concept: {
          name: "main"
        }
      }],
      type: "structure"
    };
    var _default = MainRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MarkRole.js
var require_MarkRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarkRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "mark"
        }
      }],
      type: "structure"
    };
    var _default = MarkRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MarqueeRole.js
var require_MarqueeRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MarqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarqueeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "marquee"
        }
      }, {
        module: "HTML",
        concept: {
          name: "marquee"
        }
      }],
      type: "structure"
    };
    var _default = MarqueeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MathRole.js
var require_MathRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MathRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "math"
        }
      }],
      type: "structure"
    };
    var _default = MathRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuBarRole.js
var require_MenuBarRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menubar"
        }
      }],
      type: "structure"
    };
    var _default = MenuBarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js
var require_MenuButtonRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuButtonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuItemRole.js
var require_MenuItemRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menuitem"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js
var require_MenuItemCheckBoxRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemCheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemcheckbox"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemCheckBoxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js
var require_MenuItemRadioRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRadioRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemradio"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRadioRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js
var require_MenuListOptionRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListOptionRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListOptionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js
var require_MenuListPopupRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListPopupRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListPopupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuRole.js
var require_MenuRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MenuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menu"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menu"
        }
      }],
      type: "structure"
    };
    var _default = MenuRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MeterRole.js
var require_MeterRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/MeterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MeterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "meter"
        }
      }],
      type: "structure"
    };
    var _default = MeterRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/NavigationRole.js
var require_NavigationRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/NavigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NavigationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "navigation"
        }
      }, {
        module: "HTML",
        concept: {
          name: "nav"
        }
      }],
      type: "structure"
    };
    var _default = NavigationRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/NoneRole.js
var require_NoneRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/NoneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoneRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "none"
        }
      }],
      type: "structure"
    };
    var _default = NoneRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/NoteRole.js
var require_NoteRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/NoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoteRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "note"
        }
      }],
      type: "structure"
    };
    var _default = NoteRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/OutlineRole.js
var require_OutlineRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/OutlineRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var OutlineRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = OutlineRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ParagraphRole.js
var require_ParagraphRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ParagraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ParagraphRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "p"
        }
      }],
      type: "structure"
    };
    var _default = ParagraphRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js
var require_PopUpButtonRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PopUpButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = PopUpButtonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/PreRole.js
var require_PreRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/PreRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PreRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "pre"
        }
      }],
      type: "structure"
    };
    var _default = PreRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/PresentationalRole.js
var require_PresentationalRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/PresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PresentationalRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "presentation"
        }
      }],
      type: "structure"
    };
    var _default = PresentationalRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js
var require_ProgressIndicatorRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ProgressIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "progressbar"
        }
      }, {
        module: "HTML",
        concept: {
          name: "progress"
        }
      }],
      type: "structure"
    };
    var _default = ProgressIndicatorRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js
var require_RadioButtonRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radio"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "radio"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RadioButtonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js
var require_RadioGroupRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radiogroup"
        }
      }],
      type: "structure"
    };
    var _default = RadioGroupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RegionRole.js
var require_RegionRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RegionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RegionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "region"
        }
      }],
      type: "structure"
    };
    var _default = RegionRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js
var require_RootWebAreaRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RootWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RootWebAreaRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js
var require_RowHeaderRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "rowheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th",
          attributes: [{
            name: "scope",
            value: "row"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RowHeaderRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RowRole.js
var require_RowRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "row"
        }
      }, {
        module: "HTML",
        concept: {
          name: "tr"
        }
      }],
      type: "structure"
    };
    var _default = RowRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RubyRole.js
var require_RubyRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RubyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RubyRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "ruby"
        }
      }],
      type: "structure"
    };
    var _default = RubyRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RulerRole.js
var require_RulerRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/RulerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RulerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RulerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js
var require_ScrollAreaRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ScrollAreaRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js
var require_ScrollBarRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "scrollbar"
        }
      }],
      type: "widget"
    };
    var _default = ScrollBarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js
var require_SeamlessWebAreaRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SeamlessWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SeamlessWebAreaRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SearchRole.js
var require_SearchRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SearchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "search"
        }
      }],
      type: "structure"
    };
    var _default = SearchRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js
var require_SearchBoxRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "searchbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "search"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SearchBoxRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SliderRole.js
var require_SliderRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "slider"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "range"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SliderRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js
var require_SliderThumbRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderThumbRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SliderThumbRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js
var require_SpinButtonRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "spinbutton"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "number"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SpinButtonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js
var require_SpinButtonPartRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonPartRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SpinButtonPartRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SplitterRole.js
var require_SplitterRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SplitterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SplitterRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "separator"
        }
      }],
      type: "widget"
    };
    var _default = SplitterRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/StaticTextRole.js
var require_StaticTextRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/StaticTextRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StaticTextRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = StaticTextRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/StatusRole.js
var require_StatusRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/StatusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StatusRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "status"
        }
      }],
      type: "structure"
    };
    var _default = StatusRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SVGRootRole.js
var require_SVGRootRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SVGRootRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SVGRootRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SVGRootRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SwitchRole.js
var require_SwitchRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/SwitchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SwitchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "switch"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SwitchRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabGroupRole.js
var require_TabGroupRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabGroupRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabRole.js
var require_TabRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tab"
        }
      }],
      type: "widget"
    };
    var _default = TabRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js
var require_TableHeaderContainerRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableHeaderContainerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = TableHeaderContainerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TableRole.js
var require_TableRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "table"
        }
      }, {
        module: "HTML",
        concept: {
          name: "table"
        }
      }],
      type: "structure"
    };
    var _default = TableRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabListRole.js
var require_TabListRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabListRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabPanelRole.js
var require_TabPanelRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TabPanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabPanelRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tabpanel"
        }
      }],
      type: "structure"
    };
    var _default = TabPanelRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TermRole.js
var require_TermRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TermRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "term"
        }
      }],
      type: "structure"
    };
    var _default = TermRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TextAreaRole.js
var require_TextAreaRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TextAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextAreaRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-multiline",
            value: "true"
          }],
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "textarea"
        }
      }],
      type: "widget"
    };
    var _default = TextAreaRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TextFieldRole.js
var require_TextFieldRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TextFieldRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextFieldRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "text"
          }]
        }
      }],
      type: "widget"
    };
    var _default = TextFieldRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TimeRole.js
var require_TimeRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "time"
        }
      }],
      type: "structure"
    };
    var _default = TimeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TimerRole.js
var require_TimerRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TimerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "timer"
        }
      }],
      type: "structure"
    };
    var _default = TimerRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js
var require_ToggleButtonRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToggleButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-pressed"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ToggleButtonRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ToolbarRole.js
var require_ToolbarRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/ToolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToolbarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "toolbar"
        }
      }],
      type: "structure"
    };
    var _default = ToolbarRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TreeRole.js
var require_TreeRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TreeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tree"
        }
      }],
      type: "widget"
    };
    var _default = TreeRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TreeGridRole.js
var require_TreeGridRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TreeGridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeGridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treegrid"
        }
      }],
      type: "widget"
    };
    var _default = TreeGridRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TreeItemRole.js
var require_TreeItemRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/TreeItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treeitem"
        }
      }],
      type: "widget"
    };
    var _default = TreeItemRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js
var require_UserInterfaceTooltipRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UserInterfaceTooltipRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tooltip"
        }
      }],
      type: "structure"
    };
    var _default = UserInterfaceTooltipRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/VideoRole.js
var require_VideoRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/VideoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var VideoRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "video"
        }
      }],
      type: "widget"
    };
    var _default = VideoRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/WebAreaRole.js
var require_WebAreaRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/WebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = WebAreaRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/WindowRole.js
var require_WindowRole = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/etc/objects/WindowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WindowRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = WindowRole;
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/AXObjectsMap.js
var require_AXObjectsMap = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/AXObjectsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AbbrRole = _interopRequireDefault(require_AbbrRole());
    var _AlertDialogRole = _interopRequireDefault(require_AlertDialogRole());
    var _AlertRole = _interopRequireDefault(require_AlertRole());
    var _AnnotationRole = _interopRequireDefault(require_AnnotationRole());
    var _ApplicationRole = _interopRequireDefault(require_ApplicationRole());
    var _ArticleRole = _interopRequireDefault(require_ArticleRole());
    var _AudioRole = _interopRequireDefault(require_AudioRole());
    var _BannerRole = _interopRequireDefault(require_BannerRole());
    var _BlockquoteRole = _interopRequireDefault(require_BlockquoteRole());
    var _BusyIndicatorRole = _interopRequireDefault(require_BusyIndicatorRole());
    var _ButtonRole = _interopRequireDefault(require_ButtonRole());
    var _CanvasRole = _interopRequireDefault(require_CanvasRole());
    var _CaptionRole = _interopRequireDefault(require_CaptionRole());
    var _CellRole = _interopRequireDefault(require_CellRole());
    var _CheckBoxRole = _interopRequireDefault(require_CheckBoxRole());
    var _ColorWellRole = _interopRequireDefault(require_ColorWellRole());
    var _ColumnHeaderRole = _interopRequireDefault(require_ColumnHeaderRole());
    var _ColumnRole = _interopRequireDefault(require_ColumnRole());
    var _ComboBoxRole = _interopRequireDefault(require_ComboBoxRole());
    var _ComplementaryRole = _interopRequireDefault(require_ComplementaryRole());
    var _ContentInfoRole = _interopRequireDefault(require_ContentInfoRole());
    var _DateRole = _interopRequireDefault(require_DateRole());
    var _DateTimeRole = _interopRequireDefault(require_DateTimeRole());
    var _DefinitionRole = _interopRequireDefault(require_DefinitionRole());
    var _DescriptionListDetailRole = _interopRequireDefault(require_DescriptionListDetailRole());
    var _DescriptionListRole = _interopRequireDefault(require_DescriptionListRole());
    var _DescriptionListTermRole = _interopRequireDefault(require_DescriptionListTermRole());
    var _DetailsRole = _interopRequireDefault(require_DetailsRole());
    var _DialogRole = _interopRequireDefault(require_DialogRole());
    var _DirectoryRole = _interopRequireDefault(require_DirectoryRole());
    var _DisclosureTriangleRole = _interopRequireDefault(require_DisclosureTriangleRole());
    var _DivRole = _interopRequireDefault(require_DivRole());
    var _DocumentRole = _interopRequireDefault(require_DocumentRole());
    var _EmbeddedObjectRole = _interopRequireDefault(require_EmbeddedObjectRole());
    var _FeedRole = _interopRequireDefault(require_FeedRole());
    var _FigcaptionRole = _interopRequireDefault(require_FigcaptionRole());
    var _FigureRole = _interopRequireDefault(require_FigureRole());
    var _FooterRole = _interopRequireDefault(require_FooterRole());
    var _FormRole = _interopRequireDefault(require_FormRole());
    var _GridRole = _interopRequireDefault(require_GridRole());
    var _GroupRole = _interopRequireDefault(require_GroupRole());
    var _HeadingRole = _interopRequireDefault(require_HeadingRole());
    var _IframePresentationalRole = _interopRequireDefault(require_IframePresentationalRole());
    var _IframeRole = _interopRequireDefault(require_IframeRole());
    var _IgnoredRole = _interopRequireDefault(require_IgnoredRole());
    var _ImageMapLinkRole = _interopRequireDefault(require_ImageMapLinkRole());
    var _ImageMapRole = _interopRequireDefault(require_ImageMapRole());
    var _ImageRole = _interopRequireDefault(require_ImageRole());
    var _InlineTextBoxRole = _interopRequireDefault(require_InlineTextBoxRole());
    var _InputTimeRole = _interopRequireDefault(require_InputTimeRole());
    var _LabelRole = _interopRequireDefault(require_LabelRole());
    var _LegendRole = _interopRequireDefault(require_LegendRole());
    var _LineBreakRole = _interopRequireDefault(require_LineBreakRole());
    var _LinkRole = _interopRequireDefault(require_LinkRole());
    var _ListBoxOptionRole = _interopRequireDefault(require_ListBoxOptionRole());
    var _ListBoxRole = _interopRequireDefault(require_ListBoxRole());
    var _ListItemRole = _interopRequireDefault(require_ListItemRole());
    var _ListMarkerRole = _interopRequireDefault(require_ListMarkerRole());
    var _ListRole = _interopRequireDefault(require_ListRole());
    var _LogRole = _interopRequireDefault(require_LogRole());
    var _MainRole = _interopRequireDefault(require_MainRole());
    var _MarkRole = _interopRequireDefault(require_MarkRole());
    var _MarqueeRole = _interopRequireDefault(require_MarqueeRole());
    var _MathRole = _interopRequireDefault(require_MathRole());
    var _MenuBarRole = _interopRequireDefault(require_MenuBarRole());
    var _MenuButtonRole = _interopRequireDefault(require_MenuButtonRole());
    var _MenuItemRole = _interopRequireDefault(require_MenuItemRole());
    var _MenuItemCheckBoxRole = _interopRequireDefault(require_MenuItemCheckBoxRole());
    var _MenuItemRadioRole = _interopRequireDefault(require_MenuItemRadioRole());
    var _MenuListOptionRole = _interopRequireDefault(require_MenuListOptionRole());
    var _MenuListPopupRole = _interopRequireDefault(require_MenuListPopupRole());
    var _MenuRole = _interopRequireDefault(require_MenuRole());
    var _MeterRole = _interopRequireDefault(require_MeterRole());
    var _NavigationRole = _interopRequireDefault(require_NavigationRole());
    var _NoneRole = _interopRequireDefault(require_NoneRole());
    var _NoteRole = _interopRequireDefault(require_NoteRole());
    var _OutlineRole = _interopRequireDefault(require_OutlineRole());
    var _ParagraphRole = _interopRequireDefault(require_ParagraphRole());
    var _PopUpButtonRole = _interopRequireDefault(require_PopUpButtonRole());
    var _PreRole = _interopRequireDefault(require_PreRole());
    var _PresentationalRole = _interopRequireDefault(require_PresentationalRole());
    var _ProgressIndicatorRole = _interopRequireDefault(require_ProgressIndicatorRole());
    var _RadioButtonRole = _interopRequireDefault(require_RadioButtonRole());
    var _RadioGroupRole = _interopRequireDefault(require_RadioGroupRole());
    var _RegionRole = _interopRequireDefault(require_RegionRole());
    var _RootWebAreaRole = _interopRequireDefault(require_RootWebAreaRole());
    var _RowHeaderRole = _interopRequireDefault(require_RowHeaderRole());
    var _RowRole = _interopRequireDefault(require_RowRole());
    var _RubyRole = _interopRequireDefault(require_RubyRole());
    var _RulerRole = _interopRequireDefault(require_RulerRole());
    var _ScrollAreaRole = _interopRequireDefault(require_ScrollAreaRole());
    var _ScrollBarRole = _interopRequireDefault(require_ScrollBarRole());
    var _SeamlessWebAreaRole = _interopRequireDefault(require_SeamlessWebAreaRole());
    var _SearchRole = _interopRequireDefault(require_SearchRole());
    var _SearchBoxRole = _interopRequireDefault(require_SearchBoxRole());
    var _SliderRole = _interopRequireDefault(require_SliderRole());
    var _SliderThumbRole = _interopRequireDefault(require_SliderThumbRole());
    var _SpinButtonRole = _interopRequireDefault(require_SpinButtonRole());
    var _SpinButtonPartRole = _interopRequireDefault(require_SpinButtonPartRole());
    var _SplitterRole = _interopRequireDefault(require_SplitterRole());
    var _StaticTextRole = _interopRequireDefault(require_StaticTextRole());
    var _StatusRole = _interopRequireDefault(require_StatusRole());
    var _SVGRootRole = _interopRequireDefault(require_SVGRootRole());
    var _SwitchRole = _interopRequireDefault(require_SwitchRole());
    var _TabGroupRole = _interopRequireDefault(require_TabGroupRole());
    var _TabRole = _interopRequireDefault(require_TabRole());
    var _TableHeaderContainerRole = _interopRequireDefault(require_TableHeaderContainerRole());
    var _TableRole = _interopRequireDefault(require_TableRole());
    var _TabListRole = _interopRequireDefault(require_TabListRole());
    var _TabPanelRole = _interopRequireDefault(require_TabPanelRole());
    var _TermRole = _interopRequireDefault(require_TermRole());
    var _TextAreaRole = _interopRequireDefault(require_TextAreaRole());
    var _TextFieldRole = _interopRequireDefault(require_TextFieldRole());
    var _TimeRole = _interopRequireDefault(require_TimeRole());
    var _TimerRole = _interopRequireDefault(require_TimerRole());
    var _ToggleButtonRole = _interopRequireDefault(require_ToggleButtonRole());
    var _ToolbarRole = _interopRequireDefault(require_ToolbarRole());
    var _TreeRole = _interopRequireDefault(require_TreeRole());
    var _TreeGridRole = _interopRequireDefault(require_TreeGridRole());
    var _TreeItemRole = _interopRequireDefault(require_TreeItemRole());
    var _UserInterfaceTooltipRole = _interopRequireDefault(require_UserInterfaceTooltipRole());
    var _VideoRole = _interopRequireDefault(require_VideoRole());
    var _WebAreaRole = _interopRequireDefault(require_WebAreaRole());
    var _WindowRole = _interopRequireDefault(require_WindowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjects2 = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextAreaRole", _TextAreaRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
    var AXObjectsMap = {
      entries: function entries() {
        return AXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(AXObjects2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key2 = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key2, AXObjects2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get2(key2) {
        var item = AXObjects2.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectsMap.get(key2);
      },
      keys: function keys() {
        return AXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/AXObjectElementMap.js
var require_AXObjectElementMap = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/AXObjectElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name;
                });
                if (index === -1) {
                  AXObjectElements.push([name, []]);
                  index = AXObjectElements.length - 1;
                }
                AXObjectElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectElementMap = {
      entries: function entries() {
        return AXObjectElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(AXObjectElements), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key2 = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key2, AXObjectElements);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get2(key2) {
        var item = AXObjectElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectElementMap.get(key2);
      },
      keys: function keys() {
        return AXObjectElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/AXObjectRoleMap.js
var require_AXObjectRoleMap = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/AXObjectRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "ARIA") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectRoleElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name;
                });
                if (index === -1) {
                  AXObjectRoleElements.push([name, []]);
                  index = AXObjectRoleElements.length - 1;
                }
                AXObjectRoleElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectRoleMap = {
      entries: function entries() {
        return AXObjectRoleElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(AXObjectRoleElements), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key2 = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key2, AXObjectRoleElements);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get2(key2) {
        var item = AXObjectRoleElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectRoleMap.get(key2);
      },
      keys: function keys() {
        return AXObjectRoleElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectRoleElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/elementAXObjectMap.js
var require_elementAXObjectMap = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/elementAXObjectMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _lite = require_lite();
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n2() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var elementAXObjects2 = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept != null) {
                var conceptStr = JSON.stringify(concept);
                var axObjects;
                var index = 0;
                for (; index < elementAXObjects2.length; index++) {
                  var key2 = elementAXObjects2[index][0];
                  if (JSON.stringify(key2) === conceptStr) {
                    axObjects = elementAXObjects2[index][1];
                    break;
                  }
                }
                if (!Array.isArray(axObjects)) {
                  axObjects = [];
                }
                var loc = axObjects.findIndex(function(item) {
                  return item === name;
                });
                if (loc === -1) {
                  axObjects.push(name);
                }
                if (index < elementAXObjects2.length) {
                  elementAXObjects2.splice(index, 1, [concept, axObjects]);
                } else {
                  elementAXObjects2.push([concept, axObjects]);
                }
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var elementAXObjectMap = {
      entries: function entries() {
        return elementAXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(elementAXObjects2), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key2 = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key2, elementAXObjects2);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get2(key2) {
        var item = elementAXObjects2.find(function(tuple) {
          return key2.name === tuple[0].name && (0, _lite.dequal)(key2.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!elementAXObjectMap.get(key2);
      },
      keys: function keys() {
        return elementAXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return elementAXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    exports.default = _default;
  }
});

// ../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/axobject-query@4.0.0/node_modules/axobject-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(require_AXObjectElementMap());
    var _AXObjectRoleMap = _interopRequireDefault(require_AXObjectRoleMap());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _elementAXObjectMap = _interopRequireDefault(require_elementAXObjectMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    exports.AXObjectElements = AXObjectElements;
    var AXObjectRoles2 = _AXObjectRoleMap.default;
    exports.AXObjectRoles = AXObjectRoles2;
    var AXObjects2 = _AXObjectsMap.default;
    exports.AXObjects = AXObjects2;
    var elementAXObjects2 = _elementAXObjectMap.default;
    exports.elementAXObjects = elementAXObjects2;
  }
});

// ../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.resolveURI = factory());
    })(exports, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash: hash2,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            case UrlType.Hash:
              url.query = baseUrl.query;
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.19/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));
    })(exports, function(exports2, sourcemapCodec, resolveUri) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri);
      function resolve(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri__default["default"](input, base);
      }
      function stripFilename(path) {
        if (!path)
          return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key2) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key2 === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key2;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex];
            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array2, index, value) {
        for (let i = array2.length; i > index; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index] = value;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = typeof map === "string" ? JSON.parse(map) : map;
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings
        };
        return exports2.presortedDecodedMap(joined);
      };
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset: offset2 } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset2.line, columnOffset + offset2.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
        if ("sections" in input)
          return recurse(...arguments);
        const map = new TraceMap(input, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = exports2.decodedMappings(map);
        const { resolvedSources, sourcesContent: contents } = map;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents)
          append(sourcesContent, contents);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (let i = arr.length; i <= index; i++)
          arr[i] = [];
        return arr[index];
      }
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      exports2.encodedMappings = void 0;
      exports2.decodedMappings = void 0;
      exports2.traceSegment = void 0;
      exports2.originalPositionFor = void 0;
      exports2.generatedPositionFor = void 0;
      exports2.allGeneratedPositionsFor = void 0;
      exports2.eachMapping = void 0;
      exports2.sourceContentFor = void 0;
      exports2.presortedDecodedMap = void 0;
      exports2.decodedMap = void 0;
      exports2.encodedMap = void 0;
      class TraceMap {
        constructor(map, mapUrl) {
          const isString = typeof map === "string";
          if (!isString && map._decodedMemo)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version2;
          this.file = file;
          this.names = names;
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          const from = resolve(sourceRoot || "", stripFilename(mapUrl));
          this.resolvedSources = sources.map((s) => resolve(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      (() => {
        exports2.encodedMappings = (map) => {
          var _a;
          return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);
        };
        exports2.decodedMappings = (map) => {
          return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
        };
        exports2.traceSegment = (map, line, column) => {
          const decoded = exports2.decodedMappings(map);
          if (line >= decoded.length)
            return null;
          const segments = decoded[line];
          const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
          return index === -1 ? null : segments[index];
        };
        exports2.originalPositionFor = (map, { line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const decoded = exports2.decodedMappings(map);
          if (line >= decoded.length)
            return OMapping(null, null, null, null);
          const segments = decoded[line];
          const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
          if (index === -1)
            return OMapping(null, null, null, null);
          const segment = segments[index];
          if (segment.length === 1)
            return OMapping(null, null, null, null);
          const { names, resolvedSources } = map;
          return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
        };
        exports2.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {
          return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
        };
        exports2.generatedPositionFor = (map, { source, line, column, bias }) => {
          return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
        };
        exports2.eachMapping = (map, cb) => {
          const decoded = exports2.decodedMappings(map);
          const { names, resolvedSources } = map;
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generatedLine = i + 1;
              const generatedColumn = seg[0];
              let source = null;
              let originalLine = null;
              let originalColumn = null;
              let name = null;
              if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
              }
              if (seg.length === 5)
                name = names[seg[4]];
              cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
              });
            }
          }
        };
        exports2.sourceContentFor = (map, source) => {
          const { sources, resolvedSources, sourcesContent } = map;
          if (sourcesContent == null)
            return null;
          let index = sources.indexOf(source);
          if (index === -1)
            index = resolvedSources.indexOf(source);
          return index === -1 ? null : sourcesContent[index];
        };
        exports2.presortedDecodedMap = (map, mapUrl) => {
          const tracer = new TraceMap(clone(map, []), mapUrl);
          tracer._decoded = map.mappings;
          return tracer;
        };
        exports2.decodedMap = (map) => {
          return clone(map, exports2.decodedMappings(map));
        };
        exports2.encodedMap = (map) => {
          return clone(map, exports2.encodedMappings(map));
        };
        function generatedPosition(map, source, line, column, bias, all) {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const { sources, resolvedSources } = map;
          let sourceIndex = sources.indexOf(source);
          if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
          if (sourceIndex === -1)
            return all ? [] : GMapping(null, null);
          const generated = map._bySources || (map._bySources = buildBySources(exports2.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
          const segments = generated[sourceIndex][line];
          if (segments == null)
            return all ? [] : GMapping(null, null);
          const memo = map._bySourceMemos[sourceIndex];
          if (all)
            return sliceGeneratedPositions(segments, memo, line, column, bias);
          const index = traceSegmentInternal(segments, memo, line, column, bias);
          if (index === -1)
            return GMapping(null, null);
          const segment = segments[index];
          return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
        }
      })();
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings
        };
      }
      function OMapping(source, line, column, name) {
        return { source, line, column, name };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        if (!found && bias === LEAST_UPPER_BOUND)
          min++;
        if (min === -1 || min === segments.length)
          return [];
        const matchedColumn = found ? column : segments[min][COLUMN];
        if (!found)
          min = lowerBound(segments, matchedColumn, min);
        const max = upperBound(segments, matchedColumn, min);
        const result = [];
        for (; min <= max; min++) {
          const segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      exports2.AnyMap = AnyMap;
      exports2.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports2.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports2.TraceMap = TraceMap;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+set-array@1.1.2/node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.setArray = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.get = void 0;
      exports2.put = void 0;
      exports2.pop = void 0;
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      (() => {
        exports2.get = (strarr, key2) => strarr._indexes[key2];
        exports2.put = (strarr, key2) => {
          const index = exports2.get(strarr, key2);
          if (index !== void 0)
            return index;
          const { array: array2, _indexes: indexes } = strarr;
          return indexes[key2] = array2.push(key2) - 1;
        };
        exports2.pop = (strarr) => {
          const { array: array2, _indexes: indexes } = strarr;
          if (array2.length === 0)
            return;
          const last = array2.pop();
          indexes[last] = void 0;
        };
      })();
      exports2.SetArray = SetArray;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "../../node_modules/.pnpm/@jridgewell+gen-mapping@0.3.3/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
    })(exports, function(exports2, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const NO_NAME = -1;
      exports2.addSegment = void 0;
      exports2.addMapping = void 0;
      exports2.maybeAddSegment = void 0;
      exports2.maybeAddMapping = void 0;
      exports2.setSourceContent = void 0;
      exports2.toDecodedMap = void 0;
      exports2.toEncodedMap = void 0;
      exports2.fromMap = void 0;
      exports2.allMappings = void 0;
      let addSegmentInternal;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
        }
      }
      (() => {
        exports2.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
          return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
        };
        exports2.maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
          return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
        };
        exports2.addMapping = (map, mapping) => {
          return addMappingInternal(false, map, mapping);
        };
        exports2.maybeAddMapping = (map, mapping) => {
          return addMappingInternal(true, map, mapping);
        };
        exports2.setSourceContent = (map, source, content) => {
          const { _sources: sources, _sourcesContent: sourcesContent } = map;
          sourcesContent[setArray.put(sources, source)] = content;
        };
        exports2.toDecodedMap = (map) => {
          const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
          removeEmptyFinalLines(mappings);
          return {
            version: 3,
            file: file || void 0,
            names: names.array,
            sourceRoot: sourceRoot || void 0,
            sources: sources.array,
            sourcesContent,
            mappings
          };
        };
        exports2.toEncodedMap = (map) => {
          const decoded = exports2.toDecodedMap(map);
          return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
        };
        exports2.allMappings = (map) => {
          const out = [];
          const { _mappings: mappings, _sources: sources, _names: names } = map;
          for (let i = 0; i < mappings.length; i++) {
            const line = mappings[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generated = { line: i + 1, column: seg[COLUMN] };
              let source = void 0;
              let original = void 0;
              let name = void 0;
              if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                if (seg.length === 5)
                  name = names.array[seg[NAMES_INDEX]];
              }
              out.push({ generated, source, original, name });
            }
          }
          return out;
        };
        exports2.fromMap = (input) => {
          const map = new traceMapping.TraceMap(input);
          const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
          putAll(gen._names, map.names);
          putAll(gen._sources, map.sources);
          gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);
          gen._mappings = traceMapping.decodedMappings(map);
          return gen;
        };
        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
          const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
          const line = getLine(mappings, genLine);
          const index = getColumnIndex(line, genColumn);
          if (!source) {
            if (skipable && skipSourceless(line, index))
              return;
            return insert(line, index, [genColumn]);
          }
          const sourcesIndex = setArray.put(sources, source);
          const namesIndex = name ? setArray.put(names, name) : NO_NAME;
          if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
          if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
          }
          return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
        };
      })();
      function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
          const current2 = line[i];
          if (genColumn >= current2[COLUMN])
            break;
        }
        return index;
      }
      function insert(array2, index, value) {
        for (let i = array2.length; i > index; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(strarr, array2) {
        for (let i = 0; i < array2.length; i++)
          setArray.put(strarr, array2[i]);
      }
      function skipSourceless(line, index) {
        if (index === 0)
          return true;
        const prev = line[index - 1];
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index === 0)
          return false;
        const prev = line[index - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        const s = source;
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);
      }
      exports2.GenMapping = GenMapping;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS({
  "../../node_modules/.pnpm/@ampproject+remapping@2.2.1/node_modules/@ampproject/remapping/dist/remapping.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_trace_mapping_umd(), require_gen_mapping_umd()) : typeof define === "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));
    })(exports, function(traceMapping, genMapping) {
      "use strict";
      const SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null);
      const EMPTY_SOURCES = [];
      function SegmentObject(source, line, column, name, content) {
        return { source, line, column, name, content };
      }
      function Source(map, sources, source, content) {
        return {
          map,
          sources,
          source,
          content
        };
      }
      function MapSource(map, sources) {
        return Source(map, sources, "", null);
      }
      function OriginalSource(source, content) {
        return Source(null, EMPTY_SOURCES, source, content);
      }
      function traceMappings(tree) {
        const gen = new genMapping.GenMapping({ file: tree.map.file });
        const { sources: rootSources, map } = tree;
        const rootNames = map.names;
        const rootMappings = traceMapping.decodedMappings(map);
        for (let i = 0; i < rootMappings.length; i++) {
          const segments = rootMappings[i];
          for (let j = 0; j < segments.length; j++) {
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              const source2 = rootSources[segment[1]];
              traced = originalPositionFor(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (traced == null)
                continue;
            }
            const { column, line, name, content, source } = traced;
            genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name);
            if (source && content != null)
              genMapping.setSourceContent(gen, source, content);
          }
        }
        return gen;
      }
      function originalPositionFor(source, line, column, name) {
        if (!source.map) {
          return SegmentObject(source.source, line, column, name, source.content);
        }
        const segment = traceMapping.traceSegment(source.map, line, column);
        if (segment == null)
          return null;
        if (segment.length === 1)
          return SOURCELESS_MAPPING;
        return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
      }
      function asArray(value) {
        if (Array.isArray(value))
          return value;
        return [value];
      }
      function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ""));
        const map = maps.pop();
        for (let i = 0; i < maps.length; i++) {
          if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
          }
        }
        let tree = build(map, loader, "", 0);
        for (let i = maps.length - 1; i >= 0; i--) {
          tree = MapSource(maps[i], [tree]);
        }
        return tree;
      }
      function build(map, loader, importer, importerDepth) {
        const { resolvedSources, sourcesContent } = map;
        const depth = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i) => {
          const ctx = {
            importer,
            depth,
            source: sourceFile || "",
            content: void 0
          };
          const sourceMap = loader(ctx.source, ctx);
          const { source, content } = ctx;
          if (sourceMap)
            return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);
          const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
          return OriginalSource(source, sourceContent);
        });
        return MapSource(map, children);
      }
      class SourceMap2 {
        constructor(map, options) {
          const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
          this.version = out.version;
          this.file = out.file;
          this.mappings = out.mappings;
          this.names = out.names;
          this.sourceRoot = out.sourceRoot;
          this.sources = out.sources;
          if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
          }
        }
        toString() {
          return JSON.stringify(this);
        }
      }
      function remapping2(input, loader, options) {
        const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap2(traceMappings(tree), opts);
      }
      return remapping2;
    });
  }
});

// ../../node_modules/.pnpm/acorn@8.10.0/node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === void 0)
    options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next2 = code.charCodeAt(i);
    if (isNewLine(next2)) {
      return i < end - 1 && next2 === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array2) {
  return function(block2, text2, start, end, startLoc, endLoc) {
    var comment = {
      type: block2 ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved2 = "";
  if (options.allowReserved !== true) {
    reserved2 = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved2 += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved2);
  var reservedStrict = (reserved2 ? reserved2 + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt2 = this.parseStatement(null, true, exports);
    node.body.push(stmt2);
  }
  if (this.inModule) {
    for (var i = 0, list2 = Object.keys(this.undefinedExports); i < list2.length; i += 1) {
      var name = list2[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init2);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node === void 0)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init2) {
  node.init = init2;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init2;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next2 = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next2 = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key2 = node.key;
  return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list2 = node.specifiers; i < list2.length; i += 1) {
        var spec = list2[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration2 = this.parseMaybeAssign();
    this.semicolon();
    return declaration2;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list2 = pat.properties; i < list2.length; i += 1) {
      var prop2 = list2[i];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list2 = decls; i < list2.length; i += 1) {
    var decl = list2[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list2 = node.properties; i < list2.length; i += 1) {
          var prop2 = list2[i];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest2 = this.parseRestBinding();
      this.parseBindingListItem(rest2);
      elts.push(rest2);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list2 = expr.properties; i < list2.length; i += 1) {
        var prop2 = list2[i];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update2, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update2 = type.updateContext) {
    update2.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key2 = prop2.key;
  var name;
  switch (key2.type) {
    case "Identifier":
      name = key2.name;
      break;
    case "Literal":
      name = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical2 = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical2 || coalesce);
      if (logical2 && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical2) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical2 ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update2 = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update2, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update2) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    node.meta = meta;
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node.properties.push(prop2);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parseGetterSetter = function(prop2) {
  prop2.kind = prop2.key.name;
  this.parsePropertyName(prop2);
  prop2.value = this.parseMethod(false);
  var paramCount = prop2.kind === "get" ? 0 : 1;
  if (prop2.value.params.length !== paramCount) {
    var start = prop2.value.start;
    if (prop2.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.kind = "init";
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop2);
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop2.kind = "init";
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list2 = params; i < list2.length; i += 1) {
    var param = list2[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list2 = node.params; i < list2.length; i += 1) {
    var param = list2[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop2 in node) {
    newNode[prop2] = node[prop2];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list2 = [9, 10, 11, 12, 13, 14]; i < list2.length; i += 1) {
  ecmaVersion = list2[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list2;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l) {
    return c2;
  }
  var next2 = s.charCodeAt(i + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c2 << 10) + next2 - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c2 = s.charCodeAt(i), next2;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l || (next2 = s.charCodeAt(i + 1)) < 56320 || next2 > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0)
    forceU = false;
  var pos = this.pos;
  for (var i = 0, list2 = chs; i < list2.length; i += 1) {
    var ch = list2[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list2 = state.backReferenceNames; i < list2.length; i += 1) {
    var name = list2[i];
    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code : (code << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.10.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}

// src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_newline = /^\r?\n/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]*/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]*$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_whitespaces_strict = /[ \t\n\r\f]+/g;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_starts_with_vowel = /^[aeiou]/;
var regex_heading_tags = /^h[1-6]$/;

// src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
function extract_svelte_ignore(text2) {
  const match = regex_svelte_ignore.exec(text2);
  return match ? match[1].split(regex_whitespace).map(
    /** @param {any} x */
    (x) => x.trim()
  ).filter(Boolean) : [];
}
function extract_svelte_ignore_from_comments(node) {
  return (node.leadingComments || []).flatMap(
    /** @param {any} comment */
    (comment) => extract_svelte_ignore(comment.value)
  );
}
function extract_ignores_above_position(node, template_nodes) {
  const previous_node_idx = template_nodes.indexOf(node) - 1;
  if (previous_node_idx < 0) {
    return [];
  }
  const ignores = [];
  for (let i = previous_node_idx; i >= 0; i--) {
    const node2 = template_nodes[i];
    if (node2.type !== "Comment" && node2.type !== "Text") {
      return ignores;
    }
    if (node2.type === "Comment") {
      if (node2.ignores.length) {
        ignores.push(...node2.ignores);
      }
    }
  }
  return ignores;
}

// src/compiler/phases/1-parse/utils/fuzzymatch.js
function fuzzymatch(name, names) {
  if (names.length === 0)
    return null;
  const set2 = new FuzzySet(names);
  const matches = set2.get(name);
  return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null)
    return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  if (str1.length > str2.length) {
    return 1 - distance / str1.length;
  } else {
    return 1 - distance / str2.length;
  }
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev = 0;
  let value = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current2[j];
      current2[j] = value;
    }
  }
  return (
    /** @type {number} */
    current2.pop()
  );
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  /** @type {Record<string, string>} */
  exact_set = {};
  /** @type {Record<string, [number, number][]>} */
  match_dict = {};
  /** @type {Record<string, number[]>} */
  items = {};
  /** @param {string[]} arr */
  constructor(arr) {
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /** @param {string} value */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /** @param {string} value */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return (
        /** @type {MatchTuple[]} */
        [[1, result]]
      );
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value, gram_size);
      if (results.length > 0)
        return results;
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   * @returns {MatchTuple[]}
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// src/compiler/phases/1-parse/utils/names.js
var reserved = [
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
];
var void_element_names = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return void_element_names.includes(name) || name.toLowerCase() === "!doctype";
}

// src/compiler/phases/1-parse/acorn.js
var parse4 = (source) => (
  /** @type {any} */
  /** @type {import('estree').Program} */
  parse3(source, {
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  })
);
var parse_expression_at = (source, index) => (
  /** @type {import('estree').Expression} */
  parseExpressionAt2(source, index, {
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  })
);

// src/compiler/errors.js
function list(items, conjunction = "or") {
  if (items.length === 1)
    return items[0];
  return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
}
var internal = {
  /** @param {string} message */
  TODO: (message) => `TODO ${message}`,
  /** @param {string} message */
  INTERNAL: (message) => `Internal compiler error: ${message}. Please report this to https://github.com/sveltejs/svelte/issues`
};
var parse5 = {
  /** @param {string} name */
  "unclosed-element": (name) => `<${name}> was left open`,
  "unclosed-block": () => `block was left open`,
  "unexpected-block-close": () => `Unexpected block closing tag`,
  "unexpected-eof": () => `Unexpected end of input`,
  /** @param {string} message */
  "js-parse-error": (message) => message,
  /** @param {string} token */
  "expected-token": (token) => `Expected token ${token}`,
  /** @param {string} word */
  "unexpected-reserved-word": (word) => `'${word}' is a reserved word in JavaScript and cannot be used here`,
  "missing-whitespace": () => `Expected whitespace`,
  "expected-pattern": () => `Expected identifier or destructure pattern`,
  "invalid-script-context": () => `If the context attribute is supplied, its value must be "module"`,
  "invalid-elseif": () => `'elseif' should be 'else if'`,
  /**
   * @param {string} child
   * @param {string} parent
   */
  "invalid-block-parent": (child, parent) => `Expected to close ${parent} before seeing ${child} block`,
  /**
   * @param {string} child
   * @param {string} parent
   */
  "invalid-block-missing-parent": (child, parent) => `${child} block must be a child of ${parent}`,
  "expected-block-type": () => `Expected 'if', 'each', 'await' or 'key'`,
  "expected-identifier": () => `Expected an identifier`,
  "invalid-debug": () => `{@debug ...} arguments must be identifiers, not arbitrary expressions`,
  "invalid-const": () => `{@const ...} must be an assignment`,
  /**
   * @param {string} location
   * @param {string} name
   */
  "invalid-block-placement": (location, name) => `{#${name} ...} block cannot be ${location}`,
  /**
   * @param {string} location
   * @param {string} name
   */
  "invalid-tag-placement": (location, name) => `{@${name} ...} tag cannot be ${location}`,
  "missing-attribute-value": () => `Expected attribute value`,
  /** @param {string} delimiter */
  "unclosed-attribute-value": (delimiter) => `Expected closing ${delimiter} character`,
  "invalid-directive-value": () => `Directive value must be a JavaScript expression enclosed in curly braces`,
  /** @param {string} type */
  "empty-directive-name": (type) => `${type} name cannot be empty`,
  /** @param {string} name */
  "invalid-closing-tag": (name) => `</${name}> attempted to close an element that was not open`,
  /**
   * @param {string} name
   * @param {string} reason
   */
  "invalid-closing-tag-after-autoclose": (name, reason) => `</${name}> attempted to close element that was already automatically closed by <${reason}>`,
  "invalid-dollar-binding": () => `The $ name is reserved, and cannot be used for variables and imports`,
  "invalid-dollar-global": () => `The $ name is reserved. To reference a global variable called $, use globalThis.$`,
  "illegal-subscription": () => `Cannot reference store value inside <script context="module">`,
  "duplicate-style-element": () => `A component can have a single top-level <style> element`,
  "duplicate-script-element": () => `A component can have a single top-level <script> element and/or a single top-level <script context="module"> element`
};
var css = {
  /** @param {string} message */
  "css-parse-error": (message) => message,
  "invalid-css-empty-declaration": () => `Declaration cannot be empty`,
  "invalid-css-global-placement": () => `:global(...) can be at the start or end of a selector sequence, but not in the middle`,
  "invalid-css-global-selector": () => `:global(...) must contain exactly one selector`,
  "invalid-css-global-selector-list": () => `:global(...) cannot be used to modify a selector, or be modified by another selector`,
  "invalid-css-selector": () => `Invalid selector`,
  "invalid-css-identifier": () => "Expected a valid CSS identifier"
};
var special_elements = {
  "invalid-svelte-option-attribute": () => `<svelte:options> can only receive static attributes`,
  "invalid-svelte-option-namespace": () => `Unsupported <svelte:option> value for "namespace". Valid values are "html", "svg" or "foreign".`,
  "tag-option-deprecated": () => `"tag" option is deprecated \u2014 use "customElement" instead`,
  "invalid-svelte-option-runes": () => `Unsupported <svelte:option> value for "runes". Valid values are true or false.`,
  "invalid-svelte-option-accessors": () => 'Unsupported <svelte:option> value for "accessors". Valid values are true or false.',
  "invalid-svelte-option-preserveWhitespace": () => 'Unsupported <svelte:option> value for "preserveWhitespace". Valid values are true or false.',
  "invalid-svelte-option-immutable": () => 'Unsupported <svelte:option> value for "immutable". Valid values are true or false.',
  "invalid-tag-property": () => 'tag name must be two or more words joined by the "-" character',
  "invalid-svelte-option-customElement": () => '"customElement" must be a string literal defining a valid custom element name or an object of the form { tag: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }',
  "invalid-customElement-props-attribute": () => '"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"',
  "invalid-customElement-shadow-attribute": () => '"shadow" must be either "open" or "none"',
  "unknown-svelte-option-attribute": (
    /** @param {string} name */
    (name) => `<svelte:options> unknown attribute '${name}'`
  ),
  "invalid-svelte-fragment-attribute": () => `<svelte:fragment> can only have a slot attribute and (optionally) a let: directive`,
  "invalid-svelte-fragment-slot": () => `<svelte:fragment> slot attribute must have a static value`,
  /** @param {string} name */
  "invalid-svelte-element-placement": (name) => `<${name}> tags cannot be inside elements or blocks`,
  /** @param {string} name */
  "duplicate-svelte-element": (name) => `A component can only have one <${name}> element`,
  "invalid-self-placement": () => `<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components`,
  "missing-svelte-element-definition": () => `<svelte:element> must have a 'this' attribute`,
  "missing-svelte-component-definition": () => `<svelte:component> must have a 'this' attribute`,
  "invalid-svelte-element-definition": () => `Invalid element definition \u2014 must be an {expression}`,
  "invalid-svelte-component-definition": () => `Invalid component definition \u2014 must be an {expression}`,
  /**
   * @param {string[]} tags
   * @param {string | null} match
   */
  "invalid-svelte-tag": (tags, match) => `Valid <svelte:...> tag names are ${list(tags)}${match ? " (did you mean " + match + "?)" : ""}`
};
var runes = {
  "invalid-legacy-props": () => `Cannot use $$props in runes mode`,
  "invalid-legacy-rest-props": () => `Cannot use $$restProps in runes mode`,
  "invalid-legacy-reactive-statement": () => `$: is not allowed in runes mode, use $derived or $effect instead`,
  "invalid-legacy-export": () => `Cannot use \`export let\` in runes mode \u2014 use $props instead`,
  /** @param {string} rune */
  "invalid-rune-usage": (rune) => `Cannot use ${rune} rune in non-runes mode`,
  /** @param {string} rune */
  "invalid-rune-export": (rune) => `Cannot export value created with ${rune}`,
  "invalid-props-id": () => `$props() can only be used with an object destructuring pattern`,
  "invalid-props-pattern": () => `$props() assignment must not contain nested properties or computed keys`,
  "invalid-props-location": () => `$props() can only be used at the top level of components as a variable declaration initializer`,
  "invalid-derived-location": () => `$derived() can only be used as a variable declaration initializer`,
  "invalid-state-location": () => `$state() can only be used as a variable declaration initializer`,
  "invalid-effect-location": () => `$effect() can only be used as an expression statement`,
  /**
   * @param {boolean} is_binding
   * @param {boolean} show_details
   */
  "invalid-const-assignment": (is_binding, show_details) => `Invalid ${is_binding ? "binding" : "assignment"} to const variable${show_details ? " ($derived values, let: directives, :then/:catch variables and @const declarations count as const)" : ""}`,
  "invalid-derived-assignment": () => `Invalid assignment to derived state`,
  /**
   * @param {string} rune
   * @param {number[]} args
   */
  "invalid-rune-args-length": (rune, args) => `${rune} can only be called with ${list(args, "or")} ${args.length === 1 && args[0] === 1 ? "argument" : "arguments"}`,
  "duplicate-props-rune": () => `Cannot use $props() more than once`
};
var elements = {
  "invalid-textarea-content": () => `A <textarea> can have either a value attribute or (equivalently) child content, but not both`,
  "invalid-void-content": () => `Void elements cannot have children or closing tags`,
  /** @param {string} name */
  "invalid-element-content": (name) => `<${name}> cannot have children`,
  "invalid-tag-name": () => "Expected valid tag name",
  /**
   * @param {string} node
   * @param {string} parent
   */
  "invalid-node-placement": (node, parent) => `${node} is invalid inside <${parent}>`
};
var components = {
  "invalid-component-directive": () => `Directive is not valid on components`
};
var attributes = {
  "empty-attribute-shorthand": () => `Attribute shorthand cannot be empty`,
  "duplicate-attribute": () => `Attributes need to be unique`
};
var slots = {
  "invalid-slot-element-attribute": () => `<slot> can only receive attributes, not directives`,
  "invalid-slot-attribute": () => `slot attribute must be a static value`,
  "invalid-slot-name": () => `slot attribute must be a static value`,
  "invalid-slot-placement": () => `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element`,
  "duplicate-slot-name": (
    /** @param {string} name @param {string} component */
    (name, component) => `Duplicate slot name '${name}' in <${component}>`
  ),
  "invalid-default-slot-content": () => `Found default slot content alongside an explicit slot="default"`
};
var bindings = {
  "invalid-binding-expression": () => `Can only bind to an Identifier or MemberExpression`,
  "invalid-binding-value": () => `Can only bind to state or props`,
  /**
   * @param {string} binding
   * @param {string} [elements]
   * @param {string} [post]
   */
  "invalid-binding": (binding, elements2, post = "") => (elements2 ? `'${binding}' binding can only be used with ${elements2}` : `'${binding}' is not a valid binding`) + post,
  "invalid-type-attribute": () => `'type' attribute must be a static text value if input uses two-way binding`,
  "invalid-multiple-attribute": () => `'multiple' attribute must be static if select uses two-way binding`
};
var variables = {
  "illegal-global": (
    /** @param {string} name */
    (name) => `${name} is an illegal variable name. To reference a global variable called ${name}, use globalThis.${name}`
  )
};
var legacy_reactivity = {
  "cyclical-reactive-declaration": (
    /** @param {string[]} cycle */
    (cycle) => `Cyclical dependency detected: ${cycle.join(" \u2192 ")}`
  )
};
var compiler_options = {
  "invalid-compiler-option-namespace": () => `Unsupported compiler option value for "namespace". Valid values are "html", "svg" or "foreign".`
};
var errors = {
  ...internal,
  ...parse5,
  ...css,
  ...special_elements,
  ...runes,
  ...elements,
  ...components,
  ...attributes,
  ...slots,
  ...bindings,
  ...variables,
  ...compiler_options,
  ...legacy_reactivity
  // missing_contenteditable_attribute: {
  // 	code: 'missing-contenteditable-attribute',
  // 	message:
  // 		"'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings"
  // },
  // dynamic_contenteditable_attribute: {
  // 	code: 'dynamic-contenteditable-attribute',
  // 	message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
  // },
  // invalid_event_modifier_combination: /**
  //  * @param {string} modifier1
  //  * @param {string} modifier2
  //  */ (modifier1, modifier2) => ({
  // 	code: 'invalid-event-modifier',
  // 	message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
  // }),
  // invalid_event_modifier_legacy: /** @param {string} modifier */ (modifier) => ({
  // 	code: 'invalid-event-modifier',
  // 	message: `The '${modifier}' modifier cannot be used in legacy mode`
  // }),
  // invalid_event_modifier: /** @param {string} valid */ (valid) => ({
  // 	code: 'invalid-event-modifier',
  // 	message: `Valid event modifiers are ${valid}`
  // }),
  // invalid_event_modifier_component: {
  // 	code: 'invalid-event-modifier',
  // 	message: "Event modifiers other than 'once' can only be used on DOM elements"
  // },
  // textarea_duplicate_value: {
  // 	code: 'textarea-duplicate-value',
  // 	message:
  // 		'A <textarea> can have either a value attribute or (equivalently) child content, but not both'
  // },
  // illegal_attribute: /** @param {string} name */ (name) => ({
  // 	code: 'illegal-attribute',
  // 	message: `'${name}' is not a valid attribute name`
  // }),
  // invalid_attribute_head: {
  // 	code: 'invalid-attribute',
  // 	message: '<svelte:head> should not have any attributes or directives'
  // },
  // invalid_action: {
  // 	code: 'invalid-action',
  // 	message: 'Actions can only be applied to DOM elements, not components'
  // },
  // invalid_animation: {
  // 	code: 'invalid-animation',
  // 	message: 'Animations can only be applied to DOM elements, not components'
  // },
  // invalid_class: {
  // 	code: 'invalid-class',
  // 	message: 'Classes can only be applied to DOM elements, not components'
  // },
  // invalid_transition: {
  // 	code: 'invalid-transition',
  // 	message: 'Transitions can only be applied to DOM elements, not components'
  // },
  // invalid_let: {
  // 	code: 'invalid-let',
  // 	message: 'let directive value must be an identifier or an object/array pattern'
  // },
  // invalid_slot_directive: {
  // 	code: 'invalid-slot-directive',
  // 	message: '<slot> cannot have directives'
  // },
  // dynamic_slot_name: {
  // 	code: 'dynamic-slot-name',
  // 	message: '<slot> name cannot be dynamic'
  // },
  // invalid_slot_name: {
  // 	code: 'invalid-slot-name',
  // 	message: 'default is a reserved word — it cannot be used as a slot name'
  // },
  // invalid_slot_attribute_value_missing: {
  // 	code: 'invalid-slot-attribute',
  // 	message: 'slot attribute value is missing'
  // },
  // invalid_slotted_content_fragment: {
  // 	code: 'invalid-slotted-content',
  // 	message: '<svelte:fragment> must be a child of a component'
  // },
  // illegal_attribute_title: {
  // 	code: 'illegal-attribute',
  // 	message: '<title> cannot have attributes'
  // },
  // illegal_structure_title: {
  // 	code: 'illegal-structure',
  // 	message: '<title> can only contain text and {tags}'
  // },
  // duplicate_transition: /**
  //  * @param {string} directive
  //  * @param {string} parent_directive
  //  */ (directive, parent_directive) => {
  // 	/** @param {string} _directive */
  // 	function describe(_directive) {
  // 		return _directive === 'transition' ? "a 'transition'" : `an '${_directive}'`;
  // 	}
  // 	const message =
  // 		directive === parent_directive
  // 			? `An element can only have one '${directive}' directive`
  // 			: `An element cannot have both ${describe(parent_directive)} directive and ${describe(
  // 					directive
  // 			  )} directive`;
  // 	return {
  // 		code: 'duplicate-transition',
  // 		message
  // 	};
  // },
  // contextual_store: {
  // 	code: 'contextual-store',
  // 	message:
  // 		'Stores must be declared at the top level of the component (this may change in a future version of Svelte)'
  // },
  // default_export: {
  // 	code: 'default-export',
  // 	message: 'A component cannot have a default export'
  // },
  // illegal_declaration: {
  // 	code: 'illegal-declaration',
  // 	message: 'The $ prefix is reserved, and cannot be used for variable and import names'
  // },
  // illegal_subscription: {
  // 	code: 'illegal-subscription',
  // 	message: 'Cannot reference store value inside <script context="module">'
  // },
  // illegal_global: /** @param {string} name */ (name) => ({
  // 	code: 'illegal-global',
  // 	message: `${name} is an illegal variable name`
  // }),
  // illegal_variable_declaration: {
  // 	code: 'illegal-variable-declaration',
  // 	message: 'Cannot declare same variable name which is imported inside <script context="module">'
  // },
  // css_invalid_global: {
  // 	code: 'css-invalid-global',
  // 	message: ':global(...) can be at the start or end of a selector sequence, but not in the middle'
  // },
  // css_invalid_global_selector: {
  // 	code: 'css-invalid-global-selector',
  // 	message: ':global(...) must contain a single selector'
  // },
  // css_invalid_global_selector_position: {
  // 	code: 'css-invalid-global-selector-position',
  // 	message:
  // 		':global(...) not at the start of a selector sequence should not contain type or universal selectors'
  // },
  // css_invalid_selector: /** @param {string} selector */ (selector) => ({
  // 	code: 'css-invalid-selector',
  // 	message: `Invalid selector "${selector}"`
  // }),
  // duplicate_animation: {
  // 	code: 'duplicate-animation',
  // 	message: "An element can only have one 'animate' directive"
  // },
  // invalid_animation_immediate: {
  // 	code: 'invalid-animation',
  // 	message:
  // 		'An element that uses the animate directive must be the immediate child of a keyed each block'
  // },
  // invalid_animation_key: {
  // 	code: 'invalid-animation',
  // 	message:
  // 		'An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?'
  // },
  // invalid_animation_sole: {
  // 	code: 'invalid-animation',
  // 	message:
  // 		'An element that uses the animate directive must be the sole child of a keyed each block'
  // },
  // invalid_animation_dynamic_element: {
  // 	code: 'invalid-animation',
  // 	message: '<svelte:element> cannot have a animate directive'
  // },
  // invalid_directive_value: {
  // 	code: 'invalid-directive-value',
  // 	message:
  // 		'Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)'
  // },
  // invalid_const_placement: {
  // 	code: 'invalid-const-placement',
  // 	message:
  // 		'{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>'
  // },
  // invalid_const_declaration: /** @param {string} name */ (name) => ({
  // 	code: 'invalid-const-declaration',
  // 	message: `'${name}' has already been declared`
  // }),
  // invalid_const_update: /** @param {string} name */ (name) => ({
  // 	code: 'invalid-const-update',
  // 	message: `'${name}' is declared using {@const ...} and is read-only`
  // }),
  // cyclical_const_tags: /** @param {string[]} cycle */ (cycle) => ({
  // 	code: 'cyclical-const-tags',
  // 	message: `Cyclical dependency detected: ${cycle.join(' → ')}`
  // }),
  // invalid_component_style_directive: {
  // 	code: 'invalid-component-style-directive',
  // 	message: 'Style directives cannot be used on components'
  // },
  // invalid_var_declaration: {
  // 	code: 'invalid_var_declaration',
  // 	message: '"var" scope should not extend outside the reactive block'
  // },
  // invalid_style_directive_modifier: /** @param {string} valid */ (valid) => ({
  // 	code: 'invalid-style-directive-modifier',
  // 	message: `Valid modifiers for style directives are: ${valid}`
  // })
};
var CompileError = class extends Error {
  name = "CompileError";
  /** @type {import('#compiler').CompileError['filename']} */
  filename = void 0;
  /** @type {import('#compiler').CompileError['position']} */
  position = void 0;
  /** @type {import('#compiler').CompileError['start']} */
  start = void 0;
  /** @type {import('#compiler').CompileError['end']} */
  end = void 0;
  /**
   *
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(message);
    this.code = code;
    this.position = position;
  }
  toString() {
    let out = `${this.name}: ${this.message}`;
    out += `
(${this.code})`;
    if (this.filename) {
      out += `
${this.filename}`;
      if (this.start) {
        out += `${this.start.line}:${this.start.column}`;
      }
    }
    return out;
  }
};
function error(node, code, ...args) {
  const fn = errors[code];
  const message = fn(...args);
  const start = typeof node === "number" ? node : node?.start;
  const end = typeof node === "number" ? node : node?.end;
  throw new CompileError(
    code,
    message,
    start !== void 0 && end !== void 0 ? [start, end] : void 0
  );
}

// src/compiler/phases/1-parse/read/expression.js
function read_expression(parser) {
  try {
    const node = parse_expression_at(parser.template, parser.index);
    let num_parens = 0;
    for (let i = parser.index; i < /** @type {number} */
    node.start; i += 1) {
      if (parser.template[i] === "(")
        num_parens += 1;
    }
    let index = (
      /** @type {number} */
      node.end
    );
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        error(index, "expected-token", ")");
      }
      index += 1;
    }
    parser.index = index;
    return (
      /** @type {import('estree').Expression} */
      node
    );
  } catch (err) {
    parser.acorn_error(err);
  }
}

// src/compiler/phases/1-parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
function get_context(attributes3) {
  const context = attributes3.find(
    /** @param {any} attribute */
    (attribute) => attribute.name === "context"
  );
  if (!context)
    return "default";
  if (context.value.length !== 1 || context.value[0].type !== "Text") {
    error(context.start, "invalid-script-context");
  }
  const value = context.value[0].data;
  if (value !== "module") {
    error(context.start, "invalid-script-context");
  }
  return value;
}
function read_script(parser, start, attributes3) {
  const script_start = parser.index;
  const data2 = parser.read_until(regex_closing_script_tag);
  if (parser.index >= parser.template.length) {
    error(parser.template.length, "unclosed-element", "script");
  }
  const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data2;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse4(source);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  return {
    type: "Script",
    start,
    end: parser.index,
    context: get_context(attributes3),
    content: ast,
    parent: null
  };
}

// src/compiler/phases/1-parse/read/style.js
var REGEX_MATCHER = /^[~^$*|]?=/;
var REGEX_CLOSING_PAREN = /\)/;
var REGEX_CLOSING_BRACKET = /[\s\]]/;
var REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/;
var REGEX_COMBINATOR_WHITESPACE = /^\s*(\+|~|>|\|\|)\s*/;
var REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
var REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
var REGEX_WHITESPACE_OR_COLON = /[\s:]/;
var REGEX_BRACE_OR_SEMICOLON = /[{;]/;
var REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
var REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
var REGEX_COMMENT_CLOSE = /\*\//;
var REGEX_HTML_COMMENT_CLOSE = /-->/;
function read_style(parser, start, attributes3) {
  const content_start = parser.index;
  const children = read_body(parser, "</style");
  const content_end = parser.index;
  parser.read(/^<\/style\s*>/);
  return {
    type: "Style",
    start,
    end: parser.index,
    attributes: attributes3,
    children,
    content: {
      start: content_start,
      end: content_end,
      styles: parser.template.slice(content_start, content_end)
    },
    parent: null
  };
}
function read_body(parser, close2) {
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match(close2)) {
      return children;
    }
    if (parser.match("@")) {
      children.push(read_at_rule(parser));
    } else {
      children.push(read_rule(parser));
    }
  }
  error(parser.template.length, "expected-token", close2);
}
function read_at_rule(parser) {
  const start = parser.index;
  parser.eat("@", true);
  const name = read_identifier(parser);
  const prelude = parser.read_until(REGEX_BRACE_OR_SEMICOLON).trim();
  let block2 = null;
  if (parser.match("{")) {
    const contains_declarations = [
      "color-profile",
      "counter-style",
      "font-face",
      "font-palette-values",
      "page",
      "property"
    ].includes(name);
    if (contains_declarations) {
      block2 = read_block(parser);
    } else {
      const start2 = parser.index;
      parser.eat("{", true);
      const children = read_body(parser, "}");
      parser.eat("}", true);
      block2 = {
        type: "Block",
        start: start2,
        end: parser.index,
        children
      };
    }
  } else {
    parser.eat(";", true);
  }
  return {
    type: "Atrule",
    start,
    end: parser.index,
    name,
    prelude,
    block: block2
  };
}
function read_rule(parser) {
  const start = parser.index;
  return {
    type: "Rule",
    prelude: read_selector_list(parser),
    block: read_block(parser),
    start,
    end: parser.index
  };
}
function read_selector_list(parser) {
  const children = [];
  const start = parser.index;
  while (parser.index < parser.template.length) {
    children.push(read_selector(parser));
    const end = parser.index;
    parser.allow_whitespace();
    if (parser.match("{")) {
      return {
        type: "SelectorList",
        start,
        end,
        children
      };
    } else {
      parser.eat(",", true);
      allow_comment_or_whitespace(parser);
    }
  }
  error(parser.template.length, "unexpected-eof");
}
function read_selector(parser) {
  const list_start = parser.index;
  const children = [];
  while (parser.index < parser.template.length) {
    const start = parser.index;
    if (parser.eat("*")) {
      children.push({
        type: "TypeSelector",
        name: "*",
        start,
        end: parser.index
      });
    } else if (parser.eat("#")) {
      children.push({
        type: "IdSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat(".")) {
      children.push({
        type: "ClassSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat("::")) {
      children.push({
        type: "PseudoElementSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat(":")) {
      const name = read_identifier(parser);
      let args = null;
      if (parser.eat("(")) {
        args = parser.read_until(REGEX_CLOSING_PAREN);
        parser.eat(")", true);
      }
      children.push({
        type: "PseudoClassSelector",
        name,
        args,
        start,
        end: parser.index
      });
    } else if (parser.eat("[")) {
      parser.allow_whitespace();
      const name = read_identifier(parser);
      parser.allow_whitespace();
      let value = null;
      const matcher = parser.read(REGEX_MATCHER);
      if (matcher) {
        parser.allow_whitespace();
        value = read_attribute_value(parser);
      }
      parser.allow_whitespace();
      const flags = parser.read(REGEX_ATTRIBUTE_FLAGS);
      parser.allow_whitespace();
      parser.eat("]", true);
      children.push({
        type: "AttributeSelector",
        start,
        end: parser.index,
        name,
        matcher,
        value,
        flags
      });
    } else if (parser.match_regex(REGEX_COMBINATOR_WHITESPACE)) {
      parser.allow_whitespace();
      const start2 = parser.index;
      children.push({
        type: "Combinator",
        name: (
          /** @type {string} */
          parser.read(REGEX_COMBINATOR)
        ),
        start: start2,
        end: parser.index
      });
      parser.allow_whitespace();
    } else if (parser.match_regex(REGEX_PERCENTAGE)) {
      children.push({
        type: "Percentage",
        value: (
          /** @type {string} */
          parser.read(REGEX_PERCENTAGE)
        ),
        start,
        end: parser.index
      });
    } else {
      children.push({
        type: "TypeSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    }
    const index = parser.index;
    parser.allow_whitespace();
    if (parser.match("{") || parser.match(",")) {
      parser.index = index;
      return {
        type: "Selector",
        start: list_start,
        end: index,
        children
      };
    }
    if (parser.index !== index && !parser.match_regex(REGEX_COMBINATOR)) {
      children.push({
        type: "Combinator",
        name: " ",
        start: index,
        end: parser.index
      });
    }
  }
  error(parser.template.length, "unexpected-eof");
}
function read_block(parser) {
  const start = parser.index;
  parser.eat("{", true);
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match("}")) {
      break;
    } else {
      children.push(read_declaration(parser));
    }
  }
  parser.eat("}", true);
  return {
    type: "Block",
    start,
    end: parser.index,
    children
  };
}
function read_declaration(parser) {
  const start = parser.index;
  const property = parser.read_until(REGEX_WHITESPACE_OR_COLON);
  parser.allow_whitespace();
  parser.eat(":");
  parser.allow_whitespace();
  const value = read_declaration_value(parser);
  const end = parser.index;
  if (!parser.match("}")) {
    parser.eat(";", true);
  }
  return {
    type: "Declaration",
    start,
    end,
    property,
    value
  };
}
function read_declaration_value(parser) {
  let value = "";
  let escaped = false;
  let in_url = false;
  let quote_mark = null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (char === quote_mark) {
      quote_mark = null;
    } else if (char === ")") {
      in_url = false;
    } else if (quote_mark === null && (char === '"' || char === "'")) {
      quote_mark = char;
    } else if (char === "(" && value.slice(-3) === "url") {
      in_url = true;
    } else if ((char === ";" || char === "}") && !in_url && !quote_mark) {
      return value.trim();
    }
    value += char;
    parser.index++;
  }
  error(parser.template.length, "unexpected-eof");
}
function read_attribute_value(parser) {
  let value = "";
  let escaped = false;
  const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
      if (quote_mark) {
        parser.eat(quote_mark, true);
      }
      return value.trim();
    } else {
      value += char;
    }
    parser.index++;
  }
  error(parser.template.length, "unexpected-eof");
}
function read_identifier(parser) {
  const start = parser.index;
  let identifier = "";
  if (parser.match("--") || parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
    error(start, "invalid-css-identifier");
  }
  let escaped = false;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      identifier += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (
      /** @type {number} */
      char.codePointAt(0) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char)
    ) {
      identifier += char;
    } else {
      break;
    }
    parser.index++;
  }
  if (identifier === "") {
    error(start, "invalid-css-identifier");
  }
  return identifier;
}
function allow_comment_or_whitespace(parser) {
  parser.allow_whitespace();
  while (parser.match("/*") || parser.match("<!--")) {
    if (parser.eat("/*")) {
      parser.read_until(REGEX_COMMENT_CLOSE);
      parser.eat("*/", true);
    }
    if (parser.eat("<!--")) {
      parser.read_until(REGEX_HTML_COMMENT_CLOSE);
      parser.eat("-->", true);
    }
    parser.allow_whitespace();
  }
}

// src/compiler/phases/1-parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// src/compiler/phases/1-parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    /** @param {any} entity_name */
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html.replace(
    entity_pattern,
    /**
     * @param {any} match
     * @param {keyof typeof entities} entity
     */
    (match, entity) => {
      let code;
      if (entity[0] !== "#") {
        code = entities_default[entity];
      } else if (entity[1] === "x") {
        code = parseInt(entity.substring(2), 16);
      } else {
        code = parseInt(entity.substring(1), 10);
      }
      if (!code) {
        return match;
      }
      return String.fromCodePoint(validate_code(code));
    }
  );
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  return NUL;
}
var disallowed_contents = {
  li: /* @__PURE__ */ new Set(["li"]),
  dt: /* @__PURE__ */ new Set(["dt", "dd"]),
  dd: /* @__PURE__ */ new Set(["dt", "dd"]),
  p: new Set(
    "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(
      " "
    )
  ),
  rt: /* @__PURE__ */ new Set(["rt", "rp"]),
  rp: /* @__PURE__ */ new Set(["rt", "rp"]),
  optgroup: /* @__PURE__ */ new Set(["optgroup"]),
  option: /* @__PURE__ */ new Set(["option", "optgroup"]),
  thead: /* @__PURE__ */ new Set(["tbody", "tfoot"]),
  tbody: /* @__PURE__ */ new Set(["tbody", "tfoot"]),
  tfoot: /* @__PURE__ */ new Set(["tbody"]),
  tr: /* @__PURE__ */ new Set(["tr", "tbody"]),
  td: /* @__PURE__ */ new Set(["td", "th", "tr"]),
  th: /* @__PURE__ */ new Set(["td", "th", "tr"])
};
function closing_tag_omitted(current2, next2) {
  if (disallowed_contents[current2]) {
    if (!next2 || disallowed_contents[current2].has(next2)) {
      return true;
    }
  }
  return false;
}

// src/compiler/phases/1-parse/utils/create.js
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    transparent
  };
}

// src/compiler/phases/nodes.js
var element_nodes = [
  "SvelteElement",
  "RegularElement",
  "SvelteFragment",
  "Component",
  "SvelteComponent",
  "SvelteSelf",
  "SlotElement"
];
function is_element_node(node) {
  return element_nodes.includes(node.type);
}
function is_custom_element_node(node) {
  return node.name.includes("-");
}
function create_attribute(name, start, end, value) {
  return {
    type: "Attribute",
    start,
    end,
    name,
    value,
    parent: null,
    metadata: {
      dynamic: false
    }
  };
}

// src/compiler/phases/1-parse/state/element.js
var valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "SvelteHead"],
  ["svelte:options", "SvelteOptions"],
  ["svelte:window", "SvelteWindow"],
  ["svelte:document", "SvelteDocument"],
  ["svelte:body", "SvelteBody"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "SvelteElement"],
  ["svelte:component", "SvelteComponent"],
  ["svelte:self", "SvelteSelf"],
  ["svelte:fragment", "SvelteFragment"]
]);
var valid_meta_tags = Array.from(meta_tags.keys());
var SELF = /^svelte:self(?=[\s/>])/;
var COMPONENT = /^svelte:component(?=[\s/>])/;
var SLOT = /^svelte:fragment(?=[\s/>])/;
var ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "SvelteHead")
      return true;
    if (type === "RegularElement" || type === "Component")
      return false;
  }
  return false;
}
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_capital_letter = /[A-Z]/;
function tag(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data2 = parser.read_until(regex_closing_comment);
    parser.eat("-->", true);
    parser.append({
      type: "Comment",
      start,
      end: parser.index,
      data: data2,
      ignores: extract_svelte_ignore(data2)
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name = read_tag_name(parser);
  if (root_only_meta_tags.has(name)) {
    if (is_closing_tag) {
      if ((name === "svelte:window" || name === "svelte:body" || name === "svelte:document") && /** @type {import('#compiler').ElementLike} */
      parent.fragment.nodes.length) {
        error(
          /** @type {number} */
          /** @type {import('#compiler').ElementLike} */
          parent.fragment.nodes[0].start,
          "invalid-element-content",
          name
        );
      }
    } else {
      if (name in parser.meta_tags) {
        error(start, "duplicate-svelte-element", name);
      }
      if (parent.type !== "Root") {
        error(start, "invalid-svelte-element-placement", name);
      }
      parser.meta_tags[name] = true;
    }
  }
  const type = meta_tags.has(name) ? meta_tags.get(name) : regex_capital_letter.test(name[0]) || name === "svelte:self" || name === "svelte:component" ? "Component" : name === "title" && parent_is_head(parser.stack) ? "TitleElement" : name === "slot" ? "SlotElement" : "RegularElement";
  const element = {
    type: (
      /** @type {import('#compiler').ElementLike['type']} */
      type
    ),
    start,
    end: -1,
    name,
    attributes: [],
    fragment: create_fragment(true),
    parent: null
  };
  parser.allow_whitespace();
  if (is_closing_tag) {
    if (is_void(name)) {
      error(start, "invalid-void-content");
    }
    parser.eat(">", true);
    while (
      /** @type {import('#compiler').RegularElement} */
      parent.name !== name
    ) {
      if (parent.type !== "RegularElement") {
        if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) {
          error(
            start,
            "invalid-closing-tag-after-autoclose",
            name,
            parser.last_auto_closed_tag.reason
          );
        } else {
          error(start, "invalid-closing-tag", name);
        }
      }
      parent.end = start;
      parser.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = void 0;
    }
    return;
  } else if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name)) {
    parent.end = start;
    parser.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name,
      depth: parser.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  let attribute;
  while (attribute = read_attribute(parser, unique_names)) {
    element.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (element.type === "SvelteComponent") {
    const index = element.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      error(start, "missing-svelte-component-definition");
    }
    const definition = (
      /** @type {import('#compiler').Attribute} */
      element.attributes.splice(index, 1)[0]
    );
    if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") {
      error(
        /** @type {number} */
        definition.start,
        "invalid-svelte-component-definition"
      );
    }
    element.expression = definition.value[0].expression;
  }
  if (element.type === "SvelteElement") {
    const index = element.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      error(start, "missing-svelte-element-definition");
    }
    const definition = (
      /** @type {import('#compiler').Attribute} */
      element.attributes.splice(index, 1)[0]
    );
    if (definition.value === true || definition.value.length !== 1) {
      error(
        /** @type {number} */
        definition.start,
        "invalid-svelte-element-definition"
      );
    }
    const chunk = definition.value[0];
    element.tag = chunk.type === "Text" ? { type: "Literal", value: chunk.data, raw: `'${chunk.raw}'` } : chunk.expression;
  }
  const current2 = parser.current();
  if ((name === "script" || name === "style") && current2.type === "Root") {
    parser.eat(">", true);
    if (name === "script") {
      const content = read_script(parser, start, element.attributes);
      if (content) {
        if (content.context === "module") {
          if (current2.module)
            error(start, "duplicate-script-element");
          current2.module = content;
        } else {
          if (current2.instance)
            error(start, "duplicate-script-element");
          current2.instance = content;
        }
      }
    } else {
      const content = read_style(parser, start, element.attributes);
      if (content) {
        if (current2.css)
          error(start, "duplicate-style-element");
        current2.css = content;
      }
    }
    return;
  }
  parser.append(element);
  const self_closing = parser.eat("/") || is_void(name);
  parser.eat(">", true);
  if (self_closing) {
    element.end = parser.index;
  } else if (name === "textarea") {
    element.fragment.nodes = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element.end = parser.index;
  } else if (name === "script" || name === "style") {
    const start2 = parser.index;
    const data2 = parser.read_until(new RegExp(`</${name}>`));
    const end = parser.index;
    const node = {
      start: start2,
      end,
      type: "Text",
      data: data2,
      raw: data2,
      parent: null
    };
    element.fragment.nodes.push(node);
    parser.eat(`</${name}>`, true);
    element.end = parser.index;
  } else {
    parser.stack.push(element);
    parser.fragments.push(element.fragment);
  }
}
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
function read_tag_name(parser) {
  const start = parser.index;
  if (parser.read(SELF)) {
    let i = parser.stack.length;
    let legal = false;
    while (i--) {
      const fragment2 = parser.stack[i];
      if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "Component") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      error(start, "invalid-self-placement");
    }
    return "svelte:self";
  }
  if (parser.read(COMPONENT))
    return "svelte:component";
  if (parser.read(ELEMENT))
    return "svelte:element";
  if (parser.read(SLOT))
    return "svelte:fragment";
  const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (meta_tags.has(name))
    return name;
  if (name.startsWith("svelte:")) {
    const match = fuzzymatch(name.slice(7), valid_meta_tags);
    error(start, "invalid-svelte-tag", valid_meta_tags, match);
  }
  if (!valid_tag_name.test(name)) {
    error(start, "invalid-tag-name");
  }
  return name;
}
var regex_token_ending_character = /[\s=\/>"']/;
var regex_starts_with_quote_characters = /^["']/;
function read_attribute(parser, unique_names) {
  const start = parser.index;
  function check_unique(name2) {
    if (unique_names.has(name2)) {
      error(start, "duplicate-attribute");
    }
    unique_names.add(name2);
  }
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const spread = {
        type: "SpreadAttribute",
        start,
        end: parser.index,
        expression,
        parent: null,
        metadata: {
          dynamic: false
        }
      };
      return spread;
    } else {
      const value_start = parser.index;
      const name2 = parser.read_identifier();
      if (name2 === null) {
        error(start, "empty-attribute-shorthand");
      }
      check_unique(name2);
      parser.allow_whitespace();
      parser.eat("}", true);
      const expression = {
        type: "ExpressionTag",
        start: value_start,
        end: value_start + name2.length,
        expression: {
          start: value_start,
          end: value_start + name2.length,
          type: "Identifier",
          name: name2
        },
        parent: null,
        metadata: {
          dynamic: false,
          contains_call_expression: false
        }
      };
      return create_attribute(name2, start, parser.index, [expression]);
    }
  }
  const name = parser.read_until(regex_token_ending_character);
  if (!name)
    return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    value = read_attribute_value2(parser);
    end = parser.index;
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    error(parser.index, "expected-token", "=");
  }
  if (type) {
    const [directive_name, ...modifiers] = name.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      error(start + colon_index + 1, "empty-directive-name", type);
    }
    if (type === "BindDirective" && directive_name !== "this") {
      check_unique(directive_name);
    } else if (type !== "OnDirective" && type !== "UseDirective") {
      check_unique(name);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers: (
          /** @type {Array<'important'>} */
          modifiers
        ),
        value,
        parent: null,
        metadata: {
          dynamic: false
        }
      };
    }
    const first_value = value === true ? void 0 : value[0];
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        error(
          /** @type {number} */
          first_value.start,
          "invalid-directive-value"
        );
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      modifiers,
      expression
    };
    if (directive.type === "ClassDirective") {
      directive.metadata = {
        dynamic: false
      };
    }
    if (directive.type === "TransitionDirective") {
      const direction = name.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = /** @type {any} */
      {
        start: start + colon_index + 1,
        end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  check_unique(name);
  return create_attribute(name, start, end, value);
}
function get_directive_type(name) {
  if (name === "use")
    return "UseDirective";
  if (name === "animate")
    return "AnimateDirective";
  if (name === "bind")
    return "BindDirective";
  if (name === "class")
    return "ClassDirective";
  if (name === "style")
    return "StyleDirective";
  if (name === "on")
    return "OnDirective";
  if (name === "let")
    return "LetDirective";
  if (name === "in" || name === "out" || name === "transition")
    return "TransitionDirective";
  return false;
}
function read_attribute_value2(parser) {
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: "",
        parent: null
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark)
          return parser.match(quote_mark);
        return !!parser.match_regex(regex_starts_with_invalid_attr_value);
      },
      "in attribute value"
    );
  } catch (e) {
    if (e.code === "parse-error") {
      if (parser.template.slice(e.pos - 1, e.pos + 1) === "/>") {
        parser.index = e.pos;
        error(e.pos, "unclosed-attribute-value", quote_mark || "}");
      }
    }
    throw e;
  }
  if (value.length === 0 && !quote_mark) {
    error(parser.index, "missing-attribute-value");
  }
  if (quote_mark)
    parser.index += 1;
  return value;
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: -1,
    type: "Text",
    raw: "",
    data: "",
    parent: null
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name = parser.read_until(/[^a-z]/);
        error(index2, "invalid-block-placement", location, name);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name = parser.read_until(/[^a-z]/);
        error(index2, "invalid-tag-placement", location, name);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const chunk = {
        type: "ExpressionTag",
        start: index,
        end: parser.index,
        expression,
        parent: null,
        metadata: {
          contains_call_expression: false,
          dynamic: false
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser.index,
        end: -1,
        type: "Text",
        raw: "",
        data: "",
        parent: null
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  error(parser.template.length, "unexpected-eof");
}

// src/compiler/phases/1-parse/utils/full_char_code_at.js
function full_char_code_at(str, i) {
  const code = str.charCodeAt(i);
  if (code <= 55295 || code >= 57344)
    return code;
  const next2 = str.charCodeAt(i + 1);
  return (code << 10) + next2 - 56613888;
}

// src/compiler/phases/1-parse/utils/bracket.js
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code) {
  return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code) {
  return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open2, close2) {
  return open2 === SQUARE_BRACKET_OPEN && close2 === SQUARE_BRACKET_CLOSE || open2 === CURLY_BRACKET_OPEN && close2 === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open2) {
  if (open2 === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open2 === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}

// src/compiler/phases/1-parse/read/context.js
function read_context(parser) {
  const start = parser.index;
  let i = parser.index;
  const code = full_char_code_at(parser.template, i);
  if (isIdentifierStart(code, true)) {
    return {
      type: "Identifier",
      name: (
        /** @type {string} */
        parser.read_identifier()
      ),
      start,
      end: parser.index
    };
  }
  if (!is_bracket_open(code)) {
    error(i, "expected-pattern");
  }
  const bracket_stack = [code];
  i += code <= 65535 ? 1 : 2;
  while (i < parser.template.length) {
    const code2 = full_char_code_at(parser.template, i);
    if (is_bracket_open(code2)) {
      bracket_stack.push(code2);
    } else if (is_bracket_close(code2)) {
      const popped = (
        /** @type {number} */
        bracket_stack.pop()
      );
      if (!is_bracket_pair(popped, code2)) {
        error(
          i,
          "expected-token",
          String.fromCharCode(
            /** @type {number} */
            get_bracket_close(popped)
          )
        );
      }
      if (bracket_stack.length === 0) {
        i += code2 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code2 <= 65535 ? 1 : 2;
  }
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    return (
      /** @type {any} */
      parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left
    );
  } catch (error2) {
    parser.acorn_error(error2);
  }
}

// src/compiler/phases/1-parse/state/tag.js
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function mustache(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("#"))
    return open(parser);
  if (parser.eat("/"))
    return close(parser);
  if (parser.eat(":"))
    return next(parser);
  if (parser.eat("@"))
    return special(parser);
  const expression = read_expression(parser);
  parser.allow_whitespace();
  parser.eat("}", true);
  parser.append(
    /** @type {import('#compiler').ExpressionTag} */
    {
      type: "ExpressionTag",
      start,
      end: parser.index,
      expression,
      metadata: {
        contains_call_expression: false,
        dynamic: false
      }
    }
  );
}
function open(parser) {
  const start = parser.index - 2;
  if (parser.eat("if")) {
    parser.require_whitespace();
    const block2 = parser.append(
      /** @type {import('#compiler').IfBlock} */
      {
        type: "IfBlock",
        elseif: false,
        start,
        end: -1,
        test: read_expression(parser),
        consequent: create_fragment(),
        alternate: null
      }
    );
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.stack.push(block2);
    parser.fragments.push(block2.consequent);
    return;
  }
  if (parser.eat("each")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("as", true);
    parser.require_whitespace();
    const context = read_context(parser);
    parser.allow_whitespace();
    let index;
    let key2;
    if (parser.eat(",")) {
      parser.allow_whitespace();
      index = parser.read_identifier();
      if (!index) {
        error(parser.index, "expected-identifier");
      }
      parser.allow_whitespace();
    }
    if (parser.eat("(")) {
      parser.allow_whitespace();
      key2 = read_expression(parser);
      parser.allow_whitespace();
      parser.eat(")", true);
      parser.allow_whitespace();
    }
    parser.eat("}", true);
    const block2 = parser.append(
      /** @type {Omit<import('#compiler').EachBlock, 'parent'>} */
      {
        type: "EachBlock",
        start,
        end: -1,
        expression,
        body: create_fragment(),
        context,
        index,
        key: key2,
        metadata: (
          /** @type {any} */
          null
        )
        // filled in later
      }
    );
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  if (parser.eat("await")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    const block2 = parser.append(
      /** @type {import('#compiler').AwaitBlock} */
      {
        type: "AwaitBlock",
        start,
        end: -1,
        expression,
        value: null,
        error: null,
        pending: null,
        then: null,
        catch: null
      }
    );
    if (parser.eat("then")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.value = read_context(parser);
        parser.allow_whitespace();
      }
      block2.then = create_fragment();
      parser.fragments.push(block2.then);
    } else if (parser.eat("catch")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.error = read_context(parser);
        parser.allow_whitespace();
      }
      block2.catch = create_fragment();
      parser.fragments.push(block2.catch);
    } else {
      block2.pending = create_fragment();
      parser.fragments.push(block2.pending);
    }
    parser.eat("}", true);
    parser.stack.push(block2);
    return;
  }
  if (parser.eat("key")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append(
      /** @type {import('#compiler').KeyBlock} */
      {
        type: "KeyBlock",
        start,
        end: -1,
        expression,
        fragment: create_fragment()
      }
    );
    parser.stack.push(block2);
    parser.fragments.push(block2.fragment);
    return;
  }
  error(parser.index, "expected-block-type");
}
function next(parser) {
  const start = parser.index - 1;
  const block2 = parser.current();
  if (block2.type === "IfBlock") {
    if (!parser.eat("else"))
      error(start, "expected-token", "else");
    if (parser.eat("if"))
      error(start, "invalid-elseif");
    parser.allow_whitespace();
    parser.fragments.pop();
    block2.alternate = create_fragment();
    parser.fragments.push(block2.alternate);
    if (parser.eat("if")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const child = parser.append(
        /** @type {import('#compiler').IfBlock} */
        {
          start: parser.index,
          end: -1,
          type: "IfBlock",
          elseif: true,
          test: expression,
          consequent: create_fragment(),
          alternate: null
        }
      );
      parser.stack.push(child);
      parser.fragments.pop();
      parser.fragments.push(child.consequent);
    } else {
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    return;
  }
  if (block2.type === "EachBlock") {
    if (!parser.eat("else"))
      error(start, "expected-token", "else");
    parser.allow_whitespace();
    parser.eat("}", true);
    block2.fallback = create_fragment();
    parser.fragments.pop();
    parser.fragments.push(block2.fallback);
    return;
  }
  if (block2.type === "AwaitBlock") {
    if (parser.eat("then")) {
      if (block2.then) {
        error(start, "TODO", "duplicate then");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.value = read_context(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.then = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.then);
      return;
    }
    if (parser.eat("catch")) {
      if (block2.catch) {
        error(start, "TODO", "duplicate catch");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.error = read_context(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.catch = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.catch);
      return;
    }
    error(start, "expected-token", "{:then ...} or {:catch ...}");
  }
}
function close(parser) {
  const start = parser.index - 1;
  let block2 = parser.current();
  switch (block2.type) {
    case "IfBlock":
      parser.eat("if", true);
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block2.elseif) {
        block2.end = parser.index;
        parser.stack.pop();
        block2 = /** @type {import('#compiler').IfBlock} */
        parser.current();
      }
      block2.end = parser.index;
      parser.pop();
      return;
    case "EachBlock":
      parser.eat("each", true);
      break;
    case "KeyBlock":
      parser.eat("key", true);
      break;
    case "AwaitBlock":
      parser.eat("await", true);
      break;
    case "RegularElement":
      error(start, "unexpected-block-close");
      break;
    default:
      error(start, "unexpected-block-close");
  }
  parser.allow_whitespace();
  parser.eat("}", true);
  block2.end = parser.index;
  parser.pop();
}
function special(parser) {
  let start = parser.index;
  while (parser.template[start] !== "{")
    start -= 1;
  if (parser.eat("html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append(
      /** @type {import('#compiler').HtmlTag} */
      {
        type: "HtmlTag",
        start,
        end: parser.index,
        expression
      }
    );
    return;
  }
  if (parser.eat("debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? (
        /** @type {import('estree').Identifier[]} */
        expression.expressions
      ) : [
        /** @type {import('estree').Identifier} */
        expression
      ];
      identifiers.forEach(
        /** @param {any} node */
        (node) => {
          if (node.type !== "Identifier") {
            error(
              /** @type {number} */
              node.start,
              "invalid-debug"
            );
          }
        }
      );
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.append(
      /** @type {import('#compiler').DebugTag} */
      {
        type: "DebugTag",
        start,
        end: parser.index,
        identifiers
      }
    );
    return;
  }
  if (parser.eat("const")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) {
      error(start, "invalid-const");
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append(
      /** @type {import('#compiler').ConstTag} */
      {
        type: "ConstTag",
        start,
        end: parser.index,
        expression
      }
    );
  }
}

// src/compiler/phases/1-parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data2 = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data2 += parser.template[parser.index++];
  }
  parser.append(
    /** @type {import('#compiler').Text} */
    {
      type: "Text",
      start,
      end: parser.index,
      raw: data2,
      data: decode_character_references(data2, false)
    }
  );
}

// src/compiler/phases/1-parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return tag;
  }
  if (parser.match("{")) {
    return mustache;
  }
  return text;
}

// src/compiler/phases/1-parse/read/options.js
var regex_valid_tag_name = /^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/;
function read_options(node) {
  const component_options = {};
  if (!node) {
    return component_options;
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      error(attribute, "invalid-svelte-option-attribute");
    }
    const { name } = attribute;
    switch (name) {
      case "runes": {
        const value = get_static_value(
          attribute,
          () => error(attribute, "invalid-svelte-option-runes")
        );
        if (typeof value !== "boolean") {
          error(attribute, "invalid-svelte-option-runes");
        }
        component_options.runes = value;
        break;
      }
      case "tag": {
        error(attribute, "tag-option-deprecated");
        break;
      }
      case "customElement": {
        const ce = { tag: "" };
        const { value } = attribute;
        if (value === true) {
          error(attribute, "invalid-svelte-option-customElement");
        } else if (value[0].type === "Text") {
          const tag3 = get_static_value(attribute, () => error(attribute, "invalid-tag-property"));
          validate_tag(attribute, tag3);
          ce.tag = tag3;
          component_options.customElement = ce;
          break;
        } else if (value[0].expression.type !== "ObjectExpression") {
          error(attribute, "invalid-svelte-option-customElement");
        }
        const properties = [];
        for (const property of value[0].expression.properties) {
          if (property.type !== "Property" || property.computed || property.key.type !== "Identifier") {
            error(attribute, "invalid-svelte-option-customElement");
          }
          properties.push([property.key.name, property.value]);
        }
        const tag2 = properties.find(([name2]) => name2 === "tag");
        if (tag2) {
          const tag_value = tag2[1]?.value;
          validate_tag(tag2, tag_value);
          ce.tag = tag_value;
        } else {
          error(attribute, "invalid-svelte-option-customElement");
        }
        const props = properties.find(([name2]) => name2 === "props")?.[1];
        if (props) {
          if (props.type !== "ObjectExpression") {
            error(attribute, "invalid-customElement-props-attribute");
          }
          ce.props = {};
          for (
            const property of
            /** @type {import('estree').ObjectExpression} */
            props.properties
          ) {
            if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
              error(attribute, "invalid-customElement-props-attribute");
            }
            ce.props[property.key.name] = {};
            for (const prop2 of property.value.properties) {
              if (prop2.type !== "Property" || prop2.computed || prop2.key.type !== "Identifier" || prop2.value.type !== "Literal") {
                error(attribute, "invalid-customElement-props-attribute");
              }
              if (prop2.key.name === "type") {
                if (["String", "Number", "Boolean", "Array", "Object"].indexOf(
                  /** @type {string} */
                  prop2.value.value
                ) === -1) {
                  error(attribute, "invalid-customElement-props-attribute");
                }
                ce.props[property.key.name].type = /** @type {any} */
                prop2.value.value;
              } else if (prop2.key.name === "reflect") {
                if (typeof prop2.value.value !== "boolean") {
                  error(attribute, "invalid-customElement-props-attribute");
                }
                ce.props[property.key.name].reflect = prop2.value.value;
              } else if (prop2.key.name === "attribute") {
                if (typeof prop2.value.value !== "string") {
                  error(attribute, "invalid-customElement-props-attribute");
                }
                ce.props[property.key.name].attribute = prop2.value.value;
              } else {
                error(attribute, "invalid-customElement-props-attribute");
              }
            }
          }
        }
        const shadow = properties.find(([name2]) => name2 === "shadow")?.[1];
        if (shadow) {
          const shadowdom = shadow?.value;
          if (shadowdom !== "open" && shadowdom !== "none") {
            error(shadow, "invalid-customElement-shadow-attribute");
          }
          ce.shadow = shadowdom;
        }
        const extend2 = properties.find(([name2]) => name2 === "extend")?.[1];
        if (extend2) {
          ce.extend = extend2;
        }
        component_options.customElement = ce;
        break;
      }
      case "namespace": {
        const value = get_static_value(
          attribute,
          () => error(attribute, "invalid-svelte-option-namespace")
        );
        if (typeof value !== "string") {
          error(attribute, "invalid-svelte-option-namespace");
        }
        if (value === "http://www.w3.org/2000/svg") {
          component_options.namespace = "svg";
        } else if (value === "html" || value === "svg" || value === "foreign") {
          component_options.namespace = value;
        } else {
          error(attribute, "invalid-svelte-option-namespace");
        }
        break;
      }
      case "immutable": {
        const value = get_static_value(
          attribute,
          () => error(attribute, "invalid-svelte-option-immutable")
        );
        if (typeof value !== "boolean") {
          error(attribute, "invalid-svelte-option-immutable");
        }
        component_options.immutable = value;
        break;
      }
      case "preserveWhitespace": {
        const value = get_static_value(
          attribute,
          () => error(attribute, "invalid-svelte-option-preserveWhitespace")
        );
        if (typeof value !== "boolean") {
          error(attribute, "invalid-svelte-option-preserveWhitespace");
        }
        component_options.preserveWhitespace = value;
        break;
      }
      case "accessors": {
        const value = get_static_value(
          attribute,
          () => error(attribute, "invalid-svelte-option-accessors")
        );
        if (typeof value !== "boolean") {
          error(attribute, "invalid-svelte-option-accessors");
        }
        component_options.accessors = value;
        break;
      }
      default:
        error(attribute, "unknown-svelte-option-attribute", name);
    }
  }
  return component_options;
}
function get_static_value(attribute, error2) {
  const { value } = attribute;
  const chunk = value[0];
  if (!chunk)
    return true;
  if (value.length > 1) {
    error2(attribute);
  }
  if (chunk.type === "Text")
    return chunk.data;
  if (chunk.expression.type !== "Literal") {
    error2(attribute);
  }
  return chunk.expression.value;
}
function validate_tag(attribute, tag2) {
  if (typeof tag2 !== "string" && tag2 !== null) {
    error(attribute, "invalid-tag-property");
  }
  if (tag2 && !regex_valid_tag_name.test(tag2)) {
    error(attribute, "invalid-tag-property");
  }
}

// src/compiler/phases/1-parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var Parser3 = class {
  /**
   * @readonly
   * @type {string}
   */
  template;
  /** */
  index = 0;
  /** @type {import('#compiler').TemplateNode[]} */
  stack = [];
  /** @type {import('#compiler').Fragment[]} */
  fragments = [];
  /** @type {import('#compiler').Root} */
  root;
  /** @type {Record<string, boolean>} */
  meta_tags = {};
  /** @type {LastAutoClosedTag | undefined} */
  last_auto_closed_tag;
  /** @param {string} template */
  constructor(template2) {
    if (typeof template2 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template2.trimRight();
    this.root = {
      css: null,
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: {}
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      if (current2.type === "RegularElement") {
        error(current2, "unclosed-element", current2.name);
      } else {
        error(current2, "unclosed-block");
      }
    }
    if (state !== fragment) {
      error(this.index, "unexpected-eof");
    }
    if (this.root.fragment.nodes.length) {
      let start = (
        /** @type {number} */
        this.root.fragment.nodes[0].start
      );
      while (regex_whitespace.test(template2[start]))
        start += 1;
      let end = (
        /** @type {number} */
        this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end
      );
      while (regex_whitespace.test(template2[end - 1]))
        end -= 1;
      this.root.start = start;
      this.root.end = end;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex(
      /** @param {any} thing */
      (thing) => thing.type === "SvelteOptions"
    );
    if (options_index !== -1) {
      const options = (
        /** @type {import('#compiler').SvelteOptions} */
        this.root.fragment.nodes[options_index]
      );
      this.root.fragment.nodes.splice(options_index, 1);
      this.root.options = read_options(options);
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   * @returns {never}
   */
  acorn_error(err) {
    error(err.pos, "js-parse-error", err.message.replace(regex_position_indicator, ""));
  }
  /**
   * @param {string} str
   * @param {boolean} [required]
   */
  eat(str, required) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required) {
      if (this.index === this.template.length) {
        error(this.index, "unexpected-eof");
      } else {
        error(this.index, "expected-token", str);
      }
    }
    return false;
  }
  /** @param {string} str */
  match(str) {
    return this.template.slice(this.index, this.index + str.length) === str;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0)
      return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result)
      this.index += result.length;
    return result;
  }
  /** @param {any} allow_reserved */
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code, true))
      return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code2, true))
        break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && reserved.includes(identifier)) {
      error(start, "unexpected-reserved-word", identifier);
    }
    return identifier;
  }
  /** @param {RegExp} pattern */
  read_until(pattern) {
    if (this.index >= this.template.length) {
      error(this.template.length, "unexpected-eof");
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      error(this.index, "missing-whitespace");
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  /**
   * @template T
   * @param {Omit<T, 'prev' | 'parent'>} node
   * @returns {T}
   */
  append(node) {
    const current2 = this.current();
    const fragment2 = this.fragments.at(-1);
    Object.defineProperties(node, {
      prev: {
        enumerable: false,
        value: fragment2?.nodes.at(-1) ?? null
      },
      parent: {
        enumerable: false,
        configurable: true,
        value: current2
      }
    });
    fragment2.nodes.push(node);
    return node;
  }
};
function parse6(template2) {
  const parser = new Parser3(template2);
  return parser.root;
}

// ../../node_modules/.pnpm/is-reference@3.0.1/node_modules/is-reference/src/index.js
function is_reference(node, parent) {
  if (node.type === "MemberExpression") {
    return !node.computed && is_reference(node.object, node);
  }
  if (node.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "PropertyDefinition":
        return parent.computed || node === parent.value;
      case "Property":
        return parent.computed || node === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}

// ../../node_modules/.pnpm/zimmerframe@1.1.0/node_modules/zimmerframe/src/walk.js
function walk(node, state, visitors) {
  const universal = visitors._;
  let stopped = false;
  function default_visitor(_, { next: next2, state: state2 }) {
    next2(state2);
  }
  function visit(node2, path, state2) {
    if (stopped)
      return node2;
    if (!node2.type)
      return node2;
    let result;
    const mutations = {};
    const context = {
      path,
      state: state2,
      next: (next_state = state2) => {
        path.push(node2);
        for (const key2 in node2) {
          if (key2 === "type")
            continue;
          const child_node = node2[key2];
          if (child_node && typeof child_node === "object") {
            if (Array.isArray(child_node)) {
              const array_mutations = {};
              child_node.forEach((node3, i) => {
                if (node3 && typeof node3 === "object") {
                  const result2 = visit(node3, path, next_state);
                  if (result2)
                    array_mutations[i] = result2;
                }
              });
              if (Object.keys(array_mutations).length > 0) {
                mutations[key2] = child_node.map(
                  (node3, i) => array_mutations[i] ?? node3
                );
              }
            } else {
              const result2 = visit(
                /** @type {T} */
                child_node,
                path,
                next_state
              );
              if (result2) {
                mutations[key2] = result2;
              }
            }
          }
        }
        path.pop();
        if (Object.keys(mutations).length > 0) {
          return { ...node2, ...mutations };
        }
      },
      stop: () => {
        stopped = true;
      },
      visit: (next_node, next_state = state2) => {
        path.push(node2);
        const result2 = visit(next_node, path, next_state) ?? next_node;
        path.pop();
        return result2;
      }
    };
    let visitor = (
      /** @type {import('./types').Visitor<T, U, T>} */
      visitors[
        /** @type {T['type']} */
        node2.type
      ] ?? default_visitor
    );
    if (universal) {
      let inner_result;
      result = universal(node2, {
        ...context,
        /** @param {U} next_state */
        next: (next_state = state2) => {
          state2 = next_state;
          inner_result = visitor(node2, {
            ...context,
            state: next_state
          });
          return inner_result;
        }
      });
      if (!result && inner_result) {
        result = inner_result;
      }
    } else {
      result = visitor(node2, context);
    }
    if (!result) {
      if (Object.keys(mutations).length > 0) {
        result = { ...node2, ...mutations };
      }
    }
    if (result) {
      return result;
    }
  }
  return visit(node, [], state) ?? node;
}

// src/compiler/utils/assert.js
function ok(value) {
  if (!value)
    error(null, "INTERNAL", "Assertion failed");
}
function equal(actual, expected) {
  if (actual !== expected)
    error(null, "INTERNAL", "Assertion failed");
}

// src/compiler/utils/builders.js
function array(elements2 = []) {
  return { type: "ArrayExpression", elements: elements2 };
}
function array_pattern(elements2) {
  return { type: "ArrayPattern", elements: elements2 };
}
function arrow(params, body) {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    expression: body.type !== "BlockStatement",
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function assignment(operator, left, right) {
  return { type: "AssignmentExpression", operator, left, right };
}
function binary(operator, left, right) {
  return { type: "BinaryExpression", operator, left, right };
}
function block(body) {
  return { type: "BlockStatement", body };
}
function labeled(name, body) {
  return { type: "LabeledStatement", label: id(name), body };
}
function call(callee, ...args) {
  if (typeof callee === "string")
    callee = id(callee);
  args = args.slice();
  while (args.length > 0 && !args.at(-1))
    args.pop();
  return {
    type: "CallExpression",
    callee,
    arguments: args,
    optional: false
  };
}
function maybe_call(callee, ...args) {
  const expression = (
    /** @type {import('estree').SimpleCallExpression} */
    call(callee, ...args)
  );
  expression.optional = true;
  return {
    type: "ChainExpression",
    expression
  };
}
function unary(operator, argument) {
  return { type: "UnaryExpression", argument, operator, prefix: true };
}
function conditional(test, consequent, alternate) {
  return { type: "ConditionalExpression", test, consequent, alternate };
}
function logical(operator, left, right) {
  return { type: "LogicalExpression", operator, left, right };
}
function declaration(kind, pattern, init2) {
  if (typeof pattern === "string")
    pattern = id(pattern);
  return {
    type: "VariableDeclaration",
    kind,
    declarations: [init2 ? declarator(pattern, init2) : declarator(pattern)]
  };
}
function declarator(id2, init2) {
  return { type: "VariableDeclarator", id: id2, init: init2 };
}
var empty2 = {
  type: "EmptyStatement"
};
function export_default(declaration2) {
  return { type: "ExportDefaultDeclaration", declaration: declaration2 };
}
function function_declaration(id2, params, body) {
  return {
    type: "FunctionDeclaration",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function get(name, body) {
  return prop("get", key(name), function_builder(null, [], block(body)));
}
function id(name) {
  return { type: "Identifier", name };
}
function import_namespace(local) {
  return {
    type: "ImportNamespaceSpecifier",
    local: id(local)
  };
}
function init(name, value) {
  return prop("init", key(name), value);
}
function literal2(value) {
  return { type: "Literal", value };
}
function member(object3, property, computed = false, optional = false) {
  return { type: "MemberExpression", object: object3, property, computed, optional };
}
function member_id(path) {
  const parts = path.split(".");
  let expression = id(parts[0]);
  for (let i = 1; i < parts.length; i += 1) {
    expression = member(expression, id(parts[i]));
  }
  return expression;
}
function object(properties) {
  return { type: "ObjectExpression", properties };
}
function object_pattern(properties) {
  return { type: "ObjectPattern", properties };
}
function prop(kind, key2, value, computed = false) {
  return { type: "Property", kind, key: key2, value, method: false, shorthand: false, computed };
}
function quasi(cooked, tail = false) {
  const raw = cooked.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
  return { type: "TemplateElement", value: { raw, cooked }, tail };
}
function rest(argument) {
  return { type: "RestElement", argument };
}
function sequence(expressions) {
  return { type: "SequenceExpression", expressions };
}
function set(name, body) {
  return prop("set", key(name), function_builder(null, [id("$$value")], block(body)));
}
function stmt(expression) {
  return { type: "ExpressionStatement", expression };
}
function template(elements2, expressions) {
  return { type: "TemplateLiteral", quasis: elements2, expressions };
}
function thunk(expression) {
  return arrow([], expression);
}
function update(operator, argument, prefix = false) {
  return { type: "UpdateExpression", operator, argument, prefix };
}
function do_while(test, body) {
  return { type: "DoWhileStatement", test, body };
}
var true_instance = literal2(true);
var false_instance = literal2(false);
var debugger_builder = {
  type: "DebuggerStatement"
};
var this_instance = {
  type: "ThisExpression"
};
function let_builder(pattern, init2) {
  return declaration("let", pattern, init2);
}
function const_builder(pattern, init2) {
  return declaration("const", pattern, init2);
}
function var_builder(pattern, init2) {
  return declaration("var", pattern, init2);
}
function for_builder(init2, test, update2, body) {
  return { type: "ForStatement", init: init2, test, update: update2, body };
}
function function_builder(id2, params, body) {
  return {
    type: "FunctionExpression",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function if_builder(test, consequent, alternate) {
  return { type: "IfStatement", test, consequent, alternate };
}
function import_all(as, source) {
  return {
    type: "ImportDeclaration",
    source: literal2(source),
    specifiers: [import_namespace(as)]
  };
}
function return_builder(argument = null) {
  return { type: "ReturnStatement", argument };
}
function key(name) {
  return regex_is_valid_identifier.test(name) ? id(name) : literal2(name);
}

// src/compiler/utils/ast.js
function object2(expression) {
  while (expression.type === "MemberExpression") {
    expression = /** @type {import('estree').MemberExpression | import('estree').Identifier} */
    expression.object;
  }
  if (expression.type !== "Identifier") {
    return null;
  }
  return expression;
}
function get_callee_name(node) {
  if (!node)
    return null;
  if (node.type !== "CallExpression")
    return null;
  if (node.callee.type !== "Identifier" && node.callee.type !== "MemberExpression")
    return null;
  const id2 = object2(node.callee);
  return id2 === null ? null : id2.name;
}
function is_text_attribute(attribute) {
  return attribute.value !== true && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
function extract_identifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          extract_identifiers(prop2.argument, nodes);
        } else {
          extract_identifiers(prop2.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      for (const element of param.elements) {
        if (element)
          extract_identifiers(element, nodes);
      }
      break;
    case "RestElement":
      extract_identifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extract_identifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function extract_identifiers_from_expression(node, nodes = []) {
  switch (node.type) {
    case "Identifier":
      nodes.push(node);
      break;
    case "ObjectExpression":
      for (const prop2 of node.properties) {
        if (prop2.type === "Property") {
          extract_identifiers_from_expression(
            /** @type {any} */
            prop2.value,
            nodes
          );
        } else {
          extract_identifiers_from_expression(
            /** @type {any} */
            prop2.argument,
            nodes
          );
        }
      }
      break;
    case "ArrayExpression":
      for (const element of node.elements) {
        if (element)
          extract_identifiers_from_expression(
            /** @type {any} */
            element,
            nodes
          );
      }
      break;
  }
  return nodes;
}
function extract_paths(param) {
  return _extract_paths(
    [],
    param,
    (node) => (
      /** @type {import('estree').Identifier | import('estree').MemberExpression} */
      node
    ),
    (node) => (
      /** @type {import('estree').Identifier | import('estree').MemberExpression} */
      node
    )
  );
}
function _extract_paths(assignments = [], param, expression, update_expression) {
  switch (param.type) {
    case "Identifier":
    case "MemberExpression":
      assignments.push({
        node: param,
        is_rest: false,
        expression,
        update_expression
      });
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          const rest_expression = (object3) => {
            const props = [];
            for (const p of param.properties) {
              if (p.type === "Property" && p.key.type !== "PrivateIdentifier") {
                if (p.key.type === "Identifier" && !p.computed) {
                  props.push(literal2(p.key.name));
                } else {
                  props.push(p.key);
                }
              }
            }
            return call("$.exclude_from_object", expression(object3), array(props));
          };
          if (prop2.argument.type === "Identifier") {
            assignments.push({
              node: prop2.argument,
              is_rest: true,
              expression: rest_expression,
              update_expression: rest_expression
            });
          } else {
            _extract_paths(assignments, prop2.argument, rest_expression, rest_expression);
          }
        } else {
          const object_expression = (object3) => member(expression(object3), prop2.key, prop2.computed || prop2.key.type !== "Identifier");
          _extract_paths(assignments, prop2.value, object_expression, object_expression);
        }
      }
      break;
    case "ArrayPattern":
      for (let i = 0; i < param.elements.length; i += 1) {
        const element = param.elements[i];
        if (element) {
          if (element.type === "RestElement") {
            const rest_expression = (object3) => call(member(expression(object3), id("slice")), literal2(i));
            if (element.argument.type === "Identifier") {
              assignments.push({
                node: element.argument,
                is_rest: true,
                expression: rest_expression,
                update_expression: rest_expression
              });
            } else {
              _extract_paths(assignments, element.argument, rest_expression, rest_expression);
            }
          } else {
            const array_expression = (object3) => member(expression(object3), literal2(i), true);
            _extract_paths(assignments, element, array_expression, array_expression);
          }
        }
      }
      break;
    case "AssignmentPattern": {
      const fallback_expression = (object3) => call("$.value_or_fallback", expression(object3), param.right);
      if (param.left.type === "Identifier") {
        assignments.push({
          node: param.left,
          is_rest: false,
          expression: fallback_expression,
          update_expression
        });
      } else {
        _extract_paths(assignments, param.left, fallback_expression, update_expression);
      }
      break;
    }
  }
  return assignments;
}

// src/compiler/phases/constants.js
var DOMBooleanAttributes = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var DOMProperties = [
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "inert",
  ...DOMBooleanAttributes
];
var AttributeAliases = {
  class: "className",
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly"
};
var VoidElements = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var DelegatedEvents = [
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  // 'input', This conflicts with bind:input
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
var PassiveEvents = ["wheel", "touchstart", "touchmove", "touchend", "touchcancel"];
var Runes = ["$state", "$props", "$derived", "$effect"];
var ReservedKeywords = ["$$props", "$$restProps", "$$slots"];
var WhitespaceInsensitiveAttributes = ["class", "style"];
var ContentEditableBindings = ["textContent", "innerHTML", "innerText"];

// src/compiler/phases/scope.js
var Scope3 = class _Scope {
  /** @type {ScopeRoot} */
  root;
  /**
   * The immediate parent scope
   * @type {Scope | null}
   */
  #parent;
  /**
   * Whether or not `var` declarations are contained by this scope
   * @type {boolean}
   */
  #porous;
  /**
   * A map of every identifier declared by this scope, and all the
   * identifiers that reference it
   * @type {Map<string, import('#compiler').Binding>}
   */
  declarations = /* @__PURE__ */ new Map();
  /**
   * A map of declarators to the bindings they declare
   * @type {Map<import('estree').VariableDeclarator | import('#compiler').LetDirective, import('#compiler').Binding[]>}
   */
  declarators = /* @__PURE__ */ new Map();
  /**
   * A set of all the names referenced with this scope
   * — useful for generating unique names
   * @type {Map<string, { node: import('estree').Identifier; path: import('#compiler').SvelteNode[] }[]>}
   */
  references = /* @__PURE__ */ new Map();
  /**
   *
   * @param {ScopeRoot} root
   * @param {Scope | null} parent
   * @param {boolean} porous
   */
  constructor(root, parent, porous) {
    this.root = root;
    this.#parent = parent;
    this.#porous = porous;
  }
  /**
   * @param {import('estree').Identifier} node
   * @param {import('#compiler').Binding['kind']} kind
   * @param {import('#compiler').DeclarationKind} declaration_kind
   * @param {null | import('estree').Expression | import('estree').FunctionDeclaration | import('estree').ClassDeclaration | import('estree').ImportDeclaration} initial
   * @returns {import('#compiler').Binding}
   */
  declare(node, kind, declaration_kind, initial = null) {
    if (node.name === "$") {
      error(node, "invalid-dollar-binding");
    }
    if (this.#parent) {
      if (declaration_kind === "var" && this.#porous) {
        return this.#parent.declare(node, kind, declaration_kind);
      }
      if (declaration_kind === "import") {
        return this.#parent.declare(node, kind, declaration_kind, initial);
      }
    }
    const binding = {
      node,
      references: [],
      legacy_dependencies: [],
      initial,
      mutated: false,
      scope: this,
      kind,
      declaration_kind,
      is_called: false,
      prop_alias: null,
      expression: null,
      mutation: null
    };
    this.declarations.set(node.name, binding);
    this.root.conflicts.add(node.name);
    return binding;
  }
  child(porous = false) {
    return new _Scope(this.root, this, porous);
  }
  /**
   * @param {string} preferred_name
   * @returns {string}
   */
  generate(preferred_name) {
    if (this.#porous) {
      return (
        /** @type {Scope} */
        this.#parent.generate(preferred_name)
      );
    }
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_");
    let name = preferred_name;
    let n2 = 1;
    while (this.references.has(name) || this.declarations.has(name) || this.root.conflicts.has(name)) {
      name = `${preferred_name}_${n2++}`;
    }
    this.references.set(name, []);
    this.root.conflicts.add(name);
    return name;
  }
  /**
   * @param {string} name
   * @returns {import('#compiler').Binding | null}
   */
  get(name) {
    return this.declarations.get(name) ?? this.#parent?.get(name) ?? null;
  }
  /**
   * @param {import('estree').VariableDeclarator | import('#compiler').LetDirective} node
   * @returns {import('#compiler').Binding[]}
   */
  get_bindings(node) {
    const bindings2 = this.declarators.get(node);
    if (!bindings2) {
      error(node, "INTERNAL", "No binding found for declarator");
    }
    return bindings2;
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  owner(name) {
    return this.declarations.has(name) ? this : this.#parent && this.#parent.owner(name);
  }
  /**
   * @param {import('estree').Identifier} node
   * @param {import('#compiler').SvelteNode[]} path
   */
  reference(node, path) {
    let references = this.references.get(node.name);
    if (!references)
      this.references.set(node.name, references = []);
    references.push({ node, path });
    const declaration2 = this.declarations.get(node.name);
    if (declaration2) {
      declaration2.references.push({ node, path });
    } else if (this.#parent) {
      this.#parent.reference(node, path);
    }
  }
};
var ScopeRoot = class {
  /** @type {Set<string>} */
  conflicts = /* @__PURE__ */ new Set();
  /**
   * @param {string} preferred_name
   */
  unique(preferred_name) {
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_");
    let final_name = preferred_name;
    let n2 = 1;
    while (this.conflicts.has(final_name)) {
      final_name = `${preferred_name}_${n2++}`;
    }
    this.conflicts.add(final_name);
    const id2 = id(final_name);
    return id2;
  }
};
function create_scopes(ast, root, allow_reactive_declarations, parent) {
  const scopes = /* @__PURE__ */ new Map();
  const scope = new Scope3(root, parent, false);
  scopes.set(ast, scope);
  const state = { scope };
  const references = [];
  const updates = [];
  const possible_implicit_declarations = [];
  function add_params(scope2, params) {
    for (const param of params) {
      for (const node of extract_identifiers(param)) {
        scope2.declare(node, "normal", "let");
      }
    }
  }
  const create_block_scope = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child(true);
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const SvelteFragment = (node, { state: state2, next: next2 }) => {
    const scope2 = analyze_let_directives(node, state2);
    if (scope2) {
      scopes.set(node, scope2);
      next2({ scope: scope2 });
    } else {
      next2();
    }
  };
  const CreateBlock = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child();
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  function analyze_let_directives(node, state2) {
    let scope2 = void 0;
    for (const attribute of node.attributes) {
      if (attribute.type !== "LetDirective")
        continue;
      if (!scope2) {
        scope2 = state2.scope.child();
      }
      const bindings2 = [];
      scope2.declarators.set(attribute, bindings2);
      scopes.set(attribute, scope2);
      if (attribute.expression) {
        for (const id2 of extract_identifiers_from_expression(attribute.expression)) {
          const binding = scope2.declare(id2, "derived", "const");
          bindings2.push(binding);
        }
      } else {
        const id2 = {
          name: attribute.name,
          type: "Identifier",
          start: attribute.start,
          end: attribute.end
        };
        const binding = scope2.declare(id2, "derived", "const");
        bindings2.push(binding);
      }
    }
    return scope2;
  }
  walk(ast, state, {
    // references
    Identifier(node, { path, state: state2 }) {
      const parent2 = path.at(-1);
      if (parent2 && is_reference(
        node,
        /** @type {import('estree').Node} */
        parent2
      )) {
        references.push([state2.scope, { node, path: path.slice() }]);
      }
    },
    LabeledStatement(node, { path, next: next2 }) {
      if (path.length > 1 || !allow_reactive_declarations)
        return next2();
      if (node.label.name !== "$")
        return next2();
      const scope2 = state.scope.child();
      scopes.set(node, scope2);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        for (const id2 of extract_identifiers(node.body.expression.left)) {
          if (!id2.name.startsWith("$")) {
            possible_implicit_declarations.push(id2);
          }
        }
      }
      next2({ scope: scope2 });
    },
    SvelteFragment,
    SvelteElement: SvelteFragment,
    RegularElement: SvelteFragment,
    Component(node, { state: state2, visit, path }) {
      state2.scope.reference(id(node.name), path);
      const scope2 = analyze_let_directives(node, state2);
      for (const attribute of node.attributes) {
        visit(attribute);
      }
      for (const child of node.fragment.nodes) {
        if (is_element_node(child) && child.attributes.some(
          (attribute) => attribute.type === "Attribute" && attribute.name === "slot"
        )) {
          visit(child);
        } else {
          if (scope2) {
            scopes.set(child, scope2);
            if (child.expression)
              scopes.set(child.expression, scope2);
            visit(child, { scope: scope2 });
          } else {
            visit(child);
          }
        }
      }
    },
    // updates
    AssignmentExpression(node, { state: state2, next: next2 }) {
      updates.push([state2.scope, node.left]);
      next2();
    },
    UpdateExpression(node, { state: state2, next: next2 }) {
      updates.push([
        state2.scope,
        /** @type {import('estree').Identifier | import('estree').MemberExpression} */
        node.argument
      ]);
      next2();
    },
    ImportDeclaration(node, { state: state2 }) {
      for (const specifier of node.specifiers) {
        state2.scope.declare(specifier.local, "normal", "import", node);
      }
    },
    FunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.id)
        scope2.declare(node.id, "normal", "function");
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    FunctionDeclaration(node, { state: state2, next: next2 }) {
      if (node.id)
        state2.scope.declare(node.id, "normal", "function", node);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ArrowFunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ForStatement: create_block_scope,
    ForInStatement: create_block_scope,
    ForOfStatement: create_block_scope,
    BlockStatement: create_block_scope,
    SwitchStatement: create_block_scope,
    ClassDeclaration(node, { state: state2, next: next2 }) {
      if (node.id)
        state2.scope.declare(node.id, "normal", "const");
      next2();
    },
    VariableDeclaration(node, { state: state2, next: next2 }) {
      for (const declarator2 of node.declarations) {
        const bindings2 = [];
        state2.scope.declarators.set(declarator2, bindings2);
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state2.scope.declare(id2, "normal", node.kind, declarator2.init);
          bindings2.push(binding);
        }
      }
      next2();
    },
    CatchClause(node, { state: state2, next: next2 }) {
      if (node.param) {
        const scope2 = state2.scope.child(true);
        scopes.set(node, scope2);
        for (const id2 of extract_identifiers(node.param)) {
          state2.scope.declare(id2, "normal", "let");
        }
        next2({ scope: scope2 });
      } else {
        next2();
      }
    },
    EachBlock(node, { state: state2, visit }) {
      const references_within = /* @__PURE__ */ new Set();
      const idx = references.length;
      visit(node.expression);
      for (let i = idx; i < references.length; i++) {
        const [scope3, { node: id2 }] = references[i];
        if (scope3 === state2.scope) {
          references_within.add(id2);
        }
      }
      scopes.set(node.expression, state2.scope);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      for (const id2 of extract_identifiers(node.context)) {
        scope2.declare(id2, "each", "const");
      }
      if (node.context.type !== "Identifier") {
        scope2.declare(id("$$item"), "derived", "const");
      }
      if (node.index) {
        scope2.declare(
          id(node.index),
          // TODO see logic in EachBlock in dom.ts
          node.key ? "derived" : "normal",
          "const"
        );
      }
      if (node.key)
        visit(node.key, { scope: scope2 });
      for (const child of node.body.nodes) {
        visit(child, { scope: scope2 });
      }
      if (node.fallback)
        visit(node.fallback, { scope: scope2 });
      let needs_array_deduplication = false;
      for (const [name] of scope2.declarations) {
        if (state2.scope.get(name) !== null) {
          needs_array_deduplication = true;
        }
      }
      node.metadata = {
        contains_group_binding: false,
        array_name: needs_array_deduplication ? state2.scope.root.unique("$$array") : null,
        index: scope2.root.unique("$$index"),
        item_name: node.context.type === "Identifier" ? node.context.name : "$$item",
        references: [...references_within].map((id2) => (
          /** @type {import('#compiler').Binding} */
          state2.scope.get(id2.name)
        )).filter(Boolean),
        is_controlled: false
      };
    },
    AwaitBlock(node, context) {
      context.next();
      if (node.then && node.value !== null) {
        const then_scope = (
          /** @type {Scope} */
          scopes.get(node.then)
        );
        const value_scope = context.state.scope.child();
        for (const id2 of extract_identifiers(node.value)) {
          then_scope.declare(id2, "normal", "const");
          value_scope.declare(id2, "normal", "const");
        }
        scopes.set(node.value, value_scope);
      }
      if (node.catch && node.error !== null) {
        const catch_scope = (
          /** @type {Scope} */
          scopes.get(node.catch)
        );
        const error_scope = context.state.scope.child();
        for (const id2 of extract_identifiers(node.error)) {
          catch_scope.declare(id2, "normal", "const");
          error_scope.declare(id2, "normal", "const");
        }
        scopes.set(node.error, error_scope);
      }
    },
    Fragment: (node, context) => {
      const scope2 = context.state.scope.child(node.transparent);
      scopes.set(node, scope2);
      context.next({ scope: scope2 });
    },
    // TODO this will be unnecessary when we switch to fragments
    IfBlock: CreateBlock,
    BindDirective(node, context) {
      updates.push([
        context.state.scope,
        /** @type {import('estree').Identifier | import('estree').MemberExpression} */
        node.expression
      ]);
      context.next();
    },
    ConstTag(node, { state: state2, next: next2 }) {
      for (const identifier of extract_identifiers(node.expression.left)) {
        state2.scope.declare(
          /** @type {import('estree').Identifier} */
          identifier,
          "derived",
          "const"
        );
      }
      next2();
    }
    // TODO others
  });
  for (const id2 of possible_implicit_declarations) {
    const binding = scope.get(id2.name);
    if (binding)
      continue;
    scope.declare(id2, "legacy_reactive", "let");
  }
  for (const [scope2, { node, path }] of references) {
    scope2.reference(node, path);
  }
  for (const [scope2, node] of updates) {
    if (node.type === "MemberExpression") {
      let object3 = node.object;
      while (object3.type === "MemberExpression") {
        object3 = object3.object;
      }
      const binding = scope2.get(
        /** @type {import('estree').Identifier} */
        object3.name
      );
      if (binding)
        binding.mutated = true;
    } else {
      extract_identifiers(node).forEach((identifier) => {
        const binding = scope2.get(identifier.name);
        if (binding)
          binding.mutated = true;
      });
    }
  }
  return {
    scope,
    scopes
  };
}
function set_scope(scopes) {
  return {
    /**
     *
     * @param {import('#compiler').SvelteNode} node
     * @param {import('zimmerframe').Context<import('#compiler').SvelteNode, State>} context
     */
    _(node, { next: next2, state }) {
      const scope = scopes.get(node);
      next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
    }
  };
}
function get_rune(node, scope) {
  const callee = get_callee_name(node);
  if (callee === null || !Runes.includes(callee))
    return null;
  const binding = scope.get(callee);
  if (binding !== null)
    return null;
  return callee;
}

// src/compiler/phases/visitors.js
var overrides = {
  visit() {
    throw new Error("Cannot call visit() during analysis");
  },
  stop() {
    throw new Error("Cannot call stop() during analysis");
  }
};
function merge(...tasks) {
  const visitors = {};
  for (const task of tasks) {
    for (const key2 in task) {
      if (!visitors[key2])
        visitors[key2] = [];
      visitors[key2].push(task[key2]);
    }
  }
  const combined = {};
  for (const key2 in visitors) {
    let visitor2 = function(node, context) {
      function go(i, state) {
        const fn = fns[i];
        if (!fn)
          return context.next(state);
        let called_next = false;
        fn(node, {
          ...context,
          ...overrides,
          state,
          next(next_state = state) {
            called_next = true;
            go(i + 1, next_state);
          }
        });
        if (!called_next) {
          go(i + 1, state);
        }
      }
      go(0, context.state);
    };
    var visitor = visitor2;
    const fns = visitors[key2];
    combined[key2] = visitor2;
  }
  return combined;
}

// ../../node_modules/.pnpm/magic-string@0.30.4/node_modules/magic-string/dist/magic-string.es.mjs
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str) => window.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa = /* @__PURE__ */ getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = (0, import_sourcemap_codec.encode)(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString2 = Object.prototype.toString;
function isObject(thing) {
  return toString2.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
        const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (this.hires === "boundary") {
          if (wordRegex.test(original[originalCharIndex])) {
            if (!charInHiresBoundary) {
              this.rawSegments.push(segment);
              charInHiresBoundary = true;
            }
          } else {
            this.rawSegments.push(segment);
            charInHiresBoundary = false;
          }
        } else {
          this.rawSegments.push(segment);
        }
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last;
    if (!first.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      this.overwrite(index, index + string.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// src/compiler/phases/2-analyze/css/gather_possible_values.js
var UNKNOWN = {};
function gather_possible_values(node, set2) {
  if (node.type === "Literal") {
    set2.add(String(node.value));
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, set2);
    gather_possible_values(node.alternate, set2);
  } else {
    set2.add(UNKNOWN);
  }
}
function get_possible_values(chunk) {
  const values = /* @__PURE__ */ new Set();
  if (chunk.type === "Text") {
    values.add(chunk.data);
  } else {
    gather_possible_values(chunk.expression, values);
  }
  if (values.has(UNKNOWN))
    return null;
  return values;
}

// src/compiler/phases/2-analyze/css/Selector.js
var NO_MATCH = "NO_MATCH";
var POSSIBLE_MATCH = "POSSIBLE_MATCH";
var UNKNOWN_SELECTOR = "UNKNOWN_SELECTOR";
var NodeExist = (
  /** @type {const} */
  {
    Probably: 0,
    Definitely: 1
  }
);
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", /* @__PURE__ */ new Set(["open"])],
  ["dialog", /* @__PURE__ */ new Set(["open"])]
]);
var regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
var Selector = class {
  /** @type {import('#compiler').Css.Selector} */
  node;
  /** @type {import('./Stylesheet.js').default} */
  stylesheet;
  /** @type {Block[]} */
  blocks;
  /** @type {Block[]} */
  local_blocks;
  /** @type {boolean} */
  used;
  /**
   * @param {import('#compiler').Css.Selector} node
   * @param {import('./Stylesheet.js').default} stylesheet
   */
  constructor(node, stylesheet) {
    this.node = node;
    this.stylesheet = stylesheet;
    this.blocks = group_selectors(node);
    let i = this.blocks.length;
    while (i > 0) {
      if (!this.blocks[i - 1].global)
        break;
      i -= 1;
    }
    this.local_blocks = this.blocks.slice(0, i);
    const host_only = this.blocks.length === 1 && this.blocks[0].host;
    const root_only = this.blocks.length === 1 && this.blocks[0].root;
    this.used = this.local_blocks.length === 0 || host_only || root_only;
  }
  /** @param {import('#compiler').RegularElement | import('#compiler').SvelteElement} node */
  apply(node) {
    const to_encapsulate = [];
    apply_selector(this.local_blocks.slice(), node, to_encapsulate);
    if (to_encapsulate.length > 0) {
      to_encapsulate.forEach(({ node: node2, block: block2 }) => {
        this.stylesheet.nodes_with_css_class.add(node2);
        block2.should_encapsulate = true;
      });
      this.used = true;
    }
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} attr
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, attr, max_amount_class_specificity_increased) {
    const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block2) => block2.should_encapsulate).length;
    function remove_global_pseudo_class(selector) {
      code.remove(selector.start, selector.start + ":global(".length).remove(selector.end - 1, selector.end);
    }
    function encapsulate_block(block2, attr2) {
      for (const selector of block2.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          remove_global_pseudo_class(selector);
        }
      }
      let i = block2.selectors.length;
      while (i--) {
        const selector = block2.selectors[i];
        if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
          if (selector.name !== "root" && selector.name !== "host") {
            if (i === 0)
              code.prependRight(selector.start, attr2);
          }
          continue;
        }
        if (selector.type === "TypeSelector" && selector.name === "*") {
          code.update(selector.start, selector.end, attr2);
        } else {
          code.appendLeft(selector.end, attr2);
        }
        break;
      }
    }
    this.blocks.forEach((block2, index) => {
      if (block2.global) {
        remove_global_pseudo_class(block2.selectors[0]);
      }
      if (block2.should_encapsulate)
        encapsulate_block(
          block2,
          index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr
        );
    });
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    let start = 0;
    let end = this.blocks.length;
    for (; start < end; start += 1) {
      if (!this.blocks[start].global)
        break;
    }
    for (; end > start; end -= 1) {
      if (!this.blocks[end - 1].global)
        break;
    }
    for (let i = start; i < end; i += 1) {
      if (this.blocks[i].global) {
        error(this.blocks[i].selectors[0], "invalid-css-global-placement");
      }
    }
    this.validate_global_with_multiple_selectors();
    this.validate_global_compound_selector();
    this.validate_invalid_combinator_without_selector(analysis);
  }
  validate_global_with_multiple_selectors() {
    if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) {
      return;
    }
    for (const block2 of this.blocks) {
      for (const selector of block2.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global" && selector.args !== null) {
          if (regex_is_single_css_selector.test(selector.args)) {
            error(selector, "invalid-css-global-selector");
          }
        }
      }
    }
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate_invalid_combinator_without_selector(analysis) {
    for (let i = 0; i < this.blocks.length; i++) {
      const block2 = this.blocks[i];
      if (block2.selectors.length === 0) {
        error(this.node, "invalid-css-selector");
      }
    }
  }
  validate_global_compound_selector() {
    for (const block2 of this.blocks) {
      for (const selector of block2.selectors) {
        if (selector.type === "PseudoClassSelector" && selector.name === "global" && block2.selectors.length !== 1) {
          error(selector, "invalid-css-global-selector-list");
        }
      }
    }
  }
  get_amount_class_specificity_increased() {
    let count = 0;
    for (const block2 of this.blocks) {
      if (block2.should_encapsulate) {
        count++;
      }
    }
    return count;
  }
};
function apply_selector(blocks, node, to_encapsulate) {
  const block2 = blocks.pop();
  if (!block2)
    return false;
  if (!node) {
    return block2.global && blocks.every((block3) => block3.global) || block2.host && blocks.length === 0;
  }
  const applies = block_might_apply_to_node(block2, node);
  if (applies === NO_MATCH) {
    return false;
  }
  if (applies === UNKNOWN_SELECTOR) {
    to_encapsulate.push({ node, block: block2 });
    return true;
  }
  if (block2.combinator) {
    if (block2.combinator.type === "Combinator" && block2.combinator.name === " ") {
      for (const ancestor_block of blocks) {
        if (ancestor_block.global) {
          continue;
        }
        if (ancestor_block.host) {
          to_encapsulate.push({ node, block: block2 });
          return true;
        }
        let parent = node;
        while (parent = get_element_parent(parent)) {
          if (block_might_apply_to_node(ancestor_block, parent) !== NO_MATCH) {
            to_encapsulate.push({ node: parent, block: ancestor_block });
          }
        }
        if (to_encapsulate.length) {
          to_encapsulate.push({ node, block: block2 });
          return true;
        }
      }
      if (blocks.every((block3) => block3.global)) {
        to_encapsulate.push({ node, block: block2 });
        return true;
      }
      return false;
    } else if (block2.combinator.name === ">") {
      const has_global_parent = blocks.every((block3) => block3.global);
      if (has_global_parent || apply_selector(blocks, get_element_parent(node), to_encapsulate)) {
        to_encapsulate.push({ node, block: block2 });
        return true;
      }
      return false;
    } else if (block2.combinator.name === "+" || block2.combinator.name === "~") {
      const siblings = get_possible_element_siblings(node, block2.combinator.name === "+");
      let has_match = false;
      const has_global = blocks.some((block3) => block3.global);
      if (has_global) {
        if (siblings.size === 0 && get_element_parent(node) !== null) {
          return false;
        }
        to_encapsulate.push({ node, block: block2 });
        return true;
      }
      for (const possible_sibling of siblings.keys()) {
        if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
          to_encapsulate.push({ node, block: block2 });
          has_match = true;
        }
      }
      return has_match;
    }
    to_encapsulate.push({ node, block: block2 });
    return true;
  }
  to_encapsulate.push({ node, block: block2 });
  return true;
}
var regex_backslash_and_following_character = /\\(.)/g;
function block_might_apply_to_node(block2, node) {
  if (block2.host || block2.root)
    return NO_MATCH;
  let i = block2.selectors.length;
  while (i--) {
    const selector = block2.selectors[i];
    if (selector.type === "Percentage")
      continue;
    const name = selector.name.replace(regex_backslash_and_following_character, "$1");
    if (selector.type === "PseudoClassSelector" && (name === "host" || name === "root")) {
      return NO_MATCH;
    }
    if (block2.selectors.length === 1 && selector.type === "PseudoClassSelector" && name === "global") {
      return NO_MATCH;
    }
    if (selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector") {
      continue;
    }
    if (selector.type === "AttributeSelector") {
      const whitelisted = whitelist_attribute_selector.get(node.name.toLowerCase());
      if (!whitelisted?.has(selector.name.toLowerCase()) && !attribute_matches(
        node,
        selector.name,
        selector.value && unquote(selector.value),
        selector.matcher,
        selector.flags?.includes("i") ?? false
      )) {
        return NO_MATCH;
      }
    } else {
      if (selector.type === "ClassSelector") {
        if (!attribute_matches(node, "class", name, "~=", false) && !node.attributes.some(
          (attribute) => attribute.type === "ClassDirective" && attribute.name === name
        )) {
          return NO_MATCH;
        }
      } else if (selector.type === "IdSelector") {
        if (!attribute_matches(node, "id", name, "=", false))
          return NO_MATCH;
      } else if (selector.type === "TypeSelector") {
        if (node.name.toLowerCase() !== name.toLowerCase() && name !== "*" && node.type !== "SvelteElement") {
          return NO_MATCH;
        }
      } else {
        return UNKNOWN_SELECTOR;
      }
    }
  }
  return POSSIBLE_MATCH;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name, expected_value, operator, case_insensitive) {
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute")
      return true;
    if (attribute.type === "BindDirective" && attribute.name === name)
      return true;
    if (attribute.type !== "Attribute")
      continue;
    if (attribute.name.toLowerCase() !== name.toLowerCase())
      continue;
    if (attribute.value === true)
      return operator === null;
    if (expected_value === null)
      return true;
    const chunks = attribute.value;
    if (chunks.length === 1) {
      const value = chunks[0];
      if (value.type === "Text") {
        return test_attribute(operator, expected_value, case_insensitive, value.data);
      }
    }
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of chunks) {
      const current_possible_values = get_possible_values(chunk);
      if (!current_possible_values)
        return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value)) {
            start_with_space.push(current_possible_value);
          } else {
            remaining.push(current_possible_value);
          }
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0) {
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          }
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value) => {
              combined.push(prev_value + value);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value) => {
            if (regex_ends_with_whitespace.test(value)) {
              possible_values.add(value);
            } else {
              prev_values.push(value);
            }
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value)) {
          possible_values.add(current_possible_value);
        } else {
          prev_values.push(current_possible_value);
        }
      });
      if (prev_values.length < current_possible_values.size) {
        prev_values.push(" ");
      }
      if (prev_values.length > 20) {
        return true;
      }
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    for (const value of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value))
        return true;
    }
  }
  return false;
}
function unquote(str) {
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_element_parent(node) {
  let parent = node;
  while (
    // @ts-expect-error TODO figure out a more elegant solution
    (parent = parent.parent) && parent.type !== "RegularElement" && parent.type !== "SvelteElement"
  )
    ;
  return parent ?? null;
}
function find_previous_sibling(node) {
  let current_node = node;
  do {
    if (current_node.type === "SlotElement") {
      const slot_children = current_node.fragment.nodes;
      if (slot_children.length > 0) {
        current_node = slot_children.slice(-1)[0];
        continue;
      }
    }
    while (
      // @ts-expect-error TODO
      !current_node.prev && // @ts-expect-error TODO
      current_node.parent && // @ts-expect-error TODO
      current_node.parent.type === "SlotElement"
    ) {
      current_node = current_node.parent;
    }
    current_node = current_node.prev;
  } while (current_node && current_node.type === "SlotElement");
  return current_node;
}
function get_possible_element_siblings(node, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  let prev = node;
  while (prev = find_previous_sibling(prev)) {
    if (prev.type === "RegularElement") {
      if (!prev.attributes.find(
        (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
      )) {
        result.set(prev, NodeExist.Definitely);
      }
      if (adjacent_only) {
        break;
      }
    } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
      const possible_last_child = get_possible_last_child(prev, adjacent_only);
      add_to_map(possible_last_child, result);
      if (adjacent_only && has_definite_elements(possible_last_child)) {
        return result;
      }
    }
  }
  if (!prev || !adjacent_only) {
    let parent = node;
    while (
      // @ts-expect-error TODO
      (parent = parent?.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "AwaitBlock")
    ) {
      const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
      add_to_map(possible_siblings, result);
      if (parent.type === "EachBlock" && !parent.fallback?.nodes.includes(node)) {
        add_to_map(get_possible_last_child(parent, adjacent_only), result);
      }
      if (adjacent_only && has_definite_elements(possible_siblings)) {
        break;
      }
    }
  }
  return result;
}
function get_possible_last_child(block2, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  if (block2.type === "EachBlock") {
    const each_result = loop_child(block2.body.nodes, adjacent_only);
    const else_result = block2.fallback ? loop_child(block2.fallback.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(each_result);
      mark_as_probably(else_result);
    }
    add_to_map(each_result, result);
    add_to_map(else_result, result);
  } else if (block2.type === "IfBlock") {
    const if_result = loop_child(block2.consequent.nodes, adjacent_only);
    const else_result = block2.alternate ? loop_child(block2.alternate.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
    if (not_exhaustive) {
      mark_as_probably(if_result);
      mark_as_probably(else_result);
    }
    add_to_map(if_result, result);
    add_to_map(else_result, result);
  } else if (block2.type === "AwaitBlock") {
    const pending_result = block2.pending ? loop_child(block2.pending.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const then_result = block2.then ? loop_child(block2.then.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const catch_result = block2.catch ? loop_child(block2.catch.nodes, adjacent_only) : /* @__PURE__ */ new Map();
    const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
    if (not_exhaustive) {
      mark_as_probably(pending_result);
      mark_as_probably(then_result);
      mark_as_probably(catch_result);
    }
    add_to_map(pending_result, result);
    add_to_map(then_result, result);
    add_to_map(catch_result, result);
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0)
    return false;
  for (const exist of result.values()) {
    if (exist === NodeExist.Definitely) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element) => {
    to.set(element, higher_existence(exist, to.get(element)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist1 === void 0 || exist2 === void 0)
    return exist1 || exist2;
  return exist1 > exist2 ? exist1 : exist2;
}
function mark_as_probably(result) {
  for (const key2 of result.keys()) {
    result.set(key2, NodeExist.Probably);
  }
}
function loop_child(children, adjacent_only) {
  const result = /* @__PURE__ */ new Map();
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (child.type === "RegularElement") {
      result.set(child, NodeExist.Definitely);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
      const child_result = get_possible_last_child(child, adjacent_only);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
  }
  return result;
}
var Block = class {
  /** @type {boolean} */
  host;
  /** @type {boolean} */
  root;
  /** @type {import('#compiler').Css.Combinator | null} */
  combinator;
  /** @type {import('#compiler').Css.SimpleSelector[]} */
  selectors;
  /** @type {number} */
  start;
  /** @type {number} */
  end;
  /** @type {boolean} */
  should_encapsulate;
  /** @param {import('#compiler').Css.Combinator | null} combinator */
  constructor(combinator) {
    this.combinator = combinator;
    this.host = false;
    this.root = false;
    this.selectors = [];
    this.start = -1;
    this.end = -1;
    this.should_encapsulate = false;
  }
  /** @param {import('#compiler').Css.SimpleSelector} selector */
  add(selector) {
    if (this.selectors.length === 0) {
      this.start = selector.start;
      this.host = selector.type === "PseudoClassSelector" && selector.name === "host";
    }
    this.root = this.root || selector.type === "PseudoClassSelector" && selector.name === "root";
    this.selectors.push(selector);
    this.end = selector.end;
  }
  get global() {
    return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every(
      (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
    );
  }
};
function group_selectors(selector) {
  let block2 = new Block(null);
  const blocks = [block2];
  selector.children.forEach((child) => {
    if (child.type === "Combinator") {
      block2 = new Block(child);
      blocks.push(block2);
    } else {
      block2.add(child);
    }
  });
  return blocks;
}

// src/compiler/phases/2-analyze/utils/hash.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}

// src/compiler/phases/2-analyze/utils/push_array.js
function push_array(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// src/compiler/phases/2-analyze/css/Stylesheet.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
function remove_css_prefix(name) {
  return name.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";
function escape_comment_close(node, code) {
  let escaped = false;
  let in_comment = false;
  for (let i = node.start; i < node.end; i++) {
    if (escaped) {
      escaped = false;
    } else {
      const char = code.original[i];
      if (in_comment) {
        if (char === "*" && code.original[i + 1] === "/") {
          code.prependRight(++i, "\\");
          in_comment = false;
        }
      } else if (char === "\\") {
        escaped = true;
      } else if (char === "/" && code.original[++i] === "*") {
        in_comment = true;
      }
    }
  }
}
var Rule = class {
  /** @type {import('./Selector.js').default[]} */
  selectors;
  /** @type {Declaration[]} */
  declarations;
  /** @type {import('#compiler').Css.Rule} */
  node;
  /** @type {Atrule | undefined} */
  parent;
  /**
   * @param {import('#compiler').Css.Rule} node
   * @param {any} stylesheet
   * @param {Atrule | undefined} parent
   */
  constructor(node, stylesheet, parent) {
    this.node = node;
    this.parent = parent;
    this.selectors = node.prelude.children.map((node2) => new Selector(node2, stylesheet));
    this.declarations = /** @type {import('#compiler').Css.Declaration[]} */
    node.block.children.map((node2) => new Declaration(node2));
  }
  /** @param {import('#compiler').RegularElement | import('#compiler').SvelteElement} node */
  apply(node) {
    this.selectors.forEach((selector) => selector.apply(node));
  }
  /** @param {boolean} dev */
  is_used(dev) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
      return true;
    if (this.declarations.length === 0)
      return dev;
    return this.selectors.some((s) => s.used);
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, id2, keyframes, max_amount_class_specificity_increased) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) {
      return;
    }
    const attr = `.${id2}`;
    this.selectors.forEach(
      (selector) => selector.transform(code, attr, max_amount_class_specificity_increased)
    );
    this.declarations.forEach((declaration2) => declaration2.transform(code, keyframes));
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    this.selectors.forEach((selector) => {
      selector.validate(analysis);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    this.selectors.forEach((selector) => {
      if (!selector.used)
        handler(selector);
    });
  }
  /** @returns number */
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.selectors.map((selector) => selector.get_amount_class_specificity_increased())
    );
  }
  /**
   * @param {MagicString} code
   * @param {boolean} dev
   */
  prune(code, dev) {
    if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) {
      return;
    }
    if (this.declarations.length === 0) {
      if (!dev) {
        code.prependRight(this.node.start, "/* (empty) ");
        code.appendLeft(this.node.end, "*/");
        escape_comment_close(this.node, code);
      }
      return;
    }
    const used = this.selectors.filter((s) => s.used);
    if (used.length === 0) {
      code.prependRight(this.node.start, "/* (unused) ");
      code.appendLeft(this.node.end, "*/");
      escape_comment_close(this.node, code);
      return;
    }
    if (used.length < this.selectors.length) {
      let pruning = false;
      let last = this.selectors[0].node.start;
      for (let i = 0; i < this.selectors.length; i += 1) {
        const selector = this.selectors[i];
        if (selector.used === pruning) {
          if (pruning) {
            let i2 = selector.node.start;
            while (code.original[i2] !== ",")
              i2--;
            code.overwrite(i2, i2 + 1, "*/");
          } else {
            if (i === 0) {
              code.prependRight(selector.node.start, "/* (unused) ");
            } else {
              code.overwrite(last, selector.node.start, " /* (unused) ");
            }
          }
          pruning = !pruning;
        }
        last = selector.node.end;
      }
      if (pruning) {
        code.appendLeft(last, "*/");
      }
    }
  }
};
var Declaration = class {
  /** @type {import('#compiler').Css.Declaration} */
  node;
  /** @param {import('#compiler').Css.Declaration} node */
  constructor(node) {
    this.node = node;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {Map<string, string>} keyframes
   */
  transform(code, keyframes) {
    const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      const name = (
        /** @type {string} */
        this.node.value.split(" ").find((name2) => keyframes.has(name2))
      );
      if (name) {
        const start = code.original.indexOf(
          name,
          code.original.indexOf(this.node.property, this.node.start)
        );
        const end = start + name.length;
        const keyframe = (
          /** @type {string} */
          keyframes.get(name)
        );
        code.update(start, end, keyframe);
      }
    }
  }
};
var Atrule = class {
  /** @type {import('#compiler').Css.Atrule} */
  node;
  /** @type {Array<Atrule | Rule>} */
  children;
  /** @type {Declaration[]} */
  declarations;
  /** @param {import('#compiler').Css.Atrule} node */
  constructor(node) {
    this.node = node;
    this.children = [];
    this.declarations = [];
  }
  /** @param {import('#compiler').RegularElement | import('#compiler').SvelteElement} node */
  apply(node) {
    if (this.node.name === "container" || this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer") {
      this.children.forEach((child) => {
        child.apply(node);
      });
    } else if (is_keyframes_node(this.node)) {
      this.children.forEach((rule) => {
        rule.selectors.forEach((selector) => {
          selector.used = true;
        });
      });
    }
  }
  /** @param {boolean} _dev */
  is_used(_dev) {
    return true;
  }
  /**
   * @param {import('magic-string').default} code
   * @param {string} id
   * @param {Map<string, string>} keyframes
   * @param {number} max_amount_class_specificity_increased
   */
  transform(code, id2, keyframes, max_amount_class_specificity_increased) {
    if (is_keyframes_node(this.node)) {
      let start = this.node.start + this.node.name.length + 1;
      while (code.original[start] === " ")
        start += 1;
      let end = start;
      while (code.original[end] !== "{" && code.original[end] !== " ")
        end += 1;
      if (this.node.prelude.startsWith("-global-")) {
        code.remove(start, start + 8);
        this.children.forEach((rule) => {
          rule.selectors.forEach((selector) => {
            selector.used = true;
          });
        });
      } else {
        const keyframe = (
          /** @type {string} */
          keyframes.get(this.node.prelude)
        );
        code.update(start, end, keyframe);
      }
    }
    this.children.forEach((child) => {
      child.transform(code, id2, keyframes, max_amount_class_specificity_increased);
    });
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    this.children.forEach((child) => {
      child.validate(analysis);
    });
  }
  /** @param {(selector: import('./Selector.js').default) => void} handler */
  warn_on_unused_selector(handler) {
    if (this.node.name !== "media")
      return;
    this.children.forEach((child) => {
      child.warn_on_unused_selector(handler);
    });
  }
  /** @returns {number} */
  get_max_amount_class_specificity_increased() {
    return Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
  }
  /**
   * @param {MagicString} code
   * @param {boolean} dev
   */
  prune(code, dev) {
  }
};
var get_default_css_hash = ({ css: css3, hash: hash2 }) => {
  return `svelte-${hash2(css3)}`;
};
var Stylesheet = class {
  /** @type {import('#compiler').Style | null} */
  ast;
  /** @type {string} */
  filename;
  /** @type {boolean} */
  has_styles;
  /** @type {string} */
  id;
  /** @type {Array<Rule | Atrule>} */
  children = [];
  /** @type {Map<string, string>} */
  keyframes = /* @__PURE__ */ new Map();
  /** @type {Set<import('#compiler').RegularElement | import('#compiler').SvelteElement>} */
  nodes_with_css_class = /* @__PURE__ */ new Set();
  /**
   * @param {{
   * 		ast: import('#compiler').Style | null;
   * 		filename: string;
   * 		component_name: string;
   * 		get_css_hash?: import('#compiler').CssHashGetter;
   * 	}} params
   */
  constructor({ ast, component_name, filename, get_css_hash = get_default_css_hash }) {
    this.ast = ast;
    this.filename = filename;
    if (!ast || ast.children.length === 0) {
      this.has_styles = false;
      this.id = "";
      return;
    }
    this.id = get_css_hash({
      filename,
      name: component_name,
      css: ast.content.styles,
      hash
    });
    this.has_styles = true;
    const state = {
      /** @type {Atrule | undefined} */
      atrule: void 0
    };
    walk(
      /** @type {import('#compiler').Css.Node} */
      ast,
      state,
      {
        Atrule: (node, context) => {
          const atrule = new Atrule(node);
          if (context.state.atrule) {
            context.state.atrule.children.push(atrule);
          } else {
            this.children.push(atrule);
          }
          if (is_keyframes_node(node)) {
            if (!node.prelude.startsWith("-global-")) {
              this.keyframes.set(node.prelude, `${this.id}-${node.prelude}`);
            }
          } else if (node.block) {
            const declarations = [];
            for (const child of node.block.children) {
              if (child.type === "Declaration") {
                declarations.push(new Declaration(child));
              }
            }
            if (declarations.length > 0) {
              push_array(atrule.declarations, declarations);
            }
          }
          context.next({
            ...context.state,
            atrule
          });
        },
        Rule: (node, context) => {
          const rule = new Rule(node, this, context.state.atrule);
          if (context.state.atrule) {
            context.state.atrule.children.push(rule);
          } else {
            this.children.push(rule);
          }
          context.next();
        }
      }
    );
  }
  /** @param {import('#compiler').RegularElement | import('#compiler').SvelteElement} node */
  apply(node) {
    if (!this.has_styles)
      return;
    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.children[i];
      child.apply(node);
    }
  }
  /** @param {boolean} is_dom_mode */
  reify(is_dom_mode) {
    nodes:
      for (const node of this.nodes_with_css_class) {
        if (node.type === "SvelteElement" && is_dom_mode)
          continue;
        let class_attribute = void 0;
        for (const attribute of node.attributes) {
          if (attribute.type === "SpreadAttribute") {
            continue nodes;
          }
          if (attribute.type !== "Attribute")
            continue;
          if (attribute.name.toLowerCase() !== "class")
            continue;
          class_attribute = attribute;
        }
        if (class_attribute && class_attribute.value !== true) {
          const chunks = class_attribute.value;
          if (chunks.length === 1 && chunks[0].type === "Text") {
            chunks[0].data += ` ${this.id}`;
          } else {
            chunks.push({
              type: "Text",
              data: ` ${this.id}`,
              raw: ` ${this.id}`,
              parent: null
            });
          }
        } else {
          node.attributes.push(
            create_attribute("class", void 0, void 0, [
              { type: "Text", data: this.id, raw: this.id, parent: null }
            ])
          );
        }
      }
  }
  /**
   * @param {string} file
   * @param {string} source
   * @param {boolean} dev
   */
  render(file, source, dev) {
    if (!this.ast)
      throw new Error("Unexpected error");
    const code = new MagicString(source);
    walk(
      /** @type {import('#compiler').Css.Node} */
      this.ast,
      null,
      {
        _: (node) => {
          if (node.start !== void 0 && node.end !== void 0) {
            code.addSourcemapLocation(node.start);
            code.addSourcemapLocation(node.end);
          }
        }
      }
    );
    const max = Math.max(
      ...this.children.map((rule) => rule.get_max_amount_class_specificity_increased())
    );
    for (const child of this.children) {
      child.transform(code, this.id, this.keyframes, max);
    }
    code.remove(
      0,
      /** @type {number} */
      this.ast.start
    );
    code.prependRight(
      /** @type {number} */
      this.ast.start,
      "/*"
    );
    code.appendLeft(
      /** @type {number} */
      this.ast.content.start,
      "*/"
    );
    for (const child of this.children) {
      child.prune(code, dev);
    }
    code.prependRight(this.ast.content.end, "/*");
    code.appendLeft(
      /** @type {number} */
      this.ast.end,
      "*/"
    );
    code.remove(
      /** @type {number} */
      this.ast.end,
      source.length
    );
    return {
      code: code.toString(),
      map: code.generateMap({
        includeContent: true,
        source: this.filename,
        file
      })
    };
  }
  /** @param {import('../../types.js').Analysis} analysis */
  validate(analysis) {
    this.children.forEach((child) => {
      child.validate(analysis);
    });
  }
  /** @param {import('../../types.js').Analysis} analysis */
  warn_on_unused_selectors(analysis) {
  }
};

// src/compiler/warnings.js
var css2 = {
  "unused-selector": () => "Unused CSS selector"
};
var attributes2 = {
  "avoid-is": () => 'The "is" attribute is not supported cross-browser and should be avoided'
};
var runes2 = {
  /** @param {string} name */
  "store-with-rune-name": (name) => `It looks like you're using the $${name} rune, but there is a local binding called ${name}. Referencing a local variable with a $ prefix will create a store subscription. Please rename ${name} to avoid the ambiguity.`
};
var a11y = {
  /** @param {string} name */
  "a11y-aria-attributes": (name) => `A11y: <${name}> should not have aria-* attributes`,
  /**
   * @param {string} attribute
   * @param {string | null} [suggestion]
   */
  "a11y-unknown-aria-attribute": (attribute, suggestion) => `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : ""),
  /** @param {string} name */
  "a11y-hidden": (name) => `A11y: <${name}> element should not be hidden`,
  /**
   * @param {import('aria-query').ARIAPropertyDefinition} schema
   * @param {string} attribute
   */
  "a11y-incorrect-aria-attribute-type": (schema, attribute) => {
    let message;
    switch (schema.type) {
      case "boolean":
        message = `The value of '${attribute}' must be exactly one of true or false`;
        break;
      case "id":
        message = `The value of '${attribute}' must be a string that represents a DOM element ID`;
        break;
      case "idlist":
        message = `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`;
        break;
      case "tristate":
        message = `The value of '${attribute}' must be exactly one of true, false, or mixed`;
        break;
      case "token":
        message = `The value of '${attribute}' must be exactly one of ${(schema.values || []).join(
          ", "
        )}`;
        break;
      case "tokenlist":
        message = `The value of '${attribute}' must be a space-separated list of one or more of ${(schema.values || []).join(", ")}`;
        break;
      default:
        message = `The value of '${attribute}' must be of type ${schema.type}`;
    }
    return `A11y: ${message}`;
  },
  "a11y-aria-activedescendant-has-tabindex": () => "A11y: Elements with attribute aria-activedescendant should have tabindex value",
  /** @param {string} name */
  "a11y-misplaced-role": (name) => `A11y: <${name}> should not have role attribute`,
  /** @param {string | boolean} role */
  "a11y-no-abstract-role": (role) => `A11y: Abstract role '${role}' is forbidden`,
  /**
   * @param {string | boolean} role
   * @param {string | null} [suggestion]
   */
  "a11y-unknown-role": (role, suggestion) => `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : ""),
  /** @param {string | boolean} role */
  "a11y-no-redundant-roles": (role) => `A11y: Redundant role '${role}'`,
  /**
   * @param {string} role
   * @param {string[]} props
   */
  "a11y-role-has-required-aria-props": (role, props) => `A11y: Elements with the ARIA role "${role}" must have the following attributes defined: ${props.map((name) => `"${name}"`).join(", ")}`,
  /** @param {string} role */
  "a11y-interactive-supports-focus": (role) => `A11y: Elements with the '${role}' interactive role must have a tabindex value.`,
  /**
   * @param {string | boolean} role
   * @param {string} element
   */
  "a11y-no-interactive-element-to-noninteractive-role": (role, element) => `A11y: <${element}> cannot have role '${role}'`,
  /**
   * @param {string | boolean} role
   * @param {string} element
   */
  "a11y-no-noninteractive-element-to-interactive-role": (role, element) => `A11y: Non-interactive element <${element}> cannot have interactive role '${role}'`,
  "a11y-accesskey": () => "A11y: Avoid using accesskey",
  "a11y-autofocus": () => "A11y: Avoid using autofocus",
  "a11y-misplaced-scope": () => "A11y: The scope attribute should only be used with <th> elements",
  "a11y-positive-tabindex": () => "A11y: avoid tabindex values above zero",
  "a11y-click-events-have-key-events": () => "A11y: visible, non-interactive elements with an on:click event must be accompanied by an on:keydown, on:keyup, or on:keypress event.",
  "a11y-no-noninteractive-tabindex": () => "A11y: noninteractive element cannot have nonnegative tabIndex value",
  /**
   * @param {string} attribute
   * @param {string} role
   * @param {boolean} is_implicit
   * @param {string} name
   */
  "a11y-role-supports-aria-props": (attribute, role, is_implicit, name) => {
    let message = `The attribute '${attribute}' is not supported by the role '${role}'.`;
    if (is_implicit) {
      message += ` This role is implicit on the element <${name}>.`;
    }
    return `A11y: ${message}`;
  },
  /** @param {string} element */
  "a11y-no-noninteractive-element-interactions": (element) => `A11y: Non-interactive element <${element}> should not be assigned mouse or keyboard event listeners.`,
  /**
   * @param {string} element
   * @param {string[]} handlers
   */
  "a11y-no-static-element-interactions": (element, handlers2) => `A11y: <${element}> with ${handlers2.join(", ")} ${handlers2.length === 1 ? "handler" : "handlers"} must have an ARIA role`,
  /**
   * @param {string} href_attribute
   * @param {string} href_value
   */
  "a11y-invalid-attribute": (href_attribute, href_value) => `A11y: '${href_value}' is not a valid ${href_attribute} attribute`,
  /**
   * @param {string} name
   * @param {string} article
   * @param {string} sequence
   */
  "a11y-missing-attribute": (name, article, sequence2) => `A11y: <${name}> element should have ${article} ${sequence2} attribute`,
  /**
   * @param {null | true | string} type
   * @param {null | true | string} value
   */
  "a11y-autocomplete-valid": (type, value) => `A11y: The value '${value}' is not supported by the attribute 'autocomplete' on element <input type="${type || "..."}">`,
  "a11y-img-redundant-alt": () => "A11y: Screenreaders already announce <img> elements as an image.",
  "a11y-label-has-associated-control": () => "A11y: A form label must be associated with a control.",
  "a11y-media-has-caption": () => 'A11y: <video> elements must have a <track kind="captions">',
  /** @param {string} name */
  "a11y-distracting-elements": (name) => `A11y: Avoid <${name}> elements`,
  /** @param {boolean} immediate */
  "a11y-structure": (immediate) => immediate ? "A11y: <figcaption> must be an immediate child of <figure>" : "A11y: <figcaption> must be first or last child of <figure>",
  /**
   * @param {string} event
   * @param {string} accompanied_by
   */
  "a11y-mouse-events-have-key-events": (event, accompanied_by) => `A11y: on:${event} must be accompanied by on:${accompanied_by}`,
  /** @param {string} name */
  "a11y-missing-content": (name) => `A11y: <${name}> element should have child content`
};
var warnings = {
  ...css2,
  ...attributes2,
  ...runes2,
  ...a11y
};
function warn(array2, node, path, code, ...args) {
  const fn = warnings[code];
  const ignores = [];
  for (let i = path.length - 1; i >= 0; i--) {
    const current2 = path[i];
    if ("leadingComments" in current2) {
      ignores.push(...extract_svelte_ignore_from_comments(current2));
    }
    if (current2.type === "Fragment") {
      ignores.push(
        ...extract_ignores_above_position(
          /** @type {import('#compiler').TemplateNode} */
          path[i + 1] ?? node,
          current2.nodes
        )
      );
    }
  }
  if (ignores.includes(code))
    return;
  const start = node?.start;
  const end = node?.end;
  array2.push({
    code,
    // @ts-expect-error
    message: fn(...args),
    position: start !== void 0 && end !== void 0 ? [start, end] : void 0
  });
}

// src/compiler/phases/3-transform/utils.js
function escape_html(s, attr) {
  if (typeof s !== "string")
    return s;
  const delimiter = attr ? '"' : "<";
  const escaped_delimiter = attr ? "&quot;" : "&lt;";
  let i_delimiter = s.indexOf(delimiter);
  let i_ampersand = s.indexOf("&");
  if (i_delimiter < 0 && i_ampersand < 0)
    return s;
  let left = 0, out = "";
  while (i_delimiter >= 0 && i_ampersand >= 0) {
    if (i_delimiter < i_ampersand) {
      if (left < i_delimiter)
        out += s.substring(left, i_delimiter);
      out += escaped_delimiter;
      left = i_delimiter + 1;
      i_delimiter = s.indexOf(delimiter, left);
    } else {
      if (left < i_ampersand)
        out += s.substring(left, i_ampersand);
      out += "&amp;";
      left = i_ampersand + 1;
      i_ampersand = s.indexOf("&", left);
    }
  }
  if (i_delimiter >= 0) {
    do {
      if (left < i_delimiter)
        out += s.substring(left, i_delimiter);
      out += escaped_delimiter;
      left = i_delimiter + 1;
      i_delimiter = s.indexOf(delimiter, left);
    } while (i_delimiter >= 0);
  } else if (!attr) {
    while (i_ampersand >= 0) {
      if (left < i_ampersand)
        out += s.substring(left, i_ampersand);
      out += "&amp;";
      left = i_ampersand + 1;
      i_ampersand = s.indexOf("&", left);
    }
  }
  return left < s.length ? out + s.substring(left) : out;
}
var svg_elements = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hatch",
  "hatchpath",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "unknown",
  "use",
  "view",
  "vkern"
];
function is_svg_element(name) {
  return svg_elements.includes(name);
}
function is_hoistable_function(node) {
  if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
    return node.metadata?.hoistable;
  }
  return false;
}
function clean_nodes(parent, nodes, path, namespace = "html", preserve_whitespace, preserve_comments, preserve_noscript) {
  const hoisted = [];
  const regular = [];
  for (const node of nodes) {
    if (node.type === "Comment" && !preserve_comments) {
      continue;
    }
    if (node.type === "RegularElement" && node.name === "noscript" && !preserve_noscript) {
      continue;
    }
    if (node.type === "ConstTag" || node.type === "DebugTag" || node.type === "SvelteBody" || node.type === "SvelteWindow" || node.type === "SvelteDocument" || node.type === "SvelteHead") {
      hoisted.push(node);
    } else {
      regular.push(node);
    }
  }
  if (preserve_whitespace) {
    return { hoisted, trimmed: regular };
  }
  let first, last;
  while ((first = regular[0]) && first.type === "Text" && !regex_not_whitespace.test(first.data)) {
    regular.shift();
  }
  if (first?.type === "Text") {
    first.raw = first.raw.replace(regex_starts_with_whitespaces, "");
    first.data = first.data.replace(regex_starts_with_whitespaces, "");
  }
  while ((last = regular.at(-1)) && last.type === "Text" && !regex_not_whitespace.test(last.data)) {
    regular.pop();
  }
  if (last?.type === "Text") {
    last.raw = last.raw.replace(regex_ends_with_whitespaces, "");
    last.data = last.data.replace(regex_ends_with_whitespaces, "");
  }
  const can_remove_entirely = namespace === "svg" && (parent.type !== "RegularElement" || parent.name !== "text") && !path.some((n2) => n2.type === "RegularElement" && n2.name === "text") || parent.type === "RegularElement" && // TODO others?
  (parent.name === "select" || parent.name === "tr" || parent.name === "table" || parent.name === "tbody" || parent.name === "thead" || parent.name === "tfoot" || parent.name === "colgroup" || parent.name === "datalist");
  const trimmed = [];
  let last_text = null;
  for (const node of regular) {
    if (node.type === "Text") {
      node.data = node.data.replace(regex_whitespaces_strict, " ");
      node.raw = node.raw.replace(regex_whitespaces_strict, " ");
      if ((last_text === null || !regex_ends_with_whitespaces.test(last_text.data)) && (!can_remove_entirely || node.data !== " ")) {
        trimmed.push(node);
      }
      last_text = node;
    } else {
      last_text = null;
      trimmed.push(node);
    }
  }
  return { hoisted, trimmed };
}
function loop_protect(node, context) {
  const timeout = context.state.analysis.loop_guard_timeout;
  const current_function = get_current_function(context.path);
  if (context.state.analysis.dev && timeout > 0 && (current_function === null || !current_function.async && !current_function.generator)) {
    const id2 = context.state.scope.generate("guard");
    const statements = node.body.type === "BlockStatement" ? [...node.body.body] : [node.body];
    statements.push(stmt(call(id(id2))));
    return block([
      const_builder(id2, call("$.loop_guard", literal2(timeout))),
      {
        .../** @type {Statement} */
        context.next() ?? node,
        body: (
          /** @type {import('estree').BlockStatement} */
          context.visit(block(statements))
        )
      }
    ]);
  }
  context.next();
}
function get_current_function(path) {
  for (let i = path.length - 1; i >= 0; i--) {
    const node = path[i];
    if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
      return node;
    }
  }
  return null;
}

// src/compiler/phases/bindings.js
var binding_properties = {
  // media
  currentTime: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  duration: {
    valid_elements: ["audio", "video"],
    event: "durationchange",
    omit_in_ssr: true
  },
  paused: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  buffered: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  seekable: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  played: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  volume: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  muted: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  playbackRate: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  seeking: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  ended: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  readyState: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  // video
  videoHeight: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  videoWidth: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  // img
  naturalWidth: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  naturalHeight: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  // document
  fullscreenElement: {
    valid_elements: ["svelte:document"],
    event: "fullscreenchange",
    omit_in_ssr: true
  },
  visibilityState: {
    valid_elements: ["svelte:document"],
    event: "visibilitychange",
    omit_in_ssr: true
  },
  // window
  innerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  innerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  scrollX: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  scrollY: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  online: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  devicePixelRatio: {
    valid_elements: ["svelte:window"],
    event: "resize",
    omit_in_ssr: true
  },
  // dimensions
  clientWidth: {
    omit_in_ssr: true
  },
  clientHeight: {
    omit_in_ssr: true
  },
  offsetWidth: {
    omit_in_ssr: true
  },
  offsetHeight: {
    omit_in_ssr: true
  },
  contentRect: {
    omit_in_ssr: true
  },
  contentBoxSize: {
    omit_in_ssr: true
  },
  borderBoxSize: {
    omit_in_ssr: true
  },
  devicePixelContentBoxSize: {
    omit_in_ssr: true
  },
  // checkbox/radio
  indeterminate: {
    event: "change",
    type: "set",
    valid_elements: ["input"],
    omit_in_ssr: true
    // no corresponding attribute
  },
  checked: {
    valid_elements: ["input"]
  },
  group: {
    valid_elements: ["input"]
  },
  // various
  this: {
    omit_in_ssr: true
  },
  innerText: {},
  innerHTML: {},
  textContent: {},
  open: {
    event: "toggle",
    valid_elements: ["details"]
  },
  value: {
    valid_elements: ["input", "textarea", "select"]
  }
};

// src/compiler/phases/2-analyze/a11y.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = aria_roles.filter((role) => import_aria_query.roles.get(role)?.abstract);
var non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name));
var non_interactive_roles = non_abstract_roles.filter((name) => {
  const role = import_aria_query.roles.get(name);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    // 'generic' is meant to have no semantic meaning.
    // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
    !["toolbar", "tabpanel", "generic", "cell"].includes(name) && !role?.superClass.some((classes) => classes.includes("widget"))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
);
var interactive_roles = non_abstract_roles.filter(
  (name) => !non_interactive_roles.includes(name) && // 'generic' is meant to have no semantic meaning.
  name !== "generic"
);
function is_non_interactive_roles(role) {
  return non_interactive_roles.includes(role);
}
function is_interactive_roles(role) {
  return interactive_roles.includes(role);
}
function is_abstract_role(role) {
  return abstract_roles.includes(role);
}
var presentation_roles = ["presentation", "none"];
function is_presentation_role(role) {
  return presentation_roles.includes(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  if (tag_name === "input") {
    const type = get_static_value2(attribute_map.get("type"));
    if (type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden)
    return false;
  const aria_hidden_value = get_static_value2(aria_hidden);
  if (aria_hidden_value === null)
    return true;
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr_value = get_static_value2(attribute_map.get("disabled"));
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = get_static_value2(aria_disabled_attr);
    if (aria_disabled_attr_value === true) {
      return true;
    }
  }
  return false;
}
var non_interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.includes(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
});
var interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => interactive_roles.includes(role))) {
    interactive_element_role_schemas.push(schema);
  }
});
var interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => import_axobject_query.AXObjects.get(name).type === "widget"
);
var non_interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name).type)
);
var interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
      interactive_element_ax_object_schemas.push(schema);
    }
  }
);
var non_interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
      non_interactive_element_ax_object_schemas.push(schema);
    }
  }
);
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name)
    return false;
  if (!schema.attributes)
    return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute)
      return false;
    if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) {
      return false;
    }
    return true;
  });
}
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      /** @param {any} attr */
      (attr) => attribute_map.has(attr.name) && get_static_value2(attribute_map.get(attr.name)) === attr.value
    ))) {
      for (const name of ax_object) {
        const roles = import_axobject_query.AXObjectRoles.get(name);
        if (roles) {
          for (const { name: name2 } of roles) {
            if (name2 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
var address_type_tokens = ["shipping", "billing"];
var autofill_field_name_tokens = [
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
var contact_type_tokens = ["home", "work", "mobile", "fax", "pager"];
var autofill_contact_field_name_tokens = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.includes(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.includes(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.includes(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.includes(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements = ["blink", "marquee"];
var a11y_required_content = [
  // anchor-has-content
  "a",
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
];
var a11y_labelable = [
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
];
var a11y_interactive_handlers = [
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
];
var a11y_recommended_interactive_handlers = [
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
];
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = ["email", "search", "tel", "text", "url"];
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute)
    return;
  const type = get_static_text_value(type_attribute);
  if (!type)
    return;
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.includes(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute)
    return;
  const type = get_static_text_value(type_attribute);
  if (!type)
    return;
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name, attribute_map) {
  if (name === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name);
  }
}
var invisible_elements = ["meta", "html", "script", "style"];
function is_parent(parent, elements2) {
  while (parent) {
    if (parent.type === "SvelteElement")
      return true;
    if (parent.type === "RegularElement") {
      return elements2.includes(parent.name);
    }
    parent = /** @type {import('#compiler').TemplateNode} */
    parent.parent;
  }
  return false;
}
function is_valid_aria_attribute_value(schema, value) {
  switch (schema.type) {
    case "boolean":
      return typeof value === "boolean";
    case "string":
    case "id":
      return typeof value === "string";
    case "tristate":
      return typeof value === "boolean" || value === "mixed";
    case "integer":
    case "number":
      return typeof value !== "boolean" && isNaN(Number(value)) === false;
    case "token":
      return (schema.values || []).indexOf(typeof value === "string" ? value.toLowerCase() : value) > -1;
    case "idlist":
      return typeof value === "string" && value.split(regex_whitespaces).every((id2) => typeof id2 === "string");
    case "tokenlist":
      return typeof value === "string" && value.split(regex_whitespaces).every((token) => (schema.values || []).indexOf(token.toLowerCase()) > -1);
    default:
      return false;
  }
}
function warn_missing_attribute(node, attributes3, name = node.name) {
  const article = regex_starts_with_vowel.test(attributes3[0]) || attributes3[0] === "href" ? "an" : "a";
  const sequence2 = attributes3.length > 1 ? attributes3.slice(0, -1).join(", ") + ` or ${attributes3[attributes3.length - 1]}` : attributes3[0];
  return (
    /** @type {const} */
    [node, "a11y-missing-attribute", name, article, sequence2]
  );
}
function get_static_value2(attribute) {
  if (!attribute)
    return null;
  if (attribute.value === true)
    return true;
  if (is_text_attribute(attribute))
    return attribute.value[0].data;
  return null;
}
function get_static_text_value(attribute) {
  const value = get_static_value2(attribute);
  if (value === true)
    return null;
  return value;
}
function check_element(node, state, path) {
  if (state.analysis.namespace === "foreign")
    return;
  const push_warning = (node2, code, ...args) => warn(state.analysis.warnings, node2, path, code, ...args);
  const attribute_map = /* @__PURE__ */ new Map();
  const handlers2 = /* @__PURE__ */ new Set();
  const attributes3 = [];
  const is_dynamic_element = node.type === "SvelteElement";
  let has_spread = false;
  let has_contenteditable_attr = false;
  let has_contenteditable_binding = false;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      has_spread = true;
    } else if (attribute.type === "OnDirective") {
      handlers2.add(attribute.name);
    } else if (attribute.type === "Attribute") {
      attributes3.push(attribute);
      attribute_map.set(attribute.name, attribute);
      if (attribute.name === "contenteditable") {
        has_contenteditable_attr = true;
      }
    } else if (attribute.type === "BindDirective" && ContentEditableBindings.includes(attribute.name)) {
      has_contenteditable_binding = true;
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute")
      continue;
    const name = attribute.name.toLowerCase();
    if (name.startsWith("aria-")) {
      if (invisible_elements.includes(node.name)) {
        push_warning(attribute, "a11y-aria-attributes", node.name);
      }
      const type = name.slice(5);
      if (!aria_attributes.includes(type)) {
        const match = fuzzymatch(type, aria_attributes);
        push_warning(attribute, "a11y-unknown-aria-attribute", type, match);
      }
      if (name === "aria-hidden" && regex_heading_tags.test(node.name)) {
        push_warning(attribute, "a11y-hidden", node.name);
      }
      let value = get_static_value2(attribute);
      if (value === "true")
        value = true;
      if (value === "false")
        value = false;
      if (value !== null && value !== void 0) {
        const schema = import_aria_query.aria.get(
          /** @type {import('aria-query').ARIAProperty} */
          name
        );
        if (schema !== void 0 && !is_valid_aria_attribute_value(schema, value)) {
          push_warning(attribute, "a11y-incorrect-aria-attribute-type", schema, name);
        }
      }
      if (name === "aria-activedescendant" && !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !attribute_map.has("tabindex")) {
        push_warning(attribute, "a11y-aria-activedescendant-has-tabindex");
      }
    }
    if (name === "role") {
      if (invisible_elements.includes(node.name)) {
        push_warning(attribute, "a11y-misplaced-role", node.name);
      }
      const value = get_static_value2(attribute);
      if (typeof value === "string") {
        for (const c_r of value.split(regex_whitespaces)) {
          const current_role = (
            /** @type {import('aria-query').ARIARoleDefinitionKey} current_role */
            c_r
          );
          if (current_role && is_abstract_role(current_role)) {
            push_warning(attribute, "a11y-no-abstract-role", current_role);
          } else if (current_role && !aria_roles.includes(current_role)) {
            const match = fuzzymatch(current_role, aria_roles);
            push_warning(attribute, "a11y-unknown-role", current_role, match);
          }
          if (current_role === get_implicit_role(node.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
          !["ul", "ol", "li"].includes(node.name)) {
            push_warning(attribute, "a11y-no-redundant-roles", current_role);
          }
          const is_parent_section_or_article = is_parent(node.parent, ["section", "article"]);
          if (!is_parent_section_or_article) {
            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(node.name);
            if (has_nested_redundant_role) {
              push_warning(attribute, "a11y-no-redundant-roles", current_role);
            }
          }
          if (!is_dynamic_element && !is_semantic_role_element(current_role, node.name, attribute_map)) {
            const role2 = import_aria_query.roles.get(current_role);
            if (role2) {
              const required_role_props = Object.keys(role2.requiredProps);
              const has_missing_props = required_role_props.some(
                (prop2) => !attributes3.find((a) => a.name === prop2)
              );
              if (has_missing_props) {
                push_warning(
                  attribute,
                  "a11y-role-has-required-aria-props",
                  current_role,
                  required_role_props
                );
              }
            }
          }
          if (!has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(node.name, attribute_map) && !attribute_map.get("tabindex")) {
            const has_interactive_handlers = [...handlers2].some(
              (handler) => a11y_interactive_handlers.includes(handler)
            );
            if (has_interactive_handlers) {
              push_warning(node, "a11y-interactive-supports-focus", current_role);
            }
          }
          if (is_interactive_element(node.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
            push_warning(
              node,
              "a11y-no-interactive-element-to-noninteractive-role",
              current_role,
              node.name
            );
          }
          if (is_non_interactive_element(node.name, attribute_map) && is_interactive_roles(current_role) && !a11y_non_interactive_element_to_interactive_role_exceptions[node.name]?.includes(
            current_role
          )) {
            push_warning(
              node,
              "a11y-no-noninteractive-element-to-interactive-role",
              current_role,
              node.name
            );
          }
        }
      }
    }
    if (name === "accesskey") {
      push_warning(attribute, "a11y-accesskey");
    }
    if (name === "autofocus") {
      push_warning(attribute, "a11y-autofocus");
    }
    if (name === "scope" && !is_dynamic_element && node.name !== "th") {
      push_warning(attribute, "a11y-misplaced-scope");
    }
    if (name === "tabindex") {
      const value = get_static_value2(attribute);
      if (!isNaN(value) && +value > 0) {
        push_warning(attribute, "a11y-positive-tabindex");
      }
    }
  }
  const role = attribute_map.get("role");
  const role_static_value = (
    /** @type {import('aria-query').ARIARoleDefinitionKey} */
    get_static_text_value(role)
  );
  if (handlers2.has("click")) {
    const is_non_presentation_role = role_static_value !== null && !is_presentation_role(role_static_value);
    if (!is_dynamic_element && !is_hidden_from_screen_reader(node.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(node.name, attribute_map) && !has_spread) {
      const has_key_event = handlers2.has("keydown") || handlers2.has("keyup") || handlers2.has("keypress");
      if (!has_key_event) {
        push_warning(node, "a11y-click-events-have-key-events");
      }
    }
  }
  const role_value = (
    /** @type {import('aria-query').ARIARoleDefinitionKey} */
    role ? role_static_value : get_implicit_role(node.name, attribute_map)
  );
  if (!is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value)) {
    const tab_index = attribute_map.get("tabindex");
    const tab_index_value = get_static_text_value(tab_index);
    if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) {
      push_warning(node, "a11y-no-noninteractive-tabindex");
    }
  }
  if (typeof role_value === "string" && import_aria_query.roles.has(role_value)) {
    const { props } = (
      /** @type {import('aria-query').ARIARoleDefinition} */
      import_aria_query.roles.get(role_value)
    );
    const invalid_aria_props = import_aria_query.aria.keys().filter((attribute) => !(attribute in props));
    const is_implicit = role_value && role === void 0;
    for (const attr of attributes3) {
      if (invalid_aria_props.includes(
        /** @type {import('aria-query').ARIAProperty} */
        attr.name
      )) {
        push_warning(
          attr,
          "a11y-role-supports-aria-props",
          attr.name,
          role_value,
          is_implicit,
          node.name
        );
      }
    }
  }
  if (!has_contenteditable_attr && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(node.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(node.name, attribute_map) && !role)) {
    const has_interactive_handlers = [...handlers2].some(
      (handler) => a11y_recommended_interactive_handlers.includes(handler)
    );
    if (has_interactive_handlers) {
      push_warning(node, "a11y-no-noninteractive-element-interactions", node.name);
    }
  }
  if ((!role || role_static_value !== null) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(node.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
    const interactive_handlers = [...handlers2].filter(
      (handler) => a11y_interactive_handlers.includes(handler)
    );
    if (interactive_handlers.length > 0) {
      push_warning(node, "a11y-no-static-element-interactions", node.name, interactive_handlers);
    }
  }
  if (handlers2.has("mouseover") && !handlers2.has("focus")) {
    push_warning(node, "a11y-mouse-events-have-key-events", "mouseover", "focus");
  }
  if (handlers2.has("mouseout") && !handlers2.has("blur")) {
    push_warning(node, "a11y-mouse-events-have-key-events", "mouseout", "blur");
  }
  let contains_a11y_label = false;
  if (node.name === "a") {
    const aria_label_attribute = attribute_map.get("aria-label");
    if (aria_label_attribute) {
      if (get_static_value2(aria_label_attribute) !== "") {
        contains_a11y_label = true;
      }
    }
    const href = attribute_map.get("href") || attribute_map.get("xlink:href");
    if (href) {
      const href_value = get_static_text_value(href);
      if (href_value !== null) {
        if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
          push_warning(href, "a11y-invalid-attribute", href.name, href_value);
        }
      }
    } else if (!has_spread) {
      const id_attribute = get_static_value2(attribute_map.get("id"));
      const name_attribute = get_static_value2(attribute_map.get("name"));
      if (!id_attribute && !name_attribute) {
        push_warning(...warn_missing_attribute(node, ["href"]));
      }
    }
  } else if (!has_spread) {
    const required_attributes = a11y_required_attributes[node.name];
    if (required_attributes) {
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        push_warning(...warn_missing_attribute(node, required_attributes));
      }
    }
  }
  if (node.name === "input") {
    const type = attribute_map.get("type");
    const type_value = get_static_text_value(type);
    if (type_value === "image" && !has_spread) {
      const required_attributes = ["alt", "aria-label", "aria-labelledby"];
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        push_warning(...warn_missing_attribute(node, required_attributes, 'input type="image"'));
      }
    }
    const autocomplete = attribute_map.get("autocomplete");
    if (type && autocomplete) {
      const autocomplete_value = get_static_value2(autocomplete);
      if (!is_valid_autocomplete(autocomplete_value)) {
        push_warning(autocomplete, "a11y-autocomplete-valid", type_value, autocomplete_value);
      }
    }
  }
  if (node.name === "img") {
    const alt_attribute = get_static_text_value(attribute_map.get("alt"));
    const aria_hidden = get_static_value2(attribute_map.get("aria-hidden"));
    if (alt_attribute && !aria_hidden) {
      if (/\b(image|picture|photo)\b/i.test(alt_attribute)) {
        push_warning(node, "a11y-img-redundant-alt");
      }
    }
  }
  if (node.name === "label") {
    const has_input_child = (node2) => {
      let has = false;
      walk(
        node2,
        {},
        {
          _(node3, { next: next2 }) {
            if (node3.type === "SvelteElement" || node3.type === "SlotElement" || node3.type === "RegularElement" && (a11y_labelable.includes(node3.name) || node3.name === "slot")) {
              has = true;
            } else {
              next2();
            }
          }
        }
      );
      return has;
    };
    if (!attribute_map.has("for") && !has_input_child(node)) {
      push_warning(node, "a11y-label-has-associated-control");
    }
  }
  if (node.name === "video") {
    const aria_hidden_attribute = attribute_map.get("aria-hidden");
    const aria_hidden_exist = aria_hidden_attribute && get_static_value2(aria_hidden_attribute);
    if (attribute_map.has("muted") || aria_hidden_exist === "true") {
      return;
    }
    let has_caption = false;
    const track = (
      /** @type {import('#compiler').RegularElement | undefined} */
      node.fragment.nodes.find((i) => i.type === "RegularElement" && i.name === "track")
    );
    if (track) {
      has_caption = track.attributes.some(
        (a) => a.type === "SpreadAttribute" || a.type === "Attribute" && a.name === "kind" && get_static_value2(a) === "captions"
      );
    }
    if (!has_caption) {
      push_warning(node, "a11y-media-has-caption");
    }
  }
  if (node.name === "figcaption") {
    if (!is_parent(node.parent, ["figure"])) {
      push_warning(node, "a11y-structure", true);
    }
  }
  if (node.name === "figure") {
    const children = node.fragment.nodes.filter((node2) => {
      if (node2.type === "Comment")
        return false;
      if (node2.type === "Text")
        return regex_not_whitespace.test(node2.data);
      return true;
    });
    const index = children.findIndex(
      (child) => child.type === "RegularElement" && child.name === "figcaption"
    );
    if (index !== -1 && index !== 0 && index !== children.length - 1) {
      push_warning(children[index], "a11y-structure", false);
    }
  }
  if (a11y_distracting_elements.includes(node.name)) {
    push_warning(node, "a11y-distracting-elements", node.name);
  }
  if (!contains_a11y_label && !has_contenteditable_binding && a11y_required_content.includes(node.name) && node.fragment.nodes.length === 0) {
    push_warning(node, "a11y-missing-content", node.name);
  }
}
var a11y_validators = {
  RegularElement(node, context) {
    check_element(node, context.state, context.path);
  },
  SvelteElement(node, context) {
    check_element(node, context.state, context.path);
  }
};

// src/compiler/phases/2-analyze/validation.js
function validate_component(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" && attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective" && attribute.type !== "OnDirective" && attribute.type !== "BindDirective") {
      error(attribute, "invalid-component-directive");
    }
  }
  context.next({
    ...context.state,
    parent_element: null,
    component_slots: /* @__PURE__ */ new Set()
  });
}
function validate_element(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute" && attribute.name === "is" && context.state.analysis.namespace !== "foreign") {
      warn(context.state.analysis.warnings, attribute, context.path, "avoid-is");
    }
    if (attribute.type === "Attribute" && attribute.name === "slot") {
      validate_slot_attribute(context, attribute);
    }
  }
}
function validate_slot_attribute(context, attribute) {
  let owner = void 0;
  let i = context.path.length;
  while (i--) {
    const ancestor = context.path[i];
    if (!owner && (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteSelf" || ancestor.type === "SvelteElement" || ancestor.type === "RegularElement" && is_custom_element_node(ancestor))) {
      owner = ancestor;
    }
  }
  if (owner) {
    if (!is_text_attribute(attribute)) {
      error(attribute, "invalid-slot-attribute");
    }
    if (owner.type === "Component" || owner.type === "SvelteComponent") {
      if (owner !== context.path.at(-2)) {
        error(attribute, "invalid-slot-placement");
      }
    }
    const name = attribute.value[0].data;
    if (context.state.component_slots.has(name)) {
      error(attribute, "duplicate-slot-name", name, owner.name);
    }
    context.state.component_slots.add(name);
    if (name === "default") {
      for (const node of owner.fragment.nodes) {
        if (node.type === "Text" && regex_only_whitespaces.test(node.data)) {
          continue;
        }
        if (node.type === "RegularElement" || node.type === "SvelteFragment") {
          if (node.attributes.some((a) => a.type === "Attribute" && a.name === "slot")) {
            continue;
          }
        }
        error(node, "invalid-default-slot-content");
      }
    }
  } else {
    error(attribute, "invalid-slot-placement");
  }
}
var implied_end_tags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
function is_tag_valid_with_parent(tag2, parent_tag) {
  switch (parent_tag) {
    case "select":
      return tag2 === "option" || tag2 === "optgroup" || tag2 === "#text";
    case "optgroup":
      return tag2 === "option" || tag2 === "#text";
    case "option":
      return tag2 === "#text";
    case "tr":
      return tag2 === "th" || tag2 === "td" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "tbody":
    case "thead":
    case "tfoot":
      return tag2 === "tr" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "colgroup":
      return tag2 === "col" || tag2 === "template";
    case "table":
      return tag2 === "caption" || tag2 === "colgroup" || tag2 === "tbody" || tag2 === "tfoot" || tag2 === "thead" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "head":
      return tag2 === "base" || tag2 === "basefont" || tag2 === "bgsound" || tag2 === "link" || tag2 === "meta" || tag2 === "title" || tag2 === "noscript" || tag2 === "noframes" || tag2 === "style" || tag2 === "script" || tag2 === "template";
    case "html":
      return tag2 === "head" || tag2 === "body" || tag2 === "frameset";
    case "frameset":
      return tag2 === "frame";
    case "#document":
      return tag2 === "html";
  }
  switch (tag2) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      return parent_tag !== "h1" && parent_tag !== "h2" && parent_tag !== "h3" && parent_tag !== "h4" && parent_tag !== "h5" && parent_tag !== "h6";
    case "rp":
    case "rt":
      return implied_end_tags.indexOf(parent_tag) === -1;
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
    case "tbody":
    case "td":
    case "tfoot":
    case "th":
    case "thead":
    case "tr":
      return parent_tag == null;
  }
  return true;
}
var validation = {
  BindDirective(node, context) {
    validate_no_const_assignment(node, node.expression, context.state.scope, true);
    let left = node.expression;
    while (left.type === "MemberExpression") {
      left = /** @type {import('estree').MemberExpression} */
      left.object;
    }
    if (left.type !== "Identifier") {
      error(node, "invalid-binding-expression");
    }
    if (node.expression.type === "Identifier" && node.name !== "this") {
      const binding = context.state.scope.get(left.name);
      if (!binding || binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "each" && binding.kind !== "store_sub" && !binding.mutated) {
        error(node.expression, "invalid-binding-value");
      }
    }
    if (node.name === "group") {
      const binding = context.state.scope.get(left.name);
      if (!binding) {
        error(node, "INTERNAL", "Cannot find declaration for bind:group");
      }
    }
    const parent = context.path.at(-1);
    if (parent?.type === "RegularElement" || parent?.type === "SvelteElement" || parent?.type === "SvelteWindow" || parent?.type === "SvelteDocument" || parent?.type === "SvelteBody") {
      if (context.state.analysis.namespace === "foreign" && node.name !== "this") {
        error(
          node,
          "invalid-binding",
          node.name,
          void 0,
          ". Foreign elements only support bind:this"
        );
      }
      if (node.name in binding_properties) {
        const property = binding_properties[node.name];
        if (property.valid_elements && !property.valid_elements.includes(parent.name)) {
          error(
            node,
            "invalid-binding",
            node.name,
            property.valid_elements.map((valid_element) => `<${valid_element}>`).join(", ")
          );
        }
        if (parent.name === "input") {
          const type = (
            /** @type {import('#compiler').Attribute | undefined} */
            parent.attributes.find((a) => a.type === "Attribute" && a.name === "type")
          );
          if (type && !is_text_attribute(type)) {
            error(type, "invalid-type-attribute");
          }
          if (node.name === "checked" && type?.value[0].data !== "checkbox") {
            error(node, "invalid-binding", node.name, '<input type="checkbox">');
          }
        }
        if (parent.name === "select") {
          const multiple = parent.attributes.find(
            (a) => a.type === "Attribute" && a.name === "multiple" && !is_text_attribute(a) && a.value !== true
          );
          if (multiple) {
            error(multiple, "invalid-multiple-attribute");
          }
        }
        if (node.name === "offsetWidth" && is_svg_element(parent.name)) {
          error(
            node,
            "invalid-binding",
            node.name,
            `non-<svg> elements. Use 'clientWidth' for <svg> instead`
          );
        }
      } else {
        const match = fuzzymatch(node.name, Object.keys(binding_properties));
        if (match) {
          const property = binding_properties[match];
          if (!property.valid_elements || property.valid_elements.includes(parent.name)) {
            error(node, "invalid-binding", node.name, void 0, ` (did you mean '${match}'?)`);
          }
        }
        error(node, "invalid-binding", node.name);
      }
    }
  },
  RegularElement(node, context) {
    if (node.name === "textarea" && node.fragment.nodes.length > 0) {
      for (const attribute of node.attributes) {
        if (attribute.type === "Attribute" && attribute.name === "value") {
          error(node, "invalid-textarea-content");
        }
      }
    }
    validate_element(node, context);
    if (context.state.parent_element) {
      if (!is_tag_valid_with_parent(node.name, context.state.parent_element)) {
        error(node, "invalid-node-placement", `<${node.name}>`, context.state.parent_element);
      }
    }
    context.next({
      ...context.state,
      parent_element: node.name
    });
  },
  SvelteElement(node, context) {
    validate_element(node, context);
    context.next({
      ...context.state,
      parent_element: null
    });
  },
  SvelteFragment(node, context) {
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute") {
        if (attribute.name === "slot") {
          validate_slot_attribute(context, attribute);
        }
      } else if (attribute.type !== "LetDirective") {
        error(attribute, "invalid-svelte-fragment-attribute");
      }
    }
  },
  SlotElement(node) {
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute") {
        if (attribute.name === "name") {
          if (!is_text_attribute(attribute)) {
            error(attribute, "invalid-slot-name");
          }
        }
      } else if (attribute.type !== "SpreadAttribute") {
        error(attribute, "invalid-slot-element-attribute");
      }
    }
  },
  Component: validate_component,
  SvelteComponent: validate_component,
  SvelteSelf: validate_component,
  Text(node, context) {
    if (!node.parent)
      return;
    if (context.state.parent_element && regex_not_whitespace.test(node.data)) {
      if (!is_tag_valid_with_parent("#text", context.state.parent_element)) {
        error(node, "invalid-node-placement", "Text node", context.state.parent_element);
      }
    }
  },
  ExpressionTag(node, context) {
    if (!node.parent)
      return;
    if (context.state.parent_element) {
      if (!is_tag_valid_with_parent("#text", context.state.parent_element)) {
        error(node, "invalid-node-placement", "{expression}", context.state.parent_element);
      }
    }
  }
};
var validation_legacy = merge(validation, a11y_validators, {
  VariableDeclarator(node) {
    if (node.init?.type !== "CallExpression")
      return;
    const callee = node.init.callee;
    if (callee.type !== "Identifier" || callee.name !== "$state" && callee.name !== "$derived" && callee.name !== "$props") {
      return;
    }
    error(node.init, "invalid-rune-usage", callee.name);
  },
  ExportNamedDeclaration(node) {
    if (node.declaration && node.declaration.type !== "VariableDeclaration" && node.declaration.type !== "FunctionDeclaration") {
      error(node, "TODO", "whatever this is");
    }
  },
  AssignmentExpression(node, { state, path }) {
    const parent = path.at(-1);
    if (parent && parent.type === "ConstTag")
      return;
    validate_assignment(node, node.left, state.scope);
  },
  UpdateExpression(node, { state }) {
    validate_assignment(node, node.argument, state.scope);
  }
});
function validate_export(node, scope, name) {
  const binding = scope.get(name);
  if (binding && (binding.kind === "derived" || binding.kind === "state")) {
    error(node, "invalid-rune-export", `$${binding.kind}`);
  }
}
function validate_call_expression(node, scope, path) {
  const rune = get_rune(node, scope);
  if (rune === null)
    return;
  if ((rune === "$derived" || rune === "$props" || rune === "$state") && path.at(-1)?.type !== "VariableDeclarator") {
    error(
      node,
      rune === "$derived" ? "invalid-derived-location" : rune === "$props" ? "invalid-props-location" : "invalid-state-location"
    );
  } else if (rune === "$effect") {
    if (path.at(-1)?.type !== "ExpressionStatement") {
      error(node, "invalid-effect-location");
    } else if (node.arguments.length !== 1) {
      error(node, "invalid-rune-args-length", "$effect", [1]);
    }
  }
}
var validation_runes_js = {
  ExportSpecifier(node, { state }) {
    validate_export(node, state.scope, node.local.name);
  },
  ExportNamedDeclaration(node, { state, next: next2 }) {
    if (node.declaration?.type !== "VariableDeclaration")
      return;
    next2();
    for (const declarator2 of node.declaration.declarations) {
      for (const id2 of extract_identifiers(declarator2.id)) {
        validate_export(node, state.scope, id2.name);
      }
    }
  },
  CallExpression(node, { state, path }) {
    validate_call_expression(node, state.scope, path);
  },
  VariableDeclarator(node, { state }) {
    const init2 = node.init;
    const rune = get_rune(init2, state.scope);
    if (rune === null)
      return;
    const args = (
      /** @type {import('estree').CallExpression} */
      init2.arguments
    );
    if (rune === "$derived" && args.length !== 1) {
      error(node, "invalid-rune-args-length", "$derived", [1]);
    } else if (rune === "$state" && args.length > 1) {
      error(node, "invalid-rune-args-length", "$state", [0, 1]);
    } else if (rune === "$props") {
      error(node, "invalid-props-location");
    }
  },
  AssignmentExpression(node, { state }) {
    validate_assignment(node, node.left, state.scope);
  },
  UpdateExpression(node, { state }) {
    validate_assignment(node, node.argument, state.scope);
  }
};
function validate_no_const_assignment(node, argument, scope, is_binding) {
  if (argument.type === "Identifier") {
    const binding = scope.get(argument.name);
    if (binding?.declaration_kind === "const" && binding.kind !== "each") {
      error(
        node,
        "invalid-const-assignment",
        is_binding,
        // This takes advantage of the fact that we don't assign initial for let directives and then/catch variables.
        // If we start doing that, we need another property on the binding to differentiate, or give up on the more precise error message.
        binding.kind !== "state" && (binding.kind !== "normal" || !binding.initial)
      );
    }
  }
}
function validate_assignment(node, argument, scope) {
  validate_no_const_assignment(node, argument, scope, false);
  let left = (
    /** @type {import('estree').Pattern} */
    argument
  );
  while (left.type === "MemberExpression") {
    left = /** @type {import('estree').Identifier | import('estree').MemberExpression} */
    left.object;
  }
  if (left.type === "Identifier") {
    const binding = scope.get(left.name);
    if (binding?.kind === "derived") {
      error(node, "invalid-derived-assignment");
    }
  }
}
var validation_runes = merge(validation, a11y_validators, {
  AssignmentExpression(node, { state, path }) {
    const parent = path.at(-1);
    if (parent && parent.type === "ConstTag")
      return;
    validate_assignment(node, node.left, state.scope);
  },
  UpdateExpression(node, { state }) {
    validate_assignment(node, node.argument, state.scope);
  },
  LabeledStatement(node, { path }) {
    if (node.label.name !== "$" || path.at(-1)?.type !== "Program")
      return;
    error(node, "invalid-legacy-reactive-statement");
  },
  ExportNamedDeclaration(node, { state }) {
    if (node.declaration?.type !== "VariableDeclaration")
      return;
    if (node.declaration.kind !== "let")
      return;
    if (state.analysis.instance.scope !== state.scope)
      return;
    error(node, "invalid-legacy-export");
  },
  ExportSpecifier(node, { state }) {
    validate_export(node, state.scope, node.local.name);
  },
  CallExpression(node, { state, path }) {
    validate_call_expression(node, state.scope, path);
  },
  EachBlock(node, { next: next2, state }) {
    const context = node.context;
    if (context.type === "Identifier" && (context.name === "$state" || context.name === "$derived")) {
      error(
        node,
        context.name === "$derived" ? "invalid-derived-location" : "invalid-state-location"
      );
    }
    next2({ ...state });
  },
  VariableDeclarator(node, { state }) {
    const init2 = node.init;
    const rune = get_rune(init2, state.scope);
    if (rune === null)
      return;
    const args = (
      /** @type {import('estree').CallExpression} */
      init2.arguments
    );
    if (rune === "$derived" && args.length !== 1) {
      error(node, "invalid-rune-args-length", "$derived", [1]);
    } else if (rune === "$state" && args.length > 1) {
      error(node, "invalid-rune-args-length", "$state", [0, 1]);
    } else if (rune === "$props") {
      if (state.has_props_rune) {
        error(node, "duplicate-props-rune");
      }
      state.has_props_rune = true;
      if (args.length > 0) {
        error(node, "invalid-rune-args-length", "$props", [0]);
      }
      if (node.id.type !== "ObjectPattern") {
        error(node, "invalid-props-id");
      }
      if (state.scope !== state.analysis.instance.scope) {
        error(node, "invalid-props-location");
      }
      for (const property of node.id.properties) {
        if (property.type === "Property") {
          if (property.computed) {
            error(property, "invalid-props-pattern");
          }
          const value = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
          if (value.type !== "Identifier") {
            error(property, "invalid-props-pattern");
          }
        }
      }
    }
  }
});

// src/compiler/phases/2-analyze/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u))
      g.set(u, []);
    if (!g.has(v))
      g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    visited.add(v);
    on_stack.add(v);
    graph.get(v)?.forEach((w) => {
      if (!visited.has(w)) {
        visit(w);
      } else if (on_stack.has(w)) {
        cycles.push([...on_stack, w]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// src/compiler/phases/2-analyze/index.js
function js(script, root, allow_reactive_declarations, parent) {
  const ast = script?.content ?? {
    type: "Program",
    sourceType: "module",
    start: -1,
    end: -1,
    body: []
  };
  const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
  return { ast, scope, scopes };
}
function get_component_name(filename) {
  const parts = filename.split(/[/\\]/);
  const basename = (
    /** @type {string} */
    parts.pop()
  );
  const last_dir = (
    /** @type {string} */
    parts.at(-1)
  );
  let name = basename.replace(".svelte", "");
  if (name === "index" && last_dir && last_dir !== "src") {
    name = last_dir;
  }
  return name[0].toUpperCase() + name.slice(1);
}
function get_delegated_event(node, context) {
  const handler = node.expression;
  const event_name = node.name;
  if (!handler || node.modifiers.includes("capture") || !DelegatedEvents.includes(event_name)) {
    return null;
  }
  const element = context.path.at(-1);
  if (element == null || element.type !== "RegularElement" && element.type !== "SlotElement") {
    return null;
  }
  if (element.attributes.filter((attr) => attr.type === "OnDirective" && attr.name === event_name).length > 1) {
    return null;
  }
  const non_hoistable = { type: "non-hoistable" };
  let target_function = null;
  let binding = null;
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    target_function = handler;
  } else if (handler.type === "Identifier") {
    binding = context.state.scope.get(handler.name);
    if (binding != null) {
      for (const { path } of binding.references) {
        const parent = path.at(-1);
        if (parent == null) {
          return non_hoistable;
        }
        if (parent.type === "OnDirective") {
          const element2 = path.at(-2);
          if (element2 == null || element2.type !== "RegularElement" && element2.type !== "SlotElement") {
            return non_hoistable;
          }
        } else if (parent.type !== "FunctionDeclaration" && parent.type !== "VariableDeclarator") {
          return non_hoistable;
        }
      }
    }
    if (context.state.analysis.exports.find((node2) => node2.name === handler.name)) {
      return non_hoistable;
    }
    if (binding !== null && binding.initial !== null && !binding.mutated && !binding.is_called) {
      const binding_type = binding.initial.type;
      if (binding_type === "ArrowFunctionExpression" || binding_type === "FunctionDeclaration" || binding_type === "FunctionExpression") {
        target_function = binding.initial;
      }
    }
  }
  if (target_function == null) {
    return non_hoistable;
  }
  if (target_function.params.length > 1) {
    return non_hoistable;
  }
  const scope = target_function.metadata.scope;
  for (const [reference] of scope.references) {
    const binding2 = scope.get(reference);
    if (binding2 !== null && // Bail-out if we reference anything from the EachBlock (for now) that mutates in non-runes mode,
    (!context.state.analysis.runes && binding2.kind === "each" || // or any normal not reactive bindings that are mutated.
    binding2.kind === "normal" && context.state.analysis.runes || // or any reactive imports (those are rewritten) (can only happen in legacy mode)
    binding2.kind === "state" && binding2.declaration_kind === "import") && binding2.mutated) {
      return non_hoistable;
    }
  }
  return { type: "hoistable", function: target_function };
}
function analyze_module(ast, options) {
  const { scope, scopes } = create_scopes(ast, new ScopeRoot(), false, null);
  const uses_runes = [...scope.references].some(([name]) => {
    return Runes.includes(name) && scope.get(name) === null;
  });
  if (!uses_runes) {
    return null;
  }
  walk(
    /** @type {import('estree').Node} */
    ast,
    { scope },
    merge(set_scope(scopes), validation_runes_js, runes_scope_js_tweaker)
  );
  return {
    // These are the important ones to set that actually matter
    module: { ast, scope, scopes },
    root: scope.root,
    runes: true,
    // These are all just placeholders which are not actually used,
    // but it makes it possible to reuse the dom/ssr generation code.
    accessors: false,
    custom_element: void 0,
    binding_groups: /* @__PURE__ */ new Map(),
    dev: false,
    loop_guard_timeout: 0,
    elements: [],
    exports: [],
    immutable: false,
    instance: {
      ast: { type: "Program", body: [], sourceType: "module" },
      scope,
      scopes: /* @__PURE__ */ new Map()
    },
    template: {
      ast: { type: "Fragment", nodes: [], transparent: false },
      scope,
      scopes: /* @__PURE__ */ new Map()
    },
    name: options.filename || "module",
    namespace: void 0,
    preserve_comments: false,
    preserve_whitespace: false,
    reactive_statements: /* @__PURE__ */ new Map(),
    stylesheet: new Stylesheet({ ast: null, component_name: "", filename: "" }),
    uses_rest_props: false,
    uses_component_bindings: false,
    slot_names: /* @__PURE__ */ new Set(),
    warnings: []
  };
}
function analyze_component(root, global_options) {
  const options = {
    ...global_options,
    ...root.options
  };
  const scope_root = new ScopeRoot();
  const module = js(root.module, scope_root, false, null);
  const instance = js(root.instance, scope_root, true, module.scope);
  const { scope, scopes } = create_scopes(root.fragment, scope_root, false, instance.scope);
  const template2 = { ast: root.fragment, scope, scopes };
  const warnings2 = [];
  for (const [name, references] of module.scope.references) {
    if (name[0] !== "$" || ReservedKeywords.includes(name))
      continue;
    if (name === "$" || name[1] === "$") {
      error(references[0].node, "illegal-global", name);
    }
    const store_name = name.slice(1);
    const declaration2 = instance.scope.get(store_name);
    if (options.runes === false || !Runes.includes(name) || declaration2 !== null && // const state = $state(0) is valid
    !Runes.includes(
      /** @type {string} */
      get_callee_name(
        /** @type {import('estree').Expression} */
        declaration2.initial
      )
    ) && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
    !(name === "$derived" && declaration2.initial?.type === "ImportDeclaration" && declaration2.initial.source.value === "svelte/store")) {
      if (options.runes !== false) {
        if (declaration2 === null && /[a-z]/.test(store_name[0])) {
          error(references[0].node, "illegal-global", name);
        } else if (declaration2 !== null && Runes.includes(name)) {
          warn(warnings2, declaration2.node, [], "store-with-rune-name", store_name);
        }
      }
      if (module.ast) {
        for (const { node } of references) {
          if (
            /** @type {number} */
            node.start > /** @type {number} */
            module.ast.start && /** @type {number} */
            node.end < /** @type {number} */
            module.ast.end
          ) {
            error(node, "illegal-subscription");
          }
        }
      }
      const binding = instance.scope.declare(id(name), "store_sub", "let");
      binding.references = references;
    }
  }
  const component_name = get_component_name(global_options.filename ?? "Component");
  const analysis = {
    name: module.scope.generate(global_options.name ?? component_name),
    root: scope_root,
    module,
    instance,
    template: template2,
    elements: [],
    stylesheet: new Stylesheet({
      ast: root.css,
      // TODO are any of these necessary or can we just pass in the whole `analysis` object later?
      filename: global_options.filename ?? "<unknown>",
      component_name,
      get_css_hash: global_options.cssHash
    }),
    runes: options.runes ?? Array.from(module.scope.references).some(([name]) => Runes.includes(name)),
    immutable: options.immutable ?? false,
    exports: [],
    uses_rest_props: false,
    uses_component_bindings: false,
    dev: options.dev ?? false,
    loop_guard_timeout: options.loopGuardTimeout ?? 0,
    accessors: options.customElement ? true : !!options.accessors,
    preserve_comments: options.preserveComments ?? false,
    preserve_whitespace: options.preserveWhitespace ?? false,
    namespace: options.namespace,
    custom_element: options.customElement,
    reactive_statements: /* @__PURE__ */ new Map(),
    binding_groups: /* @__PURE__ */ new Map(),
    slot_names: /* @__PURE__ */ new Set(),
    warnings: warnings2
  };
  if (analysis.runes) {
    const props_refs = module.scope.references.get("$$props");
    if (props_refs) {
      error(props_refs[0].node, "invalid-legacy-props");
    }
    const rest_props_refs = module.scope.references.get("$$restProps");
    if (rest_props_refs) {
      error(rest_props_refs[0].node, "invalid-legacy-rest-props");
    }
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template2]) {
      const state = {
        scope: scope2,
        analysis,
        parent_element: null,
        has_props_rune: false,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null
      };
      walk(
        /** @type {import('#compiler').SvelteNode} */
        ast,
        state,
        merge(set_scope(scopes2), validation_runes, runes_scope_tweaker, common_visitors)
      );
    }
  } else {
    instance.scope.declare(id("$$props"), "prop", "const");
    instance.scope.declare(id("$$restProps"), "rest_prop", "const");
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template2]) {
      const state = {
        scope: scope2,
        analysis,
        parent_element: null,
        has_props_rune: false,
        ast_type: ast === instance.ast ? "instance" : ast === template2.ast ? "template" : "module",
        instance_scope: instance.scope,
        reactive_statement: null,
        reactive_statements: analysis.reactive_statements,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null
      };
      walk(
        /** @type {import('#compiler').SvelteNode} */
        ast,
        state,
        // @ts-expect-error TODO
        merge(set_scope(scopes2), validation_legacy, legacy_scope_tweaker, common_visitors)
      );
    }
    analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
  }
  analysis.stylesheet.validate(analysis);
  for (const element of analysis.elements) {
    analysis.stylesheet.apply(element);
  }
  analysis.stylesheet.reify(options.generate === "dom");
  return analysis;
}
var legacy_scope_tweaker = {
  LabeledStatement(node, { next: next2, path, state }) {
    if (state.ast_type !== "instance" || node.label.name !== "$" || /** @type {import('#compiler').SvelteNode} */
    path.at(-1).type !== "Program") {
      return next2();
    }
    const reactive_statement = {
      assignments: /* @__PURE__ */ new Set(),
      dependencies: /* @__PURE__ */ new Set()
    };
    next2({ ...state, reactive_statement });
    for (const [name, nodes] of state.scope.references) {
      const binding = state.scope.get(name);
      if (binding === null)
        continue;
      if (nodes.some((n2) => n2.node !== binding.node && !reactive_statement.assignments.has(n2.node))) {
        reactive_statement.dependencies.add(binding);
      }
    }
    state.reactive_statements.set(node, reactive_statement);
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node.body.expression.left)) {
        const binding = state.scope.get(id2.name);
        if (binding?.kind === "legacy_reactive") {
          binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
        }
      }
    }
  },
  AssignmentExpression(node, { state, next: next2 }) {
    if (state.reactive_statement && node.operator === "=") {
      for (const id2 of extract_identifiers(node.left)) {
        state.reactive_statement.assignments.add(id2);
      }
    }
    next2();
  },
  Identifier(node, { state, path }) {
    const parent = (
      /** @type {import('estree').Node} */
      path.at(-1)
    );
    if (is_reference(node, parent)) {
      if (node.name === "$$restProps") {
        state.analysis.uses_rest_props = true;
      }
      let binding = state.scope.get(node.name);
      if (binding?.kind === "store_sub") {
        binding = state.scope.get(node.name.slice(1));
      }
      if (binding !== null && binding.kind === "normal" && (binding.scope === state.instance_scope && binding.declaration_kind !== "function" || binding.declaration_kind === "import")) {
        if (binding.declaration_kind === "import") {
          if (binding.mutated && // TODO could be more fine-grained - not every mention in the template implies a state binding
          (state.reactive_statement || state.ast_type === "template") && parent.type === "MemberExpression") {
            binding.kind = "state";
          }
        } else if (binding.mutated && // TODO could be more fine-grained - not every mention in the template implies a state binding
        (state.reactive_statement || state.ast_type === "template")) {
          binding.kind = "state";
        } else if (state.reactive_statement && parent.type === "AssignmentExpression" && parent.left === binding.node) {
          binding.kind = "derived";
        } else {
          let idx = -1;
          let ancestor = path.at(idx);
          while (ancestor) {
            if (ancestor.type === "EachBlock") {
              if (ancestor.expression === (idx === -1 ? node : path.at(idx + 1))) {
                binding.kind = "state";
                break;
              }
            }
            ancestor = path.at(--idx);
          }
        }
      }
    }
  },
  ExportNamedDeclaration(node, { next: next2, state }) {
    if (state.ast_type !== "instance") {
      return next2();
    }
    if (!node.declaration) {
      for (const specifier of node.specifiers) {
        const binding = (
          /** @type {import('#compiler').Binding} */
          state.scope.get(specifier.local.name)
        );
        if (binding.kind === "state" || binding.kind === "normal" && binding.declaration_kind === "let") {
          binding.kind = "prop";
          if (specifier.exported.name !== specifier.local.name) {
            binding.prop_alias = specifier.exported.name;
          }
        } else {
          state.analysis.exports.push({
            name: specifier.local.name,
            alias: specifier.exported.name
          });
        }
      }
      return next2();
    }
    if (node.declaration.type === "FunctionDeclaration") {
      state.analysis.exports.push({
        name: (
          /** @type {import('estree').Identifier} */
          node.declaration.id.name
        ),
        alias: null
      });
      return next2();
    }
    if (node.declaration.type === "VariableDeclaration") {
      if (node.declaration.kind === "const") {
        for (const declarator2 of node.declaration.declarations) {
          for (const node2 of extract_identifiers(declarator2.id)) {
            state.analysis.exports.push({ name: node2.name, alias: null });
          }
        }
        return next2();
      }
      for (const declarator2 of node.declaration.declarations) {
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = (
            /** @type {import('#compiler').Binding} */
            state.scope.get(id2.name)
          );
          binding.kind = "prop";
        }
      }
    }
  }
};
var runes_scope_js_tweaker = {
  VariableDeclarator(node, { state }) {
    if (node.init?.type !== "CallExpression")
      return;
    if (get_rune(node.init, state.scope) === null)
      return;
    const callee = node.init.callee;
    if (callee.type !== "Identifier")
      return;
    const name = callee.name;
    if (name !== "$state" && name !== "$derived")
      return;
    for (const path of extract_paths(node.id)) {
      const binding = (
        /** @type {import('#compiler').Binding} */
        state.scope.get(path.node.name)
      );
      binding.kind = name === "$state" ? "state" : "derived";
    }
  }
};
var runes_scope_tweaker = {
  VariableDeclarator(node, { state }) {
    if (node.init?.type !== "CallExpression")
      return;
    if (get_rune(node.init, state.scope) === null)
      return;
    const callee = node.init.callee;
    if (callee.type !== "Identifier")
      return;
    const name = callee.name;
    if (name !== "$state" && name !== "$derived" && name !== "$props")
      return;
    for (const path of extract_paths(node.id)) {
      const binding = (
        /** @type {import('#compiler').Binding} */
        state.scope.get(path.node.name)
      );
      binding.kind = name === "$state" ? "state" : name === "$derived" ? "derived" : path.is_rest ? "rest_prop" : "prop";
    }
    if (name === "$props") {
      for (
        const property of
        /** @type {import('estree').ObjectPattern} */
        node.id.properties
      ) {
        if (property.type !== "Property")
          continue;
        const name2 = property.value.type === "AssignmentPattern" ? (
          /** @type {import('estree').Identifier} */
          property.value.left.name
        ) : (
          /** @type {import('estree').Identifier} */
          property.value.name
        );
        const alias = property.key.type === "Identifier" ? property.key.name : (
          /** @type {string} */
          /** @type {import('estree').Literal} */
          property.key.value
        );
        const initial = property.value.type === "AssignmentPattern" ? property.value.right : null;
        const binding = (
          /** @type {import('#compiler').Binding} */
          state.scope.get(name2)
        );
        binding.prop_alias = alias;
        binding.initial = initial;
      }
    }
  },
  ExportSpecifier(node, { state }) {
    state.analysis.exports.push({
      name: node.local.name,
      alias: node.exported.name
    });
  },
  ExportNamedDeclaration(node, { next: next2, state }) {
    if (!node.declaration) {
      return next2();
    }
    if (node.declaration.type === "FunctionDeclaration") {
      state.analysis.exports.push({
        name: (
          /** @type {import('estree').Identifier} */
          node.declaration.id.name
        ),
        alias: null
      });
      return next2();
    }
    if (node.declaration.type === "VariableDeclaration" && node.declaration.kind === "const") {
      for (const declarator2 of node.declaration.declarations) {
        for (const node2 of extract_identifiers(declarator2.id)) {
          state.analysis.exports.push({ name: node2.name, alias: null });
        }
      }
    }
  }
};
function is_known_safe_call(node, context) {
  const callee = node.callee;
  if (callee.type === "MemberExpression" && callee.object.type === "Identifier") {
    const binding = context.state.scope.get(callee.object.name);
    const selector_binding = context.state.scope.get("selector");
    if (selector_binding !== null && selector_binding.declaration_kind === "import" && selector_binding.initial !== null && selector_binding.initial.type === "ImportDeclaration" && selector_binding.initial.source.value === "svelte" && binding !== null && binding.initial !== null && binding.initial.type === "CallExpression" && binding.initial.callee.type === "Identifier" && binding.initial.callee.name === "selector") {
      return true;
    }
  }
  if (callee.type === "Identifier") {
    const name = callee.name;
    const binding = context.state.scope.get(name);
    if (binding === null && (name === "BigInt" || name === "String" || name === "Number" || name === "Boolean")) {
      return true;
    }
  }
  return false;
}
var common_visitors = {
  Attribute(node, context) {
    if (node.value === true)
      return;
    context.next();
    node.metadata.dynamic = node.value.some(
      (chunk) => chunk.type === "ExpressionTag" && chunk.metadata.dynamic
    );
  },
  ClassDirective(node, context) {
    context.next({ ...context.state, expression: node });
  },
  SpreadAttribute(node, context) {
    context.next({ ...context.state, expression: node });
  },
  SlotElement(node, context) {
    let name = "default";
    for (const attr of node.attributes) {
      if (attr.type === "Attribute" && attr.name === "name" && is_text_attribute(attr)) {
        name = attr.value[0].data;
        break;
      }
    }
    context.state.analysis.slot_names.add(name);
  },
  StyleDirective(node, context) {
    if (node.value === true) {
      const binding = context.state.scope.get(node.name);
      if (binding?.kind !== "normal") {
        node.metadata.dynamic = true;
      }
    } else {
      context.next();
      node.metadata.dynamic = node.value.some(
        (node2) => node2.type === "ExpressionTag" && node2.metadata.dynamic
      );
    }
  },
  ExpressionTag(node, context) {
    context.next({ ...context.state, expression: node });
  },
  Identifier(node, context) {
    const parent = (
      /** @type {import('estree').Node} */
      context.path.at(-1)
    );
    if (!is_reference(node, parent))
      return;
    const binding = context.state.scope.get(node.name);
    if (binding && binding.kind !== "normal") {
      if (context.state.expression) {
        context.state.expression.metadata.dynamic = true;
      }
    }
  },
  CallExpression(node, context) {
    if (context.state.expression?.type === "ExpressionTag" && !is_known_safe_call(node, context)) {
      context.state.expression.metadata.contains_call_expression = true;
    }
    const callee = node.callee;
    if (callee.type === "Identifier") {
      const binding = context.state.scope.get(callee.name);
      if (binding !== null) {
        binding.is_called = true;
      }
    }
    context.next();
  },
  MemberExpression(node, context) {
    if (context.state.expression) {
      context.state.expression.metadata.dynamic = true;
    }
    context.next();
  },
  BindDirective(node, context) {
    let i = context.path.length;
    while (i--) {
      const parent = context.path[i];
      if (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf") {
        context.state.analysis.uses_component_bindings = true;
        break;
      } else if (is_element_node(parent)) {
        break;
      }
    }
    if (node.name !== "group")
      return;
    i = context.path.length;
    while (i--) {
      const parent = context.path[i];
      if (parent.type === "EachBlock") {
        parent.metadata.contains_group_binding = true;
        for (const binding2 of parent.metadata.references) {
          binding2.mutated = true;
        }
      }
    }
    const id2 = object2(node.expression);
    const binding = id2 === null ? null : context.state.scope.get(id2.name);
    ok(binding);
    let group = context.state.analysis.binding_groups.get(binding);
    if (!group) {
      group = {
        name: context.state.scope.root.unique("binding_group"),
        directives: []
      };
      context.state.analysis.binding_groups.set(binding, group);
    }
    group.directives.push(node);
    node.metadata = {
      binding_group_name: group.name,
      parent_each_blocks: (
        /** @type {import('#compiler').EachBlock[]} */
        context.path.filter((p) => p.type === "EachBlock")
      )
    };
  },
  OnDirective(node, context) {
    node.metadata = { delegated: null };
    context.next();
    const delegated_event = get_delegated_event(node, context);
    if (delegated_event !== null) {
      if (delegated_event.type === "hoistable") {
        delegated_event.function.metadata.hoistable = true;
      }
      node.metadata.delegated = delegated_event;
    }
  },
  ArrowFunctionExpression(node, context) {
    node.metadata = {
      hoistable: false,
      hoistable_params: [],
      scope: context.state.scope
    };
  },
  FunctionExpression(node, context) {
    node.metadata = {
      hoistable: false,
      hoistable_params: [],
      scope: context.state.scope
    };
  },
  FunctionDeclaration(node, context) {
    node.metadata = {
      hoistable: false,
      hoistable_params: [],
      scope: context.state.scope
    };
  },
  RegularElement(node, context) {
    if (context.state.analysis.namespace !== "foreign" && node.name === "textarea" && node.fragment.nodes.length > 0) {
      if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== "Text") {
        const first = node.fragment.nodes[0];
        if (first.type === "Text") {
          first.data = first.data.replace(regex_starts_with_newline, "");
          first.raw = first.raw.replace(regex_starts_with_newline, "");
        }
        node.attributes.push(
          create_attribute(
            "value",
            /** @type {import('#compiler').Text} */
            node.fragment.nodes.at(0).start,
            /** @type {import('#compiler').Text} */
            node.fragment.nodes.at(-1).end,
            // @ts-ignore
            node.fragment.nodes
          )
        );
        node.fragment.nodes = [];
      }
    }
    if (context.state.analysis.namespace !== "foreign" && node.name === "option" && node.fragment.nodes?.length === 1 && node.fragment.nodes[0].type === "ExpressionTag" && !node.attributes.some(
      (attribute) => attribute.type === "Attribute" && attribute.name === "value"
    )) {
      const child = node.fragment.nodes[0];
      node.attributes.push(create_attribute("value", child.start, child.end, [child]));
    }
    context.state.analysis.elements.push(node);
  },
  SvelteElement(node, { state }) {
    state.analysis.elements.push(node);
  }
};
function order_reactive_statements(unsorted_reactive_declarations) {
  const lookup = /* @__PURE__ */ new Map();
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    declaration2.assignments.forEach(({ name }) => {
      const statements = lookup.get(name) ?? [];
      statements.push([node, declaration2]);
      lookup.set(name, statements);
    });
  }
  const edges = [];
  for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) {
    for (const { name } of assignments) {
      for (const { node } of dependencies) {
        if (![...assignments].find(({ name: name2 }) => node.name === name2)) {
          edges.push([name, node.name]);
        }
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle?.length) {
    const declaration2 = (
      /** @type {Tuple[]} */
      lookup.get(cycle[0])[0]
    );
    error(declaration2[0], "cyclical-reactive-declaration", cycle);
  }
  const reactive_declarations = /* @__PURE__ */ new Map();
  const add_declaration = (node, declaration2) => {
    if ([...reactive_declarations.values()].includes(declaration2))
      return;
    declaration2.dependencies.forEach(({ node: { name } }) => {
      if ([...declaration2.assignments].some((a) => a.name === name))
        return;
      for (const [node2, earlier] of lookup.get(name) ?? []) {
        add_declaration(node2, earlier);
      }
    });
    reactive_declarations.set(node, declaration2);
  };
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    add_declaration(node, declaration2);
  }
  return reactive_declarations;
}

// ../../node_modules/.pnpm/esrap@1.0.2/node_modules/esrap/src/handlers.js
function push_array2(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}
function handle(node, state) {
  const handler = handlers[node.type];
  if (!handler) {
    throw new Error(`Not implemented ${node.type}`);
  }
  const result = handler(node, state);
  if (node.leadingComments) {
    result.unshift(
      c(
        node.leadingComments.map(
          (comment) => comment.type === "Block" ? `/*${comment.value}*/${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment.value}${/** @type {any} */
          comment.has_trailing_newline ? `
${state.indent}` : ` `}`
        ).join(``)
      )
    );
  }
  if (node.trailingComments) {
    state.comments.push(node.trailingComments[0]);
  }
  return result;
}
function c(content, node) {
  return {
    content,
    loc: node?.loc ?? null,
    has_newline: /\n/.test(content)
  };
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  MetaProperty: 19,
  CallExpression: 19,
  ChainExpression: 19,
  ImportExpression: 19,
  NewExpression: 19,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node, parent, is_right) {
  if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {import('estree').BinaryExpression} */
    node.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {import('estree').BinaryExpression} */
      node.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {import('estree').BinaryExpression} */
    node.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node) {
  while (node) {
    if (node.type[0] === "CallExpression") {
      return true;
    } else if (node.type === "MemberExpression") {
      node = node.object;
    } else {
      return false;
    }
  }
}
var has_newline = (chunks) => {
  for (let i = 0; i < chunks.length; i += 1) {
    if (chunks[i].has_newline)
      return true;
  }
  return false;
};
var get_length = (chunks) => {
  let total = 0;
  for (let i = 0; i < chunks.length; i += 1) {
    total += chunks[i].content.length;
  }
  return total;
};
var sum = (a, b) => a + b;
var join = (nodes, separator) => {
  if (nodes.length === 0)
    return [];
  const joined = [...nodes[0]];
  for (let i = 1; i < nodes.length; i += 1) {
    joined.push(separator);
    push_array2(joined, nodes[i]);
  }
  return joined;
};
var handle_body = (nodes, state) => {
  const chunks = [];
  const body = nodes.filter((statement) => statement.type !== "EmptyStatement").map((statement) => {
    const chunks2 = handle(statement, {
      ...state,
      indent: state.indent
    });
    let add_newline = false;
    while (state.comments.length) {
      const comment = (
        /** @type {import('estree').Comment} */
        state.comments.shift()
      );
      const prefix = add_newline ? `
${state.indent}` : ` `;
      chunks2.push(
        c(
          comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`
        )
      );
      add_newline = comment.type === "Line";
    }
    return chunks2;
  });
  let needed_padding = false;
  for (let i = 0; i < body.length; i += 1) {
    const needs_padding = has_newline(body[i]);
    if (i > 0) {
      chunks.push(c(needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`));
    }
    push_array2(chunks, body[i]);
    needed_padding = needs_padding;
  }
  return chunks;
};
var handle_var_declaration = (node, state) => {
  const chunks = [c(`${node.kind} `)];
  const declarators = node.declarations.map(
    (d) => handle(d, {
      ...state,
      indent: state.indent + (node.declarations.length === 1 ? "" : "	")
    })
  );
  const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
  const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
  push_array2(chunks, join(declarators, separator));
  return chunks;
};
var shared = {
  /**
   * @param {import('estree').ArrayExpression | import('estree').ArrayPattern} node
   * @param {import('./types').State} state
   */
  "ArrayExpression|ArrayPattern": (node, state) => {
    const chunks = [c("[")];
    const elements2 = [];
    let sparse_commas = [];
    for (let i = 0; i < node.elements.length; i += 1) {
      const element = node.elements[i];
      if (element) {
        elements2.push([
          ...sparse_commas,
          ...handle(element, {
            ...state,
            indent: state.indent + "	"
          })
        ]);
        sparse_commas = [];
      } else {
        sparse_commas.push(c(","));
      }
    }
    const multiple_lines = elements2.some(has_newline) || elements2.map(get_length).reduce(sum, 0) + (state.indent.length + elements2.length - 1) * 2 > 80;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array2(chunks, join(elements2, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent}`));
      push_array2(chunks, sparse_commas);
    } else {
      push_array2(chunks, join(elements2, c(", ")));
      push_array2(chunks, sparse_commas);
    }
    chunks.push(c("]"));
    return chunks;
  },
  /**
   * @param {import('estree').BinaryExpression | import('estree').LogicalExpression} node
   * @param {import('./types').State} state
   */
  "BinaryExpression|LogicalExpression": (node, state) => {
    const chunks = [];
    if (needs_parens(node.left, node, false)) {
      chunks.push(c("("));
      push_array2(chunks, handle(node.left, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.left, state));
    }
    chunks.push(c(` ${node.operator} `));
    if (needs_parens(node.right, node, true)) {
      chunks.push(c("("));
      push_array2(chunks, handle(node.right, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.right, state));
    }
    return chunks;
  },
  /**
   * @param {import('estree').BlockStatement | import('estree').ClassBody} node
   * @param {import('./types').State} state
   */
  "BlockStatement|ClassBody": (node, state) => {
    if (node.body.length === 0)
      return [c("{}")];
    return [
      c(`{
${state.indent}	`),
      ...handle_body(node.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  },
  /**
   * @param {import('estree').ClassDeclaration | import('estree').ClassExpression} node
   * @param {import('./types').State} state
   */
  "ClassDeclaration|ClassExpression": (node, state) => {
    const chunks = [c("class ")];
    if (node.id) {
      push_array2(chunks, handle(node.id, state));
      chunks.push(c(" "));
    }
    if (node.superClass) {
      chunks.push(c("extends "));
      push_array2(chunks, handle(node.superClass, state));
      chunks.push(c(" "));
    }
    push_array2(chunks, handle(node.body, state));
    return chunks;
  },
  /**
   * @param {import('estree').ForInStatement | import('estree').ForOfStatement} node
   * @param {import('./types').State} state
   */
  "ForInStatement|ForOfStatement": (node, state) => {
    const chunks = [c(`for ${node.type === "ForOfStatement" && node.await ? "await " : ""}(`)];
    if (node.left.type === "VariableDeclaration") {
      push_array2(chunks, handle_var_declaration(node.left, state));
    } else {
      push_array2(chunks, handle(node.left, state));
    }
    chunks.push(c(node.type === "ForInStatement" ? ` in ` : ` of `));
    push_array2(chunks, handle(node.right, state));
    chunks.push(c(") "));
    push_array2(chunks, handle(node.body, state));
    return chunks;
  },
  /**
   * @param {import('estree').FunctionDeclaration | import('estree').FunctionExpression} node
   * @param {import('./types').State} state
   */
  "FunctionDeclaration|FunctionExpression": (node, state) => {
    const chunks = [];
    if (node.async)
      chunks.push(c("async "));
    chunks.push(c(node.generator ? "function* " : "function "));
    if (node.id)
      push_array2(chunks, handle(node.id, state));
    chunks.push(c("("));
    const params = node.params.map(
      (p) => handle(p, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
    const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array2(chunks, join(params, separator));
      chunks.push(c(`
${state.indent}`));
    } else {
      push_array2(chunks, join(params, separator));
    }
    chunks.push(c(") "));
    push_array2(chunks, handle(node.body, state));
    return chunks;
  },
  /**
   * @param {import('estree').RestElement | import('estree').SpreadElement} node
   * @param {import('./types').State} state
   */
  "RestElement|SpreadElement": (node, state) => {
    return [c("..."), ...handle(node.argument, state)];
  }
};
var handlers = {
  ArrayExpression: shared["ArrayExpression|ArrayPattern"],
  ArrayPattern: shared["ArrayExpression|ArrayPattern"],
  ArrowFunctionExpression: (node, state) => {
    const chunks = [];
    if (node.async)
      chunks.push(c("async "));
    if (node.params.length === 1 && node.params[0].type === "Identifier") {
      push_array2(chunks, handle(node.params[0], state));
    } else {
      const params = node.params.map(
        (param) => handle(param, {
          ...state,
          indent: state.indent + "	"
        })
      );
      chunks.push(c("("));
      push_array2(chunks, join(params, c(", ")));
      chunks.push(c(")"));
    }
    chunks.push(c(" => "));
    if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern") {
      chunks.push(c("("));
      push_array2(chunks, handle(node.body, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.body, state));
    }
    return chunks;
  },
  AssignmentExpression(node, state) {
    return [...handle(node.left, state), c(` ${node.operator} `), ...handle(node.right, state)];
  },
  AssignmentPattern(node, state) {
    return [...handle(node.left, state), c(` = `), ...handle(node.right, state)];
  },
  AwaitExpression(node, state) {
    if (node.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        return [c("await ("), ...handle(node.argument, state), c(")")];
      } else {
        return [c("await "), ...handle(node.argument, state)];
      }
    }
    return [c("await")];
  },
  BinaryExpression: shared["BinaryExpression|LogicalExpression"],
  BlockStatement: shared["BlockStatement|ClassBody"],
  BreakStatement(node, state) {
    return node.label ? [c("break "), ...handle(node.label, state), c(";")] : [c("break;")];
  },
  CallExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
      chunks.push(c("("));
      push_array2(chunks, handle(node.callee, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.callee, state));
    }
    if (
      /** @type {import('estree').SimpleCallExpression} */
      node.optional
    ) {
      chunks.push(c("?."));
    }
    let has_inline_comment = false;
    let arg_chunks = [];
    outer:
      for (const arg of node.arguments) {
        const chunks2 = [];
        while (state.comments.length) {
          const comment = (
            /** @type {import('estree').Comment} */
            state.comments.shift()
          );
          if (comment.type === "Line") {
            has_inline_comment = true;
            break outer;
          }
          chunks2.push(c(comment.type === "Block" ? `/*${comment.value}*/ ` : `//${comment.value}`));
        }
        push_array2(chunks2, handle(arg, state));
        arg_chunks.push(chunks2);
      }
    const multiple_lines = has_inline_comment || arg_chunks.slice(0, -1).some(has_newline);
    if (multiple_lines) {
      const args = node.arguments.map((arg, i) => {
        const chunks2 = handle(arg, {
          ...state,
          indent: `${state.indent}	`
        });
        if (i < node.arguments.length - 1)
          chunks2.push(c(","));
        while (state.comments.length) {
          const comment = (
            /** @type {import('estree').Comment} */
            state.comments.shift()
          );
          chunks2.push(
            c(comment.type === "Block" ? ` /*${comment.value}*/ ` : ` //${comment.value}`)
          );
        }
        return chunks2;
      });
      chunks.push(c(`(
${state.indent}	`));
      push_array2(chunks, join(args, c(`
${state.indent}	`)));
      chunks.push(c(`
${state.indent})`));
    } else {
      chunks.push(c("("));
      push_array2(chunks, join(arg_chunks, c(", ")));
      chunks.push(c(")"));
    }
    return chunks;
  },
  ChainExpression(node, state) {
    return handle(node.expression, state);
  },
  ClassBody: shared["BlockStatement|ClassBody"],
  ClassDeclaration: shared["ClassDeclaration|ClassExpression"],
  ClassExpression: shared["ClassDeclaration|ClassExpression"],
  ConditionalExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      push_array2(chunks, handle(node.test, state));
    } else {
      chunks.push(c("("));
      push_array2(chunks, handle(node.test, state));
      chunks.push(c(")"));
    }
    const child_state = { ...state, indent: state.indent + "	" };
    const consequent = handle(node.consequent, child_state);
    const alternate = handle(node.alternate, child_state);
    const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}? `));
      push_array2(chunks, consequent);
      chunks.push(c(`
${state.indent}: `));
      push_array2(chunks, alternate);
    } else {
      chunks.push(c(` ? `));
      push_array2(chunks, consequent);
      chunks.push(c(` : `));
      push_array2(chunks, alternate);
    }
    return chunks;
  },
  ContinueStatement(node, state) {
    return node.label ? [c("continue "), ...handle(node.label, state), c(";")] : [c("continue;")];
  },
  DebuggerStatement(node, state) {
    return [c("debugger", node), c(";")];
  },
  DoWhileStatement(node, state) {
    return [
      c("do "),
      ...handle(node.body, state),
      c(" while ("),
      ...handle(node.test, state),
      c(");")
    ];
  },
  EmptyStatement(node, state) {
    return [c(";")];
  },
  ExportAllDeclaration(node, state) {
    return [c(`export * from `), ...handle(node.source, state), c(`;`)];
  },
  ExportDefaultDeclaration(node, state) {
    const chunks = [c(`export default `), ...handle(node.declaration, state)];
    if (node.declaration.type !== "FunctionDeclaration") {
      chunks.push(c(";"));
    }
    return chunks;
  },
  ExportNamedDeclaration(node, state) {
    const chunks = [c("export ")];
    if (node.declaration) {
      push_array2(chunks, handle(node.declaration, state));
    } else {
      const specifiers = node.specifiers.map((specifier) => {
        const name = handle(specifier.local, state)[0];
        const as = handle(specifier.exported, state)[0];
        if (name.content === as.content) {
          return [name];
        }
        return [name, c(" as "), as];
      });
      const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
      if (width > 80) {
        chunks.push(c("{\n	"));
        push_array2(chunks, join(specifiers, c(",\n	")));
        chunks.push(c("\n}"));
      } else {
        chunks.push(c("{ "));
        push_array2(chunks, join(specifiers, c(", ")));
        chunks.push(c(" }"));
      }
      if (node.source) {
        chunks.push(c(" from "));
        push_array2(chunks, handle(node.source, state));
      }
    }
    chunks.push(c(";"));
    return chunks;
  },
  ExpressionStatement(node, state) {
    if (node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern") {
      return [c("("), ...handle(node.expression, state), c(");")];
    }
    return [...handle(node.expression, state), c(";")];
  },
  ForStatement: (node, state) => {
    const chunks = [c("for (")];
    if (node.init) {
      if (node.init.type === "VariableDeclaration") {
        push_array2(chunks, handle_var_declaration(node.init, state));
      } else {
        push_array2(chunks, handle(node.init, state));
      }
    }
    chunks.push(c("; "));
    if (node.test)
      push_array2(chunks, handle(node.test, state));
    chunks.push(c("; "));
    if (node.update)
      push_array2(chunks, handle(node.update, state));
    chunks.push(c(") "));
    push_array2(chunks, handle(node.body, state));
    return chunks;
  },
  ForInStatement: shared["ForInStatement|ForOfStatement"],
  ForOfStatement: shared["ForInStatement|ForOfStatement"],
  FunctionDeclaration: shared["FunctionDeclaration|FunctionExpression"],
  FunctionExpression: shared["FunctionDeclaration|FunctionExpression"],
  Identifier(node) {
    let name = node.name;
    return [c(name, node)];
  },
  IfStatement(node, state) {
    const chunks = [
      c("if ("),
      ...handle(node.test, state),
      c(") "),
      ...handle(node.consequent, state)
    ];
    if (node.alternate) {
      chunks.push(c(" else "));
      push_array2(chunks, handle(node.alternate, state));
    }
    return chunks;
  },
  ImportDeclaration(node, state) {
    const chunks = [c("import ")];
    const { length } = node.specifiers;
    const source = handle(node.source, state);
    if (length > 0) {
      let i = 0;
      while (i < length) {
        if (i > 0) {
          chunks.push(c(", "));
        }
        const specifier = node.specifiers[i];
        if (specifier.type === "ImportDefaultSpecifier") {
          chunks.push(c(specifier.local.name, specifier));
          i += 1;
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          chunks.push(c("* as " + specifier.local.name, specifier));
          i += 1;
        } else {
          break;
        }
      }
      if (i < length) {
        const specifiers = (
          /** @type {import('estree').ImportSpecifier[]} */
          node.specifiers.slice(i).map((specifier) => {
            const name = handle(specifier.imported, state)[0];
            const as = handle(specifier.local, state)[0];
            if (name.content === as.content) {
              return [as];
            }
            return [name, c(" as "), as];
          })
        );
        const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
        if (width > 80) {
          chunks.push(c(`{
	`));
          push_array2(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c(`{ `));
          push_array2(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
      }
      chunks.push(c(" from "));
    }
    push_array2(chunks, source);
    chunks.push(c(";"));
    return chunks;
  },
  ImportExpression(node, state) {
    return [c("import("), ...handle(node.source, state), c(")")];
  },
  LabeledStatement(node, state) {
    return [...handle(node.label, state), c(": "), ...handle(node.body, state)];
  },
  Literal(node, state) {
    if (typeof node.value === "string") {
      return [
        // TODO do we need to handle weird unicode characters somehow?
        // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
        c(node.raw || JSON.stringify(node.value), node)
      ];
    }
    return [c(node.raw || String(node.value), node)];
  },
  LogicalExpression: shared["BinaryExpression|LogicalExpression"],
  MemberExpression(node, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      chunks.push(c("("));
      push_array2(chunks, handle(node.object, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.object, state));
    }
    if (node.computed) {
      if (node.optional) {
        chunks.push(c("?."));
      }
      chunks.push(c("["));
      push_array2(chunks, handle(node.property, state));
      chunks.push(c("]"));
    } else {
      chunks.push(c(node.optional ? "?." : "."));
      push_array2(chunks, handle(node.property, state));
    }
    return chunks;
  },
  MetaProperty(node, state) {
    return [...handle(node.meta, state), c("."), ...handle(node.property, state)];
  },
  MethodDefinition(node, state) {
    const chunks = [];
    if (node.static) {
      chunks.push(c("static "));
    }
    if (node.kind === "get" || node.kind === "set") {
      chunks.push(c(node.kind + " "));
    }
    if (node.value.async) {
      chunks.push(c("async "));
    }
    if (node.value.generator) {
      chunks.push(c("*"));
    }
    if (node.computed) {
      chunks.push(c("["));
      push_array2(chunks, handle(node.key, state));
      chunks.push(c("]"));
    } else {
      push_array2(chunks, handle(node.key, state));
    }
    chunks.push(c("("));
    const { params } = node.value;
    for (let i = 0; i < params.length; i += 1) {
      push_array2(chunks, handle(params[i], state));
      if (i < params.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(") "));
    push_array2(chunks, handle(node.value.body, state));
    return chunks;
  },
  NewExpression(node, state) {
    const chunks = [c("new ")];
    if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node.callee)) {
      chunks.push(c("("));
      push_array2(chunks, handle(node.callee, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.callee, state));
    }
    const args = node.arguments.map(
      (arg) => handle(arg, {
        ...state,
        indent: state.indent + "	"
      })
    );
    const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
    chunks.push(c("("));
    push_array2(chunks, join(args, separator));
    chunks.push(c(")"));
    return chunks;
  },
  ObjectExpression(node, state) {
    if (node.properties.length === 0) {
      return [c("{}")];
    }
    let has_inline_comment = false;
    const chunks = [];
    const separator = c(", ");
    node.properties.forEach((p, i) => {
      push_array2(
        chunks,
        handle(p, {
          ...state,
          indent: state.indent + "	"
        })
      );
      if (state.comments.length) {
        chunks.push(c(", "));
        while (state.comments.length) {
          const comment = (
            /** @type {import('estree').Comment} */
            state.comments.shift()
          );
          chunks.push(
            c(
              comment.type === "Block" ? `/*${comment.value}*/
${state.indent}	` : `//${comment.value}
${state.indent}	`
            )
          );
          if (comment.type === "Line") {
            has_inline_comment = true;
          }
        }
      } else {
        if (i < node.properties.length - 1) {
          chunks.push(separator);
        }
      }
    });
    const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
    if (multiple_lines) {
      separator.content = `,
${state.indent}	`;
    }
    return [
      c(multiple_lines ? `{
${state.indent}	` : `{ `),
      ...chunks,
      c(multiple_lines ? `
${state.indent}}` : ` }`)
    ];
  },
  ObjectPattern(node, state) {
    const chunks = [c("{ ")];
    for (let i = 0; i < node.properties.length; i += 1) {
      push_array2(chunks, handle(node.properties[i], state));
      if (i < node.properties.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(" }"));
    return chunks;
  },
  // @ts-expect-error this isn't a real node type, but Acorn produces it
  ParenthesizedExpression(node, state) {
    return handle(node.expression, state);
  },
  PrivateIdentifier(node, state) {
    const chunks = [c("#")];
    push_array2(chunks, [c(node.name, node)]);
    return chunks;
  },
  Program(node, state) {
    return handle_body(node.body, state);
  },
  Property(node, state) {
    const value = handle(node.value, state);
    if (node.key === node.value) {
      return value;
    }
    if (!node.computed && node.value.type === "AssignmentPattern" && node.value.left.type === "Identifier" && node.key.type === "Identifier" && node.value.left.name === node.key.name) {
      return value;
    }
    if (!node.computed && node.value.type === "Identifier" && (node.key.type === "Identifier" && node.key.name === value[0].content || node.key.type === "Literal" && node.key.value === value[0].content)) {
      return value;
    }
    const key2 = handle(node.key, state);
    if (node.value.type === "FunctionExpression" && !node.value.id) {
      const chunks = node.kind !== "init" ? [c(`${node.kind} `)] : [];
      if (node.value.async) {
        chunks.push(c("async "));
      }
      if (node.value.generator) {
        chunks.push(c("*"));
      }
      push_array2(chunks, node.computed ? [c("["), ...key2, c("]")] : key2);
      chunks.push(c("("));
      push_array2(
        chunks,
        join(
          node.value.params.map((param) => handle(param, state)),
          c(", ")
        )
      );
      chunks.push(c(") "));
      push_array2(chunks, handle(node.value.body, state));
      return chunks;
    }
    if (node.computed) {
      return [c("["), ...key2, c("]: "), ...value];
    }
    return [...key2, c(": "), ...value];
  },
  PropertyDefinition(node, state) {
    const chunks = [];
    if (node.static) {
      chunks.push(c("static "));
    }
    if (node.computed) {
      chunks.push(c("["), ...handle(node.key, state), c("]"));
    } else {
      chunks.push(...handle(node.key, state));
    }
    if (node.value) {
      chunks.push(c(" = "));
      chunks.push(...handle(node.value, state));
    }
    chunks.push(c(";"));
    return chunks;
  },
  RestElement: shared["RestElement|SpreadElement"],
  ReturnStatement(node, state) {
    if (node.argument) {
      const contains_comment = node.argument.leadingComments && node.argument.leadingComments.some(
        (comment) => comment.has_trailing_newline
      );
      return [
        c(contains_comment ? "return (" : "return "),
        ...handle(node.argument, state),
        c(contains_comment ? ");" : ";")
      ];
    } else {
      return [c("return;")];
    }
  },
  SequenceExpression(node, state) {
    const expressions = node.expressions.map((e) => handle(e, state));
    return [c("("), ...join(expressions, c(", ")), c(")")];
  },
  SpreadElement: shared["RestElement|SpreadElement"],
  StaticBlock(node, state) {
    return [
      c("static "),
      c(`{
${state.indent}	`),
      ...handle_body(node.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  },
  Super(node, state) {
    return [c("super", node)];
  },
  SwitchStatement(node, state) {
    const chunks = [c("switch ("), ...handle(node.discriminant, state), c(") {")];
    node.cases.forEach((block2) => {
      if (block2.test) {
        chunks.push(c(`
${state.indent}	case `));
        push_array2(chunks, handle(block2.test, { ...state, indent: `${state.indent}	` }));
        chunks.push(c(":"));
      } else {
        chunks.push(c(`
${state.indent}	default:`));
      }
      block2.consequent.forEach((statement) => {
        chunks.push(c(`
${state.indent}		`));
        push_array2(chunks, handle(statement, { ...state, indent: `${state.indent}		` }));
      });
    });
    chunks.push(c(`
${state.indent}}`));
    return chunks;
  },
  TaggedTemplateExpression(node, state) {
    return handle(node.tag, state).concat(handle(node.quasi, state));
  },
  TemplateLiteral(node, state) {
    const chunks = [c("`")];
    const { quasis, expressions } = node;
    for (let i = 0; i < expressions.length; i++) {
      chunks.push(c(quasis[i].value.raw), c("${"));
      push_array2(chunks, handle(expressions[i], state));
      chunks.push(c("}"));
    }
    chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
    return chunks;
  },
  ThisExpression(node, state) {
    return [c("this", node)];
  },
  ThrowStatement(node, state) {
    return [c("throw "), ...handle(node.argument, state), c(";")];
  },
  TryStatement(node, state) {
    const chunks = [c("try "), ...handle(node.block, state)];
    if (node.handler) {
      if (node.handler.param) {
        chunks.push(c(" catch("));
        push_array2(chunks, handle(node.handler.param, state));
        chunks.push(c(") "));
      } else {
        chunks.push(c(" catch "));
      }
      push_array2(chunks, handle(node.handler.body, state));
    }
    if (node.finalizer) {
      chunks.push(c(" finally "));
      push_array2(chunks, handle(node.finalizer, state));
    }
    return chunks;
  },
  UnaryExpression(node, state) {
    const chunks = [c(node.operator)];
    if (node.operator.length > 1) {
      chunks.push(c(" "));
    }
    if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      chunks.push(c("("));
      push_array2(chunks, handle(node.argument, state));
      chunks.push(c(")"));
    } else {
      push_array2(chunks, handle(node.argument, state));
    }
    return chunks;
  },
  UpdateExpression(node, state) {
    return node.prefix ? [c(node.operator), ...handle(node.argument, state)] : [...handle(node.argument, state), c(node.operator)];
  },
  VariableDeclaration(node, state) {
    return handle_var_declaration(node, state).concat(c(";"));
  },
  VariableDeclarator(node, state) {
    if (node.init) {
      return [...handle(node.id, state), c(" = "), ...handle(node.init, state)];
    } else {
      return handle(node.id, state);
    }
  },
  WhileStatement(node, state) {
    return [c("while ("), ...handle(node.test, state), c(") "), ...handle(node.body, state)];
  },
  WithStatement(node, state) {
    return [c("with ("), ...handle(node.object, state), c(") "), ...handle(node.body, state)];
  },
  YieldExpression(node, state) {
    if (node.argument) {
      return [c(node.delegate ? `yield* ` : `yield `), ...handle(node.argument, state)];
    }
    return [c(node.delegate ? `yield*` : `yield`)];
  }
};

// ../../node_modules/.pnpm/esrap@1.0.2/node_modules/esrap/src/index.js
var import_sourcemap_codec2 = __toESM(require_sourcemap_codec_umd(), 1);
var btoa2 = () => {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa2 = (str) => window.btoa(unescape(encodeURIComponent(str)));
} else if (typeof Buffer === "function") {
  btoa2 = (str) => Buffer.from(str, "utf-8").toString("base64");
}
function print(node, opts = {}) {
  if (Array.isArray(node)) {
    return print(
      {
        type: "Program",
        body: node,
        sourceType: "module"
      },
      opts
    );
  }
  const chunks = handle(node, {
    indent: "",
    comments: []
  });
  let code = "";
  let current_column = 0;
  let mappings = [];
  let current_line = [];
  for (let i = 0; i < chunks.length; i += 1) {
    const chunk = chunks[i];
    code += chunk.content;
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.start.line - 1,
        chunk.loc.start.column
      ]);
    }
    for (let i2 = 0; i2 < chunk.content.length; i2 += 1) {
      if (chunk.content[i2] === "\n") {
        mappings.push(current_line);
        current_line = [];
        current_column = 0;
      } else {
        current_column += 1;
      }
    }
    if (chunk.loc) {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        chunk.loc.end.line - 1,
        chunk.loc.end.column
      ]);
    }
  }
  mappings.push(current_line);
  const map = {
    version: 3,
    /** @type {string[]} */
    names: [],
    sources: [opts.sourceMapSource || null],
    sourcesContent: [opts.sourceMapContent || null],
    mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? (0, import_sourcemap_codec2.encode)(mappings) : mappings
  };
  Object.defineProperties(map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
      }
    }
  });
  return {
    code,
    map
  };
}

// src/compiler/phases/3-transform/ssr/ssr.js
function t_string(value) {
  return { type: "string", value };
}
function t_expression(value) {
  return { type: "expression", value };
}
function t_statement(value) {
  return { type: "statement", value };
}
function serialize_anchor(state) {
  const id2 = state.scope.root.unique("anchor");
  return [const_builder(id2, call("$.create_anchor", id("$$payload"))), id2];
}
function serialize_template(template2, out = id("out")) {
  let quasis = [];
  let expressions = [];
  const statements = [];
  const flush_payload = () => {
    statements.push(
      stmt(assignment("+=", member(id("$$payload"), out), template(quasis, expressions)))
    );
    quasis = [];
    expressions = [];
  };
  for (let i = 0; i < template2.length; i++) {
    const template_item = template2[i];
    if (template_item.type === "statement") {
      if (quasis.length !== 0) {
        flush_payload();
      }
      statements.push(template_item.value);
    } else {
      let last = quasis.at(-1);
      if (!last)
        quasis.push(last = quasi("", false));
      if (template_item.type === "string") {
        last.value.raw += sanitize_template_string(template_item.value);
      } else if (template_item.type === "expression") {
        const value = template_item.value;
        if (value.type === "TemplateLiteral") {
          last.value.raw += sanitize_template_string(value.quasis[0].value.raw);
          quasis.push(...value.quasis.slice(1));
          expressions.push(...value.expressions);
          continue;
        }
        expressions.push(value);
        quasis.push(quasi("", i + 1 === template2.length || template2[i + 1].type === "statement"));
      }
    }
  }
  if (quasis.length !== 0) {
    flush_payload();
  }
  return statements;
}
function sanitize_template_string(str) {
  return str.replace(/(`|\${|\\)/g, "\\$1");
}
function process_children(nodes, parent, { visit, state }) {
  let sequence2 = [];
  let did_flush = false;
  function flush_sequence(sequence3, final) {
    const is_single_flush = !did_flush && final;
    const escape_method = is_single_flush ? "$.escape_html_single_child" : "$.escape";
    did_flush = true;
    if (sequence3.length === 1) {
      const node = sequence3[0];
      if (node.type === "Text") {
        if (is_single_flush && parent.type === "RegularElement" && (parent.name === "script" || parent.name === "style")) {
          state.template.push(t_string(node.data));
        } else {
          state.template.push(t_string(escape_html(node.data)));
        }
        return;
      }
      if (node.type === "Comment") {
        state.template.push(t_string(`<!--${escape_html(node.data)}-->`));
        return;
      }
      if (node.type === "Anchor") {
        state.template.push(t_expression(node.id));
        return;
      }
      const expression = call(
        escape_method,
        /** @type {import('estree').Expression} */
        visit(node.expression)
      );
      state.template.push(t_expression(expression));
      return;
    }
    const quasis = [];
    const expressions = [];
    quasis.push(quasi("", false));
    for (let i = 0; i < sequence3.length; i++) {
      const node = sequence3[i];
      if (node.type === "Text" || node.type === "Comment") {
        let last = (
          /** @type {import('estree').TemplateElement} */
          quasis.at(-1)
        );
        last.value.raw += node.type === "Comment" ? `<!--${node.data}-->` : node.data;
      } else if (node.type === "Anchor") {
        expressions.push(node.id);
        quasis.push(quasi("", i + 1 === sequence3.length));
      } else {
        expressions.push(
          call(
            "$.escape",
            /** @type {import('estree').Expression} */
            visit(node.expression)
          )
        );
        quasis.push(quasi("", i + 1 === sequence3.length));
      }
    }
    state.template.push(t_expression(template(quasis, expressions)));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node.type === "Text" || node.type === "Comment" || node.type === "ExpressionTag" || node.type === "Anchor") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2, false);
        sequence2 = [];
      }
      visit(node, {
        ...state
      });
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2, true);
  }
}
function create_block(parent, nodes, context, anchor) {
  const body = [];
  const { hoisted, trimmed } = clean_nodes(
    parent,
    nodes,
    context.path,
    context.state.metadata.namespace,
    context.state.preserve_whitespace,
    context.state.analysis.preserve_comments,
    true
  );
  if (hoisted.length === 0 && trimmed.length === 0 && !anchor) {
    return [];
  }
  const state = {
    ...context.state,
    init: [],
    template: [],
    metadata: {
      namespace: context.state.metadata.namespace
    }
  };
  for (const node of hoisted) {
    context.visit(node, state);
  }
  process_children(anchor ? [anchor, ...trimmed, anchor] : trimmed, parent, {
    ...context,
    state
  });
  if (state.template.length > 0) {
    body.push(...state.init);
    body.push(...serialize_template(state.template));
  } else {
    body.push(...state.init);
  }
  return body;
}
function create_state_declarators(declarator2, scope, value) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, value)];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path) => {
      const value2 = path.expression?.(id(tmp));
      return declarator(path.node, value2);
    })
  ];
}
function serialize_get_binding(node, state) {
  const binding = state.scope.get(node.name);
  if (binding === null || node === binding.node) {
    return node;
  }
  if (binding.kind === "store_sub") {
    const store_id = id(node.name.slice(1));
    return call(
      state.analysis.dev ? "$.store_get_dev" : "$.store_get",
      id("$$store_subs"),
      literal2(node.name),
      serialize_get_binding(store_id, state)
    );
  }
  if (binding.expression) {
    return binding.expression;
  }
  return node;
}
function get_assignment_value(node, { state, visit }) {
  if (node.left.type === "Identifier") {
    const operator = node.operator;
    return operator === "=" ? (
      /** @type {import('estree').Expression} */
      visit(node.right)
    ) : (
      // turn something like x += 1 into x = x + 1
      binary(
        /** @type {import('estree').BinaryOperator} */
        operator.slice(0, -1),
        serialize_get_binding(node.left, state),
        /** @type {import('estree').Expression} */
        visit(node.right)
      )
    );
  } else {
    return (
      /** @type {import('estree').Expression} */
      visit(node.right)
    );
  }
}
function is_store_name(name) {
  return name[0] === "$" && /[A-Za-z_]/.test(name[1]);
}
function serialize_set_binding(node, context, fallback) {
  const { state, visit } = context;
  if (node.left.type === "ArrayPattern" || node.left.type === "ObjectPattern" || node.left.type === "RestElement") {
    const tmp_id = context.state.scope.generate("tmp");
    const original_assignments = [];
    const assignments = [];
    const paths = extract_paths(node.left);
    for (const path of paths) {
      const value2 = path.expression?.(id(tmp_id));
      const assignment2 = assignment("=", path.node, value2);
      original_assignments.push(assignment2);
      assignments.push(serialize_set_binding(assignment2, context, () => assignment2));
    }
    if (assignments.every((assignment2, i) => assignment2 === original_assignments[i])) {
      return fallback();
    }
    return call(
      thunk(
        block([
          const_builder(
            tmp_id,
            /** @type {import('estree').Expression} */
            visit(node.right)
          ),
          stmt(sequence(assignments)),
          return_builder(id(tmp_id))
        ])
      )
    );
  }
  if (node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
    error(node, "INTERNAL", `Unexpected assignment type ${node.left.type}`);
  }
  let left = node.left;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (left.type !== "Identifier") {
    return fallback();
  }
  const is_store = is_store_name(left.name);
  const left_name = is_store ? left.name.slice(1) : left.name;
  const binding = state.scope.get(left_name);
  if (!binding)
    return fallback();
  if (binding.mutation !== null) {
    return binding.mutation(node, context);
  }
  if (binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "each" && binding.kind !== "legacy_reactive" && !is_store) {
    return fallback();
  }
  const value = get_assignment_value(node, { state, visit });
  if (left === node.left) {
    if (is_store) {
      return call(
        "$.store_set",
        id(left_name),
        /** @type {import('estree').Expression} */
        visit(node.right)
      );
    }
    return fallback();
  } else if (is_store) {
    return call(
      "$.mutate_store",
      id("$$store_subs"),
      literal2(left.name),
      id(left_name),
      assignment(
        node.operator,
        /** @type {import('estree').Pattern} */
        visit(node.left),
        value
      )
    );
  }
  return fallback();
}
var global_visitors = {
  Identifier(node, { path, state }) {
    if (is_reference(
      node,
      /** @type {import('estree').Node} */
      path.at(-1)
    )) {
      return serialize_get_binding(node, state);
    }
  },
  AssignmentExpression(node, context) {
    return serialize_set_binding(node, context, context.next);
  },
  UpdateExpression(node, context) {
    const { state, next: next2 } = context;
    const argument = node.argument;
    if (argument.type === "Identifier") {
      const binding = state.scope.get(argument.name);
      const is_store = binding?.kind === "store_sub";
      const name = is_store ? argument.name.slice(1) : argument.name;
      if (is_store) {
        let fn = node.operator === "++" ? "$.increment" : "$.decrement";
        if (node.prefix)
          fn += "_pre";
        if (is_store) {
          fn += "_store";
          return call(fn, serialize_get_binding(id(name), state), call("$" + name));
        } else {
          return call(fn, id(name));
        }
      } else {
        return next2();
      }
    }
    return next2();
  },
  WhileStatement: loop_protect,
  DoWhileStatement: loop_protect,
  ForStatement: loop_protect
};
var javascript_visitors = {
  Program(node, { visit }) {
    return (
      /** @type {import('estree').Program} */
      {
        ...node,
        body: node.body.map((node2) => (
          /** @type {import('estree').Node} */
          visit(node2)
        ))
      }
    );
  },
  BlockStatement(node, { visit }) {
    return (
      /** @type {import('estree').BlockStatement} */
      {
        ...node,
        body: node.body.map((node2) => (
          /** @type {import('estree').Node} */
          visit(node2)
        ))
      }
    );
  }
};
var javascript_visitors_runes = {
  VariableDeclaration(node, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node.declarations) {
      const rune = get_rune(declarator2.init, state.scope);
      if (!rune) {
        declarations.push(
          /** @type {import('estree').VariableDeclarator} */
          visit(declarator2)
        );
        continue;
      }
      if (rune === "$props") {
        declarations.push(declarator(declarator2.id, id("$$props")));
        continue;
      }
      const args = (
        /** @type {import('estree').CallExpression} */
        declarator2.init.arguments
      );
      const value = args.length === 0 ? id("undefined") : (
        /** @type {import('estree').Expression} */
        visit(args[0])
      );
      if (declarator2.id.type === "Identifier") {
        declarations.push(declarator(declarator2.id, value));
        continue;
      }
      if (rune === "$derived") {
        declarations.push(
          declarator(
            /** @type {import('estree').Pattern} */
            visit(declarator2.id),
            value
          )
        );
        continue;
      }
      declarations.push(...create_state_declarators(declarator2, state.scope, value));
    }
    return {
      ...node,
      declarations
    };
  },
  ExpressionStatement(node, context) {
    const expression = node.expression;
    if (expression.type === "CallExpression") {
      const callee = expression.callee;
      if (callee.type === "Identifier" && callee.name === "$effect") {
        return empty2;
      }
      if (callee.type === "MemberExpression" && callee.object.type === "Identifier" && callee.object.name === "$effect") {
        return empty2;
      }
    }
    context.next();
  }
};
function serialize_attribute_value(attribute_value, context, trim_whitespace = false) {
  if (attribute_value === true) {
    return true_instance;
  }
  if (attribute_value.length === 0) {
    return literal2("");
  }
  if (attribute_value.length === 1) {
    const value = attribute_value[0];
    if (value.type === "Text") {
      let data2 = value.data;
      if (trim_whitespace) {
        data2 = data2.replace(regex_whitespaces_strict, " ").trim();
      }
      return literal2(escape_html(data2, true));
    } else {
      return (
        /** @type {import('estree').Expression} */
        context.visit(value.expression)
      );
    }
  }
  const quasis = [];
  const expressions = [];
  if (attribute_value[0].type !== "Text") {
    quasis.push(quasi("", false));
  }
  let i = 0;
  for (const node of attribute_value) {
    i++;
    if (node.type === "Text") {
      let data2 = node.data;
      if (trim_whitespace) {
        data2 = data2.replace(regex_whitespaces_strict, " ");
      }
      quasis.push(quasi(data2, i === attribute_value.length));
    } else {
      expressions.push(
        call(
          "$.stringify",
          /** @type {import('estree').Expression} */
          context.visit(node.expression)
        )
      );
      if (i === attribute_value.length) {
        quasis.push(quasi("", true));
      }
    }
  }
  return template(quasis, expressions);
}
function serialize_element_spread_attributes(attributes3, style_directives, class_directives, context) {
  const values = [];
  for (const attribute of attributes3) {
    if (attribute.type === "Attribute") {
      const name = attribute.name.toLowerCase();
      const value = serialize_attribute_value(
        attribute.value,
        context,
        WhitespaceInsensitiveAttributes.includes(name)
      );
      values.push(object([prop("init", literal2(name), value)]));
    } else {
      values.push(
        /** @type {import('estree').Expression} */
        context.visit(attribute)
      );
    }
  }
  const args = [array(values), literal2(context.state.analysis.stylesheet.id)];
  if (style_directives.length > 0 || class_directives.length > 0) {
    const styles = style_directives.map(
      (directive) => init(
        directive.name,
        directive.value === true ? id(directive.name) : serialize_attribute_value(directive.value, context, true)
      )
    );
    const expressions = class_directives.map(
      (directive) => conditional(directive.expression, literal2(directive.name), literal2(""))
    );
    const classes = expressions.length ? call(
      member(
        call(member(array(expressions), id("filter")), id("Boolean")),
        id("join")
      ),
      literal2(" ")
    ) : literal2("");
    args.push(
      object([
        init("styles", styles.length === 0 ? literal2(null) : object(styles)),
        init("classes", classes)
      ])
    );
  }
  context.state.template.push(t_expression(call("$.spread_attributes", ...args)));
}
function serialize_inline_component(node, component_name, context) {
  const props_and_spreads = [];
  const custom_css_props = [];
  const default_lets = [];
  const children = {};
  function push_prop(prop2) {
    const current2 = props_and_spreads.at(-1);
    const current_is_props = Array.isArray(current2);
    const props = current_is_props ? current2 : [];
    props.push(prop2);
    if (!current_is_props) {
      props_and_spreads.push(props);
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      default_lets.push(
        /** @type {import('estree').ExpressionStatement} */
        context.visit(attribute)
      );
    } else if (attribute.type === "SpreadAttribute") {
      props_and_spreads.push(
        /** @type {import('estree').Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      if (attribute.name === "slot")
        continue;
      if (attribute.name.startsWith("--")) {
        const value2 = serialize_attribute_value(attribute.value, context);
        custom_css_props.push(init(attribute.name, value2));
        continue;
      }
      const value = serialize_attribute_value(attribute.value, context);
      push_prop(prop("init", literal2(attribute.name), value));
    } else if (attribute.type === "BindDirective") {
      push_prop(
        get(attribute.name, [
          return_builder(
            /** @type {import('estree').Expression} */
            context.visit(attribute.expression)
          )
        ])
      );
      push_prop(
        set(attribute.name, [
          stmt(
            /** @type {import('estree').Expression} */
            context.visit(assignment("=", attribute.expression, id("$$value")))
          ),
          stmt(assignment("=", id("$$settled"), false_instance))
        ])
      );
    }
  }
  for (const child of node.fragment.nodes) {
    let slot_name = "default";
    if (is_element_node(child)) {
      const attribute = (
        /** @type {import('#compiler').Attribute | undefined} */
        child.attributes.find(
          (attribute2) => attribute2.type === "Attribute" && attribute2.name === "slot"
        )
      );
      if (attribute !== void 0) {
        slot_name = /** @type {import('#compiler').Text[]} */
        attribute.value[0].data;
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  const serialized_slots = [];
  for (const slot_name of Object.keys(children)) {
    const body = create_block(node, children[slot_name], context);
    if (body.length === 0)
      continue;
    const slot = prop(
      "init",
      literal2(slot_name),
      arrow(
        [id("$$payload"), id("$$slotProps")],
        block([...slot_name === "default" ? default_lets : [], ...body])
      )
    );
    serialized_slots.push(slot);
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {import('estree').Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p))
  );
  const events_expression = object([]);
  let component = (typeof component_name === "string" ? call : maybe_call)(
    component_name,
    id("$$payload"),
    props_expression,
    events_expression,
    // TODO just remove this from the SSR params?
    object(serialized_slots)
  );
  if (custom_css_props.length > 0) {
    component = call(
      "$.css_props",
      id("$$payload"),
      literal2(context.state.metadata.namespace === "svg" ? false : true),
      object(custom_css_props),
      thunk(component)
    );
  }
  return component;
}
function is_text_attribute2(attribute) {
  return attribute.value !== true && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
var javascript_visitors_legacy = {
  VariableDeclaration(node, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node.declarations) {
      const bindings2 = (
        /** @type {import('#compiler').Binding[]} */
        state.scope.get_bindings(declarator2)
      );
      const has_state = bindings2.some((binding) => binding.kind === "state");
      const has_props = bindings2.some((binding) => binding.kind === "prop");
      if (!has_state && !has_props) {
        declarations.push(
          /** @type {import('estree').VariableDeclarator} */
          visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(
              id(tmp),
              /** @type {import('estree').Expression} */
              visit(
                /** @type {import('estree').Expression} */
                declarator2.init
              )
            )
          );
          for (const path of paths) {
            const value = path.expression?.(id(tmp));
            const name = (
              /** @type {import('estree').Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {import('#compiler').Binding} */
              state.scope.get(name)
            );
            const prop3 = member(id("$$props"), literal2(binding2.prop_alias ?? name), true);
            declarations.push(declarator(path.node, call("$.value_or_fallback", prop3, value)));
          }
          continue;
        }
        const binding = (
          /** @type {import('#compiler').Binding} */
          state.scope.get(declarator2.id.name)
        );
        const prop2 = member(
          id("$$props"),
          literal2(binding.prop_alias ?? declarator2.id.name),
          true
        );
        const init2 = declarator2.init ? call(
          "$.value_or_fallback",
          prop2,
          /** @type {import('estree').Expression} */
          visit(declarator2.init)
        ) : prop2;
        declarations.push(declarator(declarator2.id, init2));
        continue;
      }
      declarations.push(
        ...create_state_declarators(
          declarator2,
          state.scope,
          /** @type {import('estree').Expression} */
          declarator2.init && visit(declarator2.init)
        )
      );
    }
    return {
      ...node,
      declarations
    };
  },
  LabeledStatement(node, context) {
    if (context.path.length > 1)
      return;
    if (node.label.name !== "$")
      return;
    context.state.legacy_reactive_statements.set(
      node,
      // people could do "break $" inside, so we need to keep the label
      labeled(
        "$",
        /** @type {import('estree').ExpressionStatement} */
        context.visit(node.body)
      )
    );
    return empty2;
  }
};
var template_visitors = {
  Fragment(node, context) {
    const body = create_block(node, node.nodes, context);
    return block(body);
  },
  HtmlTag(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const raw = (
      /** @type {import('estree').Expression} */
      context.visit(node.expression)
    );
    context.state.template.push(t_expression(raw));
    state.template.push(t_expression(id2));
  },
  ConstTag(node, { state, visit }) {
    const pattern = (
      /** @type {import('estree').Pattern} */
      visit(node.expression.left)
    );
    const init2 = (
      /** @type {import('estree').Expression} */
      visit(node.expression.right)
    );
    state.init.push(declaration("const", pattern, init2));
  },
  DebugTag(node, { state, visit }) {
    state.template.push(
      t_statement(
        stmt(
          call(
            "console.log",
            object(
              node.identifiers.map(
                (identifier) => prop(
                  "init",
                  identifier,
                  /** @type {import('estree').Expression} */
                  visit(identifier)
                )
              )
            )
          )
        )
      ),
      t_statement(debugger_builder)
    );
  },
  ClassDirective(node) {
    error(node, "INTERNAL", "Node should have been handled elsewhere");
  },
  StyleDirective(node) {
    error(node, "INTERNAL", "Node should have been handled elsewhere");
  },
  RegularElement(node, context) {
    const metadata = context.state.metadata;
    if (metadata.namespace !== "foreign") {
      if (metadata.namespace === void 0) {
        if (is_svg_element(node.name)) {
          metadata.namespace = "svg";
        } else {
          metadata.namespace = "html";
        }
      } else if (node.name === "foreignObject") {
        metadata.namespace = "html";
      }
    }
    context.state.template.push(t_string(`<${node.name}`));
    const body_expression = serialize_element_attributes(node, context);
    context.state.template.push(t_string(">"));
    const state = {
      ...context.state,
      preserve_whitespace: context.state.preserve_whitespace || (node.name === "pre" || node.name === "textarea") && metadata.namespace !== "foreign"
    };
    const inner_context = body_expression !== null ? {
      ...context,
      state: {
        ...state,
        template: [],
        init: []
      }
    } : { ...context, state };
    const { hoisted, trimmed } = clean_nodes(
      node,
      node.fragment.nodes,
      inner_context.path,
      inner_context.state.metadata.namespace,
      state.preserve_whitespace,
      state.analysis.preserve_comments,
      true
    );
    for (const node2 of hoisted) {
      inner_context.visit(node2, state);
    }
    process_children(trimmed, node, inner_context);
    if (body_expression !== null) {
      let body_id;
      const expression = body_expression.escape ? call("$.escape", body_expression.expression) : body_expression.expression;
      if (expression.type === "Identifier") {
        body_id = expression;
      } else {
        body_id = id(context.state.scope.generate("$$body"));
        context.state.template.push(t_statement(const_builder(body_id, expression)));
      }
      context.state.template.push(
        t_statement(
          if_builder(
            body_id,
            block(serialize_template([t_expression(body_id)])),
            block([
              ...inner_context.state.init,
              ...serialize_template(inner_context.state.template)
            ])
          )
        )
      );
    }
    if (!VoidElements.includes(node.name) && metadata.namespace !== "foreign") {
      context.state.template.push(t_string(`</${node.name}>`));
    }
  },
  SvelteElement(node, context) {
    let tag2 = (
      /** @type {import('estree').Expression} */
      context.visit(node.tag)
    );
    if (tag2.type !== "Identifier") {
      const tag_id = context.state.scope.generate("$$tag");
      context.state.init.push(const_builder(tag_id, tag2));
      tag2 = id(tag_id);
    }
    if (context.state.analysis.dev) {
      if (node.fragment.nodes.length > 0) {
        context.state.init.push(stmt(call("$.validate_void_dynamic_element", thunk(tag2))));
      }
      context.state.init.push(stmt(call("$.validate_dynamic_element_tag", thunk(tag2))));
    }
    const inner_context = {
      ...context,
      state: {
        ...context.state,
        template: [],
        init: []
      }
    };
    const [el_anchor, anchor_id] = serialize_anchor(context.state);
    context.state.init.push(el_anchor);
    context.state.template.push(t_expression(anchor_id));
    const [inner_anchor, inner_id] = serialize_anchor(context.state);
    inner_context.state.init.push(inner_anchor);
    inner_context.state.template.push(t_string("<"), t_expression(tag2));
    serialize_element_attributes(node, inner_context);
    inner_context.state.template.push(t_string(">"));
    const before = serialize_template(inner_context.state.template);
    const main = create_block(node, node.fragment.nodes, context);
    const after = serialize_template([
      t_expression(inner_id),
      t_string("</"),
      t_expression(tag2),
      t_string(">")
    ]);
    context.state.template.push(
      t_statement(
        if_builder(
          tag2,
          block([
            ...inner_context.state.init,
            ...before,
            if_builder(
              unary("!", call("$.VoidElements.has", tag2)),
              block([...serialize_template([t_expression(inner_id)]), ...main, ...after])
            )
          ])
        )
      ),
      t_expression(anchor_id)
    );
  },
  EachBlock(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const each_node_meta = node.metadata;
    const collection = (
      /** @type {import('estree').Expression} */
      context.visit(node.expression)
    );
    const item = id(each_node_meta.item_name);
    const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
    const children = node.body.nodes;
    const [each_dec, each_id] = serialize_anchor(state);
    const anchor = {
      type: "Anchor",
      id: each_id
    };
    const array_id = state.scope.root.unique("each_array");
    state.init.push(const_builder(array_id, call("$.ensure_array_like", collection)));
    const each = [const_builder(item, member(array_id, index, true))];
    if (node.context.type !== "Identifier") {
      each.push(const_builder(
        /** @type {import('estree').Pattern} */
        node.context,
        item
      ));
    }
    if (index.name !== node.index && node.index != null) {
      each.push(let_builder(node.index, index));
    }
    each.push(
      each_dec,
      .../** @type {import('estree').Statement[]} */
      create_block(node, children, context, anchor)
    );
    const for_loop = for_builder(
      let_builder(index, literal2(0)),
      binary("<", index, member(array_id, id("length"))),
      update("++", index, false),
      block(each)
    );
    if (node.fallback) {
      state.template.push(
        t_statement(
          if_builder(
            binary("!==", member(array_id, id("length")), literal2(0)),
            for_loop,
            block(create_block(node, node.fallback.nodes, context))
          )
        )
      );
    } else {
      state.template.push(t_statement(for_loop));
    }
    state.template.push(t_expression(id2));
  },
  IfBlock(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const consequent = create_block(node, node.consequent.nodes, context);
    state.template.push(
      t_statement(
        if_builder(
          /** @type {import('estree').Expression} */
          context.visit(node.test),
          block(
            /** @type {import('estree').Statement[]} */
            consequent
          ),
          node.alternate ? (
            /** @type {import('estree').BlockStatement} */
            context.visit(node.alternate)
          ) : void 0
        )
      )
    );
    state.template.push(t_expression(id2));
  },
  AwaitBlock(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    state.template.push(
      t_statement(
        stmt(
          call(
            "$.await",
            /** @type {import('estree').Expression} */
            context.visit(node.expression),
            thunk(
              node.pending ? (
                /** @type {import('estree').BlockStatement} */
                context.visit(node.pending)
              ) : block([])
            ),
            arrow(
              node.value ? [
                /** @type {import('estree').Pattern} */
                context.visit(node.value)
              ] : [],
              node.then ? (
                /** @type {import('estree').BlockStatement} */
                context.visit(node.then)
              ) : block([])
            ),
            arrow(
              node.error ? [
                /** @type {import('estree').Pattern} */
                context.visit(node.error)
              ] : [],
              node.catch ? (
                /** @type {import('estree').BlockStatement} */
                context.visit(node.catch)
              ) : block([])
            )
          )
        )
      )
    );
    state.template.push(t_expression(id2));
  },
  KeyBlock(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const body = create_block(node, node.fragment.nodes, context);
    state.template.push(t_statement(block(body)));
    state.template.push(t_expression(id2));
  },
  BindDirective(node, context) {
  },
  Component(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const call2 = serialize_inline_component(node, node.name, context);
    state.template.push(t_statement(stmt(call2)));
    state.template.push(t_expression(id2));
  },
  SvelteSelf(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const call2 = serialize_inline_component(node, context.state.analysis.name, context);
    state.template.push(t_statement(stmt(call2)));
    state.template.push(t_expression(id2));
  },
  SvelteComponent(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const call2 = serialize_inline_component(
      node,
      /** @type {import('estree').Expression} */
      context.visit(node.expression),
      context
    );
    state.template.push(t_statement(stmt(call2)));
    state.template.push(t_expression(id2));
  },
  Attribute(node, context) {
    error(node, "INTERNAL", `${node.type} should be handled in parent node`);
  },
  LetDirective(node, { state, path }) {
    const parent = path.at(-1);
    if (parent === void 0 || parent.type !== "Component" && parent.type !== "RegularElement" && parent.type !== "SvelteFragment") {
      error(node, "INTERNAL", "let directive at invalid position");
    }
    if (node.expression && node.expression.type !== "Identifier") {
      const name = state.scope.generate(node.name);
      const bindings2 = state.scope.get_bindings(node);
      for (const binding of bindings2) {
        binding.expression = member(id(name), id(binding.node.name));
      }
      return const_builder(
        name,
        call(
          thunk(
            block([
              let_builder(
                node.expression.type === "ObjectExpression" ? (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  object_pattern(node.expression.properties)
                ) : (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  array_pattern(node.expression.elements)
                ),
                member(id("$$slotProps"), id(node.name))
              ),
              return_builder(object(bindings2.map((binding) => init(binding.node.name, binding.node))))
            ])
          )
        )
      );
    } else {
      const name = node.expression === null ? node.name : node.expression.name;
      return const_builder(name, member(id("$$slotProps"), id(node.name)));
    }
  },
  SpreadAttribute(node, { visit }) {
    return visit(node.expression);
  },
  ExpressionTag(node) {
    error(node, "INTERNAL", `${node.type} should be handled in parent node`);
  },
  SvelteFragment(node, context) {
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        context.state.template.push(
          t_statement(
            /** @type {import('estree').ExpressionStatement} */
            context.visit(attribute)
          )
        );
      }
    }
    const state = {
      ...context.state,
      // TODO this logic eventually belongs in create_block, when fragments are used everywhere
      scope: (
        /** @type {import('../../scope').Scope} */
        context.state.scopes.get(node.fragment)
      )
    };
    const body = create_block(node, node.fragment.nodes, {
      ...context,
      state
    });
    context.state.template.push(t_statement(block(body)));
  },
  TitleElement(node, context) {
    const state = context.state;
    const inner_state = {
      ...state,
      init: [],
      template: []
    };
    process_children(node.fragment.nodes, node, {
      ...context,
      state: inner_state
    });
    state.init.push(stmt(assignment("=", id("$$payload.title"), literal2("<title>"))));
    inner_state.template.push(t_string("</title>"));
    state.init.push(...serialize_template(inner_state.template, id("title")));
  },
  SlotElement(node, context) {
    const state = context.state;
    const [dec, id2] = serialize_anchor(state);
    state.init.push(dec);
    state.template.push(t_expression(id2));
    const props = [];
    const spreads = [];
    let name = literal2("default");
    for (const attribute of node.attributes) {
      if (attribute.type === "SpreadAttribute") {
        spreads.push(
          /** @type {import('estree').Expression} */
          context.visit(attribute)
        );
      } else if (attribute.type === "Attribute") {
        const value = serialize_attribute_value(attribute.value, context);
        if (attribute.name === "name") {
          name = value;
        } else {
          if (attribute.metadata.dynamic) {
            props.push(get(attribute.name, [return_builder(value)]));
          } else {
            props.push(init(attribute.name, value));
          }
        }
      }
    }
    const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", array([object(props), ...spreads]));
    const fallback = node.fragment.nodes.length === 0 ? literal2(null) : thunk(block(create_block(node, node.fragment.nodes, context)));
    const slot = call(
      "$.slot",
      id("$$payload"),
      member(id("$$slots"), name, true),
      props_expression,
      fallback
    );
    state.template.push(t_statement(stmt(slot)));
    state.template.push(t_expression(id2));
  },
  SvelteHead(node, context) {
    const state = context.state;
    const body = create_block(node, node.fragment.nodes, context);
    state.template.push(
      t_statement(
        stmt(call("$.head", id("$$payload"), arrow([id("$$payload")], block(body))))
      )
    );
  }
};
function serialize_element_attributes(node, context) {
  const attributes3 = [];
  const class_directives = [];
  const style_directives = [];
  const lets = [];
  let content = null;
  let has_spread = false;
  let class_attribute_idx = -1;
  let style_attribute_idx = -1;
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "value" && node.name === "textarea") {
        if (attribute.value !== true && attribute.value[0].type === "Text" && regex_starts_with_newline.test(attribute.value[0].data)) {
          attribute.value[0].data = "\n" + attribute.value[0].data;
        }
        content = { escape: true, expression: serialize_attribute_value(attribute.value, context) };
      } else {
        if (attribute.name === "class") {
          class_attribute_idx = attributes3.length;
        } else if (attribute.name === "style") {
          style_attribute_idx = attributes3.length;
        }
        attributes3.push(attribute);
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "value" && node.name === "select")
        continue;
      if (attribute.name === "value" && attributes3.some(
        (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute2(attr) && attr.value[0].data === "file"
      )) {
        continue;
      }
      if (attribute.name === "this")
        continue;
      const binding = binding_properties[attribute.name];
      if (binding?.omit_in_ssr)
        continue;
      if (ContentEditableBindings.includes(attribute.name)) {
        content = { escape: false, expression: attribute.expression };
      } else if (attribute.name === "value" && node.name === "textarea") {
        content = { escape: true, expression: attribute.expression };
      } else if (attribute.name === "group") {
        const value_attribute = (
          /** @type {import('#compiler').Attribute | undefined} */
          node.attributes.find((attr) => attr.type === "Attribute" && attr.name === "value")
        );
        if (!value_attribute)
          continue;
        const is_checkbox = node.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute2(attr) && attr.value[0].data === "checkbox"
        );
        attributes3.push(
          create_attribute("checked", void 0, void 0, [
            {
              type: "ExpressionTag",
              parent: attribute,
              expression: is_checkbox ? call(
                member(attribute.expression, id("includes")),
                serialize_attribute_value(value_attribute.value, context)
              ) : binary(
                "===",
                attribute.expression,
                serialize_attribute_value(value_attribute.value, context)
              ),
              metadata: {
                contains_call_expression: false,
                dynamic: false
              }
            }
          ])
        );
      } else {
        attributes3.push(
          create_attribute(attribute.name, void 0, void 0, [
            {
              type: "ExpressionTag",
              parent: attribute,
              expression: attribute.expression,
              metadata: {
                contains_call_expression: false,
                dynamic: false
              }
            }
          ])
        );
      }
    } else if (attribute.type === "SpreadAttribute") {
      attributes3.push(attribute);
      has_spread = true;
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {import('estree').ExpressionStatement} */
        context.visit(attribute)
      );
    } else {
      context.visit(attribute);
    }
  }
  if (class_directives.length > 0 && !has_spread) {
    const class_attribute = serialize_class_directives(
      class_directives,
      /** @type {import('#compiler').Attribute | null} */
      attributes3[class_attribute_idx] ?? null
    );
    if (class_attribute_idx === -1) {
      attributes3.push(class_attribute);
    }
  }
  if (style_directives.length > 0 && !has_spread) {
    serialize_style_directives(
      style_directives,
      /** @type {import('#compiler').Attribute | null} */
      attributes3[style_attribute_idx] ?? null,
      context
    );
    if (style_attribute_idx > -1) {
      attributes3.splice(style_attribute_idx, 1);
    }
  }
  context.state.init.push(...lets);
  if (has_spread) {
    serialize_element_spread_attributes(attributes3, style_directives, class_directives, context);
  } else {
    for (
      const attribute of
      /** @type {import('#compiler').Attribute[]} */
      attributes3
    ) {
      if (attribute.value === true || is_text_attribute2(attribute)) {
        const name2 = attribute.name.toLowerCase();
        const literal_value = (
          /** @type {import('estree').Literal} */
          serialize_attribute_value(
            attribute.value,
            context,
            WhitespaceInsensitiveAttributes.includes(name2)
          ).value
        );
        if (name2 !== "class" || literal_value) {
          context.state.template.push(
            t_string(
              ` ${attribute.name}${DOMBooleanAttributes.includes(name2) && literal_value === true ? "" : `="${literal_value === true ? "" : String(literal_value)}"`}`
            )
          );
        }
        continue;
      }
      const name = attribute.name.toLowerCase();
      const is_boolean = DOMBooleanAttributes.includes(name);
      const value = serialize_attribute_value(
        attribute.value,
        context,
        WhitespaceInsensitiveAttributes.includes(name)
      );
      context.state.template.push(
        t_expression(call("$.attr", literal2(name), value, literal2(is_boolean)))
      );
    }
  }
  return content;
}
function serialize_class_directives(class_directives, class_attribute) {
  const expressions = class_directives.map(
    (directive) => conditional(directive.expression, literal2(directive.name), literal2(""))
  );
  if (class_attribute === null) {
    class_attribute = create_attribute("class", void 0, void 0, []);
  }
  const last = (
    /** @type {any[]} */
    class_attribute.value.at(-1)
  );
  if (last?.type === "Text") {
    last.data += " ";
    last.raw += " ";
  } else if (last) {
    class_attribute.value.push({
      type: "Text",
      parent: class_attribute,
      data: " ",
      raw: " "
    });
  }
  class_attribute.value.push({
    type: "ExpressionTag",
    parent: class_attribute,
    expression: call(
      member(
        call(member(array(expressions), id("filter")), id("Boolean")),
        id("join")
      ),
      literal2(" ")
    ),
    metadata: { contains_call_expression: false, dynamic: false }
  });
  return class_attribute;
}
function serialize_style_directives(style_directives, style_attribute, context) {
  const styles = style_directives.map((directive) => {
    let value = directive.value === true ? id(directive.name) : serialize_attribute_value(directive.value, context, true);
    if (directive.modifiers.includes("important")) {
      value = binary("+", value, literal2(" !important"));
    }
    return init(directive.name, value);
  });
  if (style_attribute === null) {
    context.state.template.push(t_expression(call("$.add_styles", object(styles))));
  } else {
    context.state.template.push(
      t_expression(
        call(
          "$.add_styles",
          call(
            "$.merge_styles",
            serialize_attribute_value(style_attribute.value, context, true),
            object(styles)
          )
        )
      )
    );
  }
}
function ssr_component(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    scopes: analysis.template.scopes,
    hoisted: [import_all("$", "svelte-experimental/server/internal")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called outside create_block");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called outside create_block");
      return a;
    },
    metadata: {
      namespace: analysis.namespace
    },
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.module.ast,
      state,
      {
        ...set_scope(analysis.module.scopes),
        ...global_visitors,
        ...javascript_visitors,
        ...analysis.runes ? javascript_visitors_runes : javascript_visitors_legacy
      }
    )
  );
  const instance = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.instance.ast,
      { ...state, scope: analysis.instance.scope },
      {
        ...set_scope(analysis.instance.scopes),
        ...global_visitors,
        ...javascript_visitors,
        ...analysis.runes ? javascript_visitors_runes : javascript_visitors_legacy,
        ImportDeclaration(node, { state: state2 }) {
          state2.hoisted.push(node);
          return { type: "EmptyStatement" };
        },
        ExportNamedDeclaration(node, { state: state2, visit }) {
          if (node.declaration) {
            return visit(node.declaration);
          }
          return empty2;
        }
      }
    )
  );
  const template2 = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.template.ast,
      { ...state, scope: analysis.template.scope },
      {
        ...set_scope(analysis.template.scopes),
        ...global_visitors,
        ...template_visitors
      }
    )
  );
  const legacy_reactive_declarations = [];
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node);
    if (statement === void 0) {
      error(node, "INTERNAL", "Could not find reactive statement");
    }
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node.body.expression.left)) {
        const binding = analysis.instance.scope.get(id2.name);
        if (binding?.kind === "legacy_reactive") {
          legacy_reactive_declarations.push(declarator(id2));
        }
      }
    }
    instance.body.push(statement[1]);
  }
  if (legacy_reactive_declarations.length > 0) {
    instance.body.unshift({
      type: "VariableDeclaration",
      kind: "let",
      declarations: legacy_reactive_declarations
    });
  }
  if (analysis.uses_component_bindings) {
    template2.body = [
      let_builder("$$settled", true_instance),
      let_builder("$$inner_payload"),
      stmt(
        function_builder(
          id("$$render_inner"),
          [id("$$payload")],
          block(
            /** @type {import('estree').Statement[]} */
            template2.body
          )
        )
      ),
      do_while(
        unary("!", id("$$settled")),
        block([
          stmt(assignment("=", id("$$settled"), true_instance)),
          stmt(
            assignment("=", id("$$inner_payload"), call("$.copy_payload", id("$$payload")))
          ),
          stmt(call("$$render_inner", id("$$inner_payload")))
        ])
      ),
      stmt(call("$.assign_payload", id("$$payload"), id("$$inner_payload")))
    ];
  }
  if ([...analysis.instance.scope.declarations.values()].some(
    (binding) => binding.kind === "store_sub"
  )) {
    instance.body.unshift(const_builder("$$store_subs", object([])));
    template2.body.push(stmt(call("$.unsubscribe_stores", id("$$store_subs"))));
  }
  const props = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "prop" && !name.startsWith("$$")) {
      props.push(init(binding.prop_alias ?? name, id(name)));
    }
  }
  for (const { name, alias } of analysis.exports) {
    props.push(init(alias ?? name, id(name)));
  }
  if (props.length > 0) {
    template2.body.push(stmt(call("$.bind_props", id("$$props"), object(props))));
  }
  const component_block = block([
    stmt(
      call(
        "$.push",
        id("$$events"),
        literal2(analysis.runes),
        ...analysis.immutable ? [true_instance] : []
      )
    ),
    .../** @type {import('estree').Statement[]} */
    instance.body,
    .../** @type {import('estree').Statement[]} */
    template2.body,
    stmt(call("$.pop"))
  ]);
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "prop")
        named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call("$.rest_props", id("$$props"), array(named_props.map((name) => literal2(name))))
      )
    );
  }
  const body = [
    ...state.hoisted,
    ...module.body,
    export_default(
      function_declaration(
        id(analysis.name),
        [id("$$payload"), id("$$props"), id("$$events"), id("$$slots")],
        component_block
      )
    )
  ];
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function ssr_module(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    hoisted: [import_all("$", "svelte-experimental/server/internal")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called");
      return a;
    },
    metadata: {
      namespace: analysis.namespace
    },
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.module.ast,
      state,
      {
        ...set_scope(analysis.module.scopes),
        ...global_visitors,
        ...javascript_visitors,
        ...analysis.runes ? javascript_visitors_runes : javascript_visitors_legacy
      }
    )
  );
  return {
    type: "Program",
    sourceType: "module",
    body: [...state.hoisted, ...module.body]
  };
}

// src/compiler/phases/3-transform/dom/utils.js
function get_assignment_value2(node, { state, visit }) {
  if (node.left.type === "Identifier") {
    const operator = node.operator;
    return operator === "=" ? (
      /** @type {import('estree').Expression} */
      visit(node.right)
    ) : (
      // turn something like x += 1 into x = x + 1
      binary(
        /** @type {import('estree').BinaryOperator} */
        operator.slice(0, -1),
        serialize_get_binding2(node.left, state),
        /** @type {import('estree').Expression} */
        visit(node.right)
      )
    );
  } else {
    return (
      /** @type {import('estree').Expression} */
      visit(node.right)
    );
  }
}
function serialize_get_binding2(node, state) {
  const binding = state.scope.get(node.name);
  if (binding === null || node === binding.node) {
    return node;
  }
  if (binding.kind === "store_sub") {
    return call(node);
  }
  if (binding.expression) {
    return binding.expression;
  }
  if (binding.kind === "prop" && binding.node.name === "$$props") {
    return call("$.unwrap", node);
  }
  if (binding.kind === "prop" && !binding.mutated && !binding.initial && !state.analysis.accessors) {
    return call(node);
  }
  if (binding.kind === "state" && binding.declaration_kind === "import") {
    return call("$$_import_" + node.name);
  }
  if (binding.kind === "state" || binding.kind === "derived" || binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "legacy_reactive") {
    return call("$.get", node);
  }
  return node;
}
function serialize_set_binding2(node, context, fallback) {
  const { state, visit } = context;
  if (node.left.type === "ArrayPattern" || node.left.type === "ObjectPattern" || node.left.type === "RestElement") {
    const tmp_id = context.state.scope.generate("tmp");
    const original_assignments = [];
    const assignments = [];
    const paths = extract_paths(node.left);
    for (const path of paths) {
      const value2 = path.expression?.(id(tmp_id));
      const assignment2 = assignment("=", path.node, value2);
      original_assignments.push(assignment2);
      assignments.push(serialize_set_binding2(assignment2, context, () => assignment2));
    }
    if (assignments.every((assignment2, i) => assignment2 === original_assignments[i])) {
      return fallback();
    }
    return call(
      thunk(
        block([
          const_builder(
            tmp_id,
            /** @type {import('estree').Expression} */
            visit(node.right)
          ),
          stmt(sequence(assignments)),
          // return because it could be used in a nested expression where the value is needed.
          // example: { foo: ({ bar } = { bar: 1 })}
          return_builder(id(tmp_id))
        ])
      )
    );
  }
  if (node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
    error(node, "INTERNAL", `Unexpected assignment type ${node.left.type}`);
  }
  let left = node.left;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (left.type !== "Identifier") {
    return fallback();
  }
  const binding = state.scope.get(left.name);
  if (!binding)
    return fallback();
  if (binding.mutation !== null) {
    return binding.mutation(node, context);
  }
  if (binding.kind === "state" && binding.declaration_kind === "import") {
    return call(
      "$$_import_" + binding.node.name,
      assignment(
        node.operator,
        /** @type {import('estree').Pattern} */
        visit(node.left),
        /** @type {import('estree').Expression} */
        visit(node.right)
      )
    );
  }
  const is_store = binding.kind === "store_sub";
  const left_name = is_store ? left.name.slice(1) : left.name;
  if (binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "each" && binding.kind !== "legacy_reactive" && !is_store) {
    return fallback();
  }
  const value = get_assignment_value2(node, { state, visit });
  const serialize = () => {
    if (left === node.left) {
      if (is_store) {
        return call("$.store_set", serialize_get_binding2(id(left_name), state), value);
      } else {
        return call("$.set", id(left_name), value);
      }
    } else {
      if (is_store) {
        return call(
          "$.mutate_store",
          serialize_get_binding2(id(left_name), state),
          assignment(
            node.operator,
            /** @type {import('estree').Pattern} */
            visit(node.left),
            value
          ),
          call("$" + left_name)
        );
      } else {
        return call(
          "$.mutate",
          id(left_name),
          assignment(
            node.operator,
            /** @type {import('estree').Pattern} */
            visit(node.left),
            value
          )
        );
      }
    }
  };
  if (value.type === "BinaryExpression" && /** @type {any} */
  value.operator === "??") {
    return logical("??", serialize_get_binding2(id(left_name), state), serialize());
  }
  return serialize();
}
var function_visitor = (node, context) => {
  const metadata = node.metadata;
  if (metadata?.hoistable) {
    const params = serialize_hoistable_params(node, context);
    return (
      /** @type {import('estree').FunctionExpression} */
      {
        ...node,
        params,
        body: context.visit(node.body)
      }
    );
  }
  context.next({ ...context.state });
};
function get_hoistable_params(node, context) {
  const scope = context.state.scope;
  const params = [];
  for (const [reference] of scope.references) {
    const binding = scope.get(reference);
    if (binding !== null && !scope.declarations.has(reference) && binding.initial !== node) {
      if (binding.kind === "store_sub") {
        params.push(id(binding.node.name.slice(1)));
        params.push(id(binding.node.name));
      } else {
        params.push(binding.node);
      }
    }
  }
  return params;
}
function serialize_hoistable_params(node, context) {
  const hoistable_params = get_hoistable_params(node, context);
  node.metadata.hoistable_params = hoistable_params;
  const params = [];
  if (node.params.length === 0) {
    if (hoistable_params.length > 0) {
      params.push(id("_"));
    }
  } else {
    for (const param of node.params) {
      params.push(
        /** @type {import('estree').Pattern} */
        context.visit(param)
      );
    }
  }
  params.push(...hoistable_params);
  return params;
}
function get_props_method(binding, state, name, default_value) {
  const args = [id("$$props"), literal2(name)];
  if (default_value) {
    if (default_value.type !== "Literal" && default_value.type !== "Identifier") {
      args.push(thunk(default_value));
      args.push(true_instance);
    } else {
      args.push(default_value);
      args.push(false_instance);
    }
  }
  return call(
    // Use $.prop_source in the following cases:
    // - accessors/mutated: needs to be able to set the prop value from within
    // - default value: we set the fallback value only initially, and it's not possible to know this timing in $.prop
    binding.mutated || binding.initial || state.analysis.accessors ? "$.prop_source" : "$.prop",
    ...args
  );
}
function create_state_declarators2(declarator2, scope, value) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, call("$.source", value))];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path) => {
      const value2 = path.expression?.(id(tmp));
      const binding = scope.get(
        /** @type {import('estree').Identifier} */
        path.node.name
      );
      return declarator(path.node, binding?.kind === "state" ? call("$.source", value2) : value2);
    })
  ];
}

// src/compiler/phases/3-transform/dom/visitors/template.js
function serialize_style_directives2(style_directives, element_id, context, is_attributes_reactive) {
  if (style_directives.length > 0) {
    const values = style_directives.map((directive) => {
      let value = directive.value === true ? serialize_get_binding2({ name: directive.name, type: "Identifier" }, context.state) : serialize_attribute_value2(directive.value, context)[1];
      return stmt(
        call(
          "$.style",
          element_id,
          literal2(directive.name),
          value,
          /** @type {import('estree').Expression} */
          directive.modifiers.includes("important") ? true_instance : void 0
        )
      );
    });
    if (is_attributes_reactive || style_directives.some((directive) => directive.metadata.dynamic)) {
      context.state.update.push(...values.map((v) => ({ grouped: v })));
    } else {
      context.state.init.push(...values);
    }
  }
}
function serialize_class_directives2(class_directives, element_id, context, is_attributes_reactive) {
  if (class_directives.length > 0) {
    const values = class_directives.map((directive) => {
      const value = (
        /** @type {import('estree').Expression} */
        context.visit(directive.expression)
      );
      return stmt(call("$.class_toggle", element_id, literal2(directive.name), value));
    });
    if (is_attributes_reactive || class_directives.some((directive) => directive.metadata.dynamic)) {
      context.state.update.push(...values.map((v) => ({ grouped: v })));
    } else {
      context.state.init.push(...values);
    }
  }
}
function add_select_to_spread_update(spread_id, node, context, node_id) {
  if (spread_id !== null && node.name === "select") {
    context.state.update.push({
      grouped: if_builder(
        binary("in", literal2("value"), id(spread_id)),
        block([
          stmt(call("$.select_option", node_id, member(id(spread_id), id("value"))))
        ])
      )
    });
  }
}
function serialize_transitive_dependencies(references, context) {
  const dependencies = /* @__PURE__ */ new Set();
  for (const ref2 of references) {
    const deps = collect_transitive_dependencies(ref2);
    for (const dep of deps) {
      dependencies.add(dep);
    }
  }
  return [...dependencies].map((dep) => serialize_get_binding2({ ...dep.node }, context.state));
}
function collect_transitive_dependencies(binding, seen = /* @__PURE__ */ new Set()) {
  if (binding.kind !== "legacy_reactive")
    return [];
  for (const dep of binding.legacy_dependencies) {
    if (!seen.has(dep)) {
      seen.add(dep);
      for (const transitive_dep of collect_transitive_dependencies(dep, seen)) {
        seen.add(transitive_dep);
      }
    }
  }
  return [...seen];
}
function setup_select_synchronization(value_binding, context) {
  let bound = value_binding.expression;
  while (bound.type === "MemberExpression") {
    bound = /** @type {import('estree').Identifier | import('estree').MemberExpression} */
    bound.object;
  }
  const names = [];
  for (const [name, refs] of context.state.scope.references) {
    if (refs.length > 0 && // prevent infinite loop
    name !== bound.name) {
      names.push(name);
    }
  }
  const to_invalidate = context.state.analysis.runes ? empty2 : stmt(
    call(
      "$.invalidate_inner_signals",
      thunk(
        block(
          names.map((name) => {
            const serialized = serialize_get_binding2(id(name), context.state);
            return stmt(serialized);
          })
        )
      )
    )
  );
  context.state.init.push(
    stmt(
      call(
        "$.pre_effect",
        thunk(
          block([
            stmt(
              /** @type {import('estree').Expression} */
              context.visit(value_binding.expression)
            ),
            to_invalidate
          ])
        )
      )
    )
  );
}
function serialize_element_spread_attributes2(attributes3, context, element_id) {
  let is_reactive = false;
  const values = [];
  for (const attribute of attributes3) {
    if (attribute.type === "Attribute") {
      const name = get_attribute_name(attribute, context.state);
      const [, value] = serialize_attribute_value2(attribute.value, context);
      values.push(object([init(name, value)]));
    } else {
      values.push(
        /** @type {import('estree').Expression} */
        context.visit(attribute)
      );
    }
    is_reactive ||= attribute.metadata.dynamic;
  }
  if (is_reactive) {
    const id2 = context.state.scope.generate("spread_attributes");
    context.state.init.push(let_builder(id2, void 0));
    context.state.update.push({
      grouped: stmt(
        assignment(
          "=",
          id(id2),
          call(
            "$.spread_attributes",
            element_id,
            id(id2),
            array(values),
            literal2(context.state.analysis.stylesheet.id)
          )
        )
      )
    });
    return id2;
  } else {
    context.state.init.push(
      stmt(
        call(
          "$.spread_attributes",
          element_id,
          literal2(null),
          array(values),
          literal2(context.state.analysis.stylesheet.id)
        )
      )
    );
    return null;
  }
}
function serialize_dynamic_element_spread_attributes(attributes3, context, element_id) {
  let is_reactive = false;
  const values = [];
  for (const attribute of attributes3) {
    if (attribute.type === "Attribute") {
      const [, value] = serialize_attribute_value2(attribute.value, context);
      values.push(object([init(attribute.name, value)]));
    } else {
      values.push(
        /** @type {import('estree').Expression} */
        context.visit(attribute)
      );
    }
    is_reactive ||= attribute.metadata.dynamic;
  }
  if (is_reactive) {
    const id2 = context.state.scope.generate("spread_attributes");
    context.state.init.push(let_builder(id2));
    context.state.update.push({
      grouped: stmt(
        assignment(
          "=",
          id(id2),
          call(
            "$.spread_dynamic_element_attributes",
            element_id,
            id(id2),
            array(values),
            literal2(context.state.analysis.stylesheet.id)
          )
        )
      )
    });
    return true;
  } else {
    context.state.init.push(
      stmt(
        call(
          "$.spread_dynamic_element_attributes",
          element_id,
          literal2(null),
          array(values),
          literal2(context.state.analysis.stylesheet.id)
        )
      )
    );
    return false;
  }
}
function serialize_element_attribute_update_assignment(node_id, attribute, context) {
  const state = context.state;
  const name = get_attribute_name(attribute, state);
  let [contains_call_expression, value] = serialize_attribute_value2(attribute.value, context);
  if (context.state.metadata.namespace === "foreign") {
    const statement = { grouped: stmt(call("$.attr", node_id, literal2(name), value)) };
    if (attribute.metadata.dynamic) {
      const id2 = state.scope.generate(`${node_id.name}_${name}`);
      serialize_update_assignment(state, id2, void 0, value, statement, contains_call_expression);
      return true;
    } else {
      state.init.push(statement.grouped);
      return false;
    }
  }
  let grouped_value = value;
  if (name === "autofocus") {
    state.init.push(stmt(call("$.auto_focus", node_id, value)));
    return false;
  }
  if (name === "class") {
    grouped_value = call("$.to_class", value);
  }
  const assign = (grouped, singular) => {
    if (name === "class") {
      if (singular) {
        return {
          singular: stmt(call("$.class_name_effect", node_id, thunk(singular))),
          grouped: stmt(call("$.class_name", node_id, singular)),
          skip_condition: true
        };
      }
      return {
        grouped: stmt(call("$.class_name", node_id, value)),
        skip_condition: true
      };
    } else if (!DOMProperties.includes(name)) {
      if (singular) {
        return {
          singular: stmt(
            call(
              name.startsWith("xlink") ? "$.xlink_attr_effect" : "$.attr_effect",
              node_id,
              literal2(name),
              thunk(singular)
            )
          ),
          grouped: stmt(
            call(
              name.startsWith("xlink") ? "$.xlink_attr" : "$.attr",
              node_id,
              literal2(name),
              grouped
            )
          )
        };
      }
      return {
        grouped: stmt(
          call(
            name.startsWith("xlink") ? "$.xlink_attr" : "$.attr",
            node_id,
            literal2(name),
            grouped
          )
        )
      };
    } else {
      return { grouped: stmt(assignment("=", member(node_id, id(name)), grouped)) };
    }
  };
  if (attribute.metadata.dynamic) {
    const id2 = state.scope.generate(`${node_id.name}_${name}`);
    serialize_update_assignment(
      state,
      id2,
      name === "class" ? literal2("") : void 0,
      grouped_value,
      assign(id(id2), value),
      contains_call_expression
    );
    return true;
  } else {
    state.init.push(assign(grouped_value).grouped);
    return false;
  }
}
function serialize_custom_element_attribute_update_assignment(node_id, attribute, context) {
  const state = context.state;
  const name = attribute.name;
  let [contains_call_expression, value] = serialize_attribute_value2(attribute.value, context);
  let grouped_value = value;
  const assign = (grouped, singular) => {
    if (singular) {
      return {
        singular: stmt(
          call("$.set_custom_element_data_effect", node_id, literal2(name), thunk(singular))
        ),
        grouped: stmt(call("$.set_custom_element_data", node_id, literal2(name), grouped))
      };
    }
    return {
      grouped: stmt(call("$.set_custom_element_data", node_id, literal2(name), grouped))
    };
  };
  if (attribute.metadata.dynamic) {
    const id2 = state.scope.generate(`${node_id.name}_${name}`);
    serialize_update_assignment(
      state,
      id2,
      void 0,
      grouped_value,
      assign(id(id2), value),
      contains_call_expression
    );
    return true;
  } else {
    state.init.push(assign(grouped_value).grouped);
    return false;
  }
}
function serialize_element_special_value_attribute(element, node_id, attribute, context) {
  const state = context.state;
  const [contains_call_expression, value] = serialize_attribute_value2(attribute.value, context);
  const inner_assignment = assignment(
    "=",
    member(node_id, id("value")),
    assignment("=", member(node_id, id("__value")), value)
  );
  const is_reactive = attribute.metadata.dynamic;
  const needs_selected_call = element === "option" && (is_reactive || collect_parent_each_blocks(context).length > 0);
  const needs_option_call = element === "select" && is_reactive;
  const assigment = stmt(
    needs_selected_call ? sequence([
      inner_assignment,
      // This ensures things stay in sync with the select binding
      // in case of updates to the option value or new values appearing
      call("$.selected", node_id)
    ]) : needs_option_call ? (
      // This ensures a one-way street to the DOM in case it's <select {value}>
      // and not <select bind:value>
      call("$.select_option", node_id, inner_assignment)
    ) : inner_assignment
  );
  if (is_reactive) {
    const id2 = state.scope.generate(`${node_id.name}_value`);
    serialize_update_assignment(
      state,
      id2,
      void 0,
      value,
      { grouped: assigment },
      contains_call_expression
    );
    return true;
  } else {
    state.init.push(assigment);
    return false;
  }
}
function serialize_update_assignment(state, id2, init2, value, assignment2, contains_call_expression) {
  const grouped = if_builder(
    binary("!==", id(id2), assignment("=", id(id2), value)),
    block([assignment2.grouped])
  );
  if (contains_call_expression && assignment2.singular) {
    state.update_effects.push(assignment2.singular);
  } else {
    if (assignment2.skip_condition) {
      if (assignment2.singular) {
        state.update.push({
          singular: assignment2.singular,
          grouped: assignment2.grouped
        });
      } else {
        state.update.push({
          init: var_builder(id2, init2),
          grouped
        });
      }
    } else {
      if (assignment2.singular) {
        state.update.push({
          init: var_builder(id2, init2),
          singular: assignment2.singular,
          grouped
        });
      } else {
        state.update.push({
          init: var_builder(id2, init2),
          grouped
        });
      }
    }
  }
}
function collect_parent_each_blocks(context) {
  return (
    /** @type {import('#compiler').EachBlock[]} */
    context.path.filter((node) => node.type === "EachBlock")
  );
}
function get_attribute_name(attribute, state) {
  let name = attribute.name;
  if (state.metadata.namespace !== "foreign") {
    name = name.toLowerCase();
    if (name !== "class" && name in AttributeAliases) {
      name = AttributeAliases[name];
    }
  }
  return name;
}
function serialize_inline_component2(node, component_name, context) {
  const props_and_spreads = [];
  const default_lets = [];
  const children = {};
  const events = {};
  const custom_css_props = [];
  let bind_this = null;
  function push_prop(prop2) {
    const current2 = props_and_spreads.at(-1);
    const current_is_props = Array.isArray(current2);
    const props = current_is_props ? current2 : [];
    props.push(prop2);
    if (!current_is_props) {
      props_and_spreads.push(props);
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      default_lets.push(
        /** @type {import('estree').ExpressionStatement} */
        context.visit(attribute)
      );
    } else if (attribute.type === "OnDirective") {
      events[attribute.name] ||= [];
      let handler = serialize_event_handler(attribute, context);
      if (attribute.modifiers.includes("once")) {
        handler = call("$.once", handler);
      }
      events[attribute.name].push(handler);
    } else if (attribute.type === "SpreadAttribute") {
      props_and_spreads.push(
        /** @type {import('estree').Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      if (attribute.name === "slot")
        continue;
      if (attribute.name.startsWith("--")) {
        custom_css_props.push(
          init(attribute.name, serialize_attribute_value2(attribute.value, context)[1])
        );
        continue;
      }
      const [, value] = serialize_attribute_value2(attribute.value, context);
      if (attribute.metadata.dynamic) {
        push_prop(get(attribute.name, [return_builder(value)]));
      } else {
        push_prop(init(attribute.name, value));
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "this") {
        bind_this = attribute.expression;
      } else {
        push_prop(
          get(attribute.name, [
            return_builder(
              call(
                "$.exposable",
                thunk(
                  /** @type {import('estree').Expression} */
                  context.visit(attribute.expression)
                )
              )
            )
          ])
        );
        const binding = attribute.expression.type !== "Identifier" ? null : context.state.scope.get(attribute.expression.name);
        if (binding === null || binding.kind !== "state" && binding.kind !== "prop" && binding.kind !== "rest_prop") {
          const assignment2 = assignment("=", attribute.expression, id("$$value"));
          push_prop(
            set(attribute.name, [
              stmt(serialize_set_binding2(assignment2, context, () => assignment2))
            ])
          );
        }
      }
    }
  }
  for (const child of node.fragment.nodes) {
    let slot_name = "default";
    if (is_element_node(child)) {
      const attribute = (
        /** @type {import('#compiler').Attribute | undefined} */
        child.attributes.find(
          (attribute2) => attribute2.type === "Attribute" && attribute2.name === "slot"
        )
      );
      if (attribute !== void 0) {
        slot_name = /** @type {import('#compiler').Text[]} */
        attribute.value[0].data;
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  const serialized_slots = [];
  for (const slot_name of Object.keys(children)) {
    const body = create_block2(node, `${node.name}_${slot_name}`, children[slot_name], context);
    if (body.length === 0)
      continue;
    const slot_name_valid_identifier = !/[^a-zA-Z0-9_$]/g.test(slot_name) && !/^[0-9]/.test(slot_name);
    const slot = prop(
      "init",
      slot_name_valid_identifier ? id(slot_name) : literal2(slot_name),
      arrow(
        [id("$$slotProps"), id("$$anchor")],
        block([...slot_name === "default" ? default_lets : [], ...body])
      ),
      !slot_name_valid_identifier
    );
    serialized_slots.push(slot);
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {import('estree').Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    thunk(array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p)))
  );
  const events_expression = object(
    Object.keys(events).map(
      (name) => prop("init", id(name), events[name].length > 1 ? array(events[name]) : events[name][0])
    )
  );
  const component_call = (node_id) => call(
    component_name,
    node_id,
    props_expression,
    events_expression,
    object(serialized_slots)
  );
  let component = component_call;
  if (bind_this !== null) {
    const assignment2 = assignment("=", bind_this, id("$$value"));
    component = (node_id) => call(
      "$.bind_this",
      component_call(node_id),
      arrow(
        [id("$$value")],
        serialize_set_binding2(assignment2, context, () => context.visit(assignment2))
      )
    );
  }
  if (Object.keys(custom_css_props).length > 0) {
    return call(
      "$.cssProps",
      context.state.node,
      // TODO would be great to do this at runtime instead. Svelte 4 also can't handle cases today
      // where it's not statically determinable whether the component is used in a svg or html context
      context.state.metadata.namespace === "svg" ? false_instance : true_instance,
      thunk(object(custom_css_props)),
      arrow([id("$$node")], component(id("$$node")))
    );
  } else {
    return component(context.state.node);
  }
}
function create_block2(parent, name, nodes, context) {
  const template_name = context.state.scope.root.unique(name);
  const body = [];
  const { hoisted, trimmed } = clean_nodes(
    parent,
    nodes,
    context.path,
    context.state.metadata.namespace,
    context.state.preserve_whitespace,
    context.state.analysis.preserve_comments,
    false
  );
  if (hoisted.length === 0 && trimmed.length === 0) {
    return [];
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === "SvelteFragment" || trimmed[0].type === "TitleElement");
  let close2 = void 0;
  let id2 = void 0;
  const state = {
    ...context.state,
    init: [],
    update: [],
    update_effects: [],
    after_update: [],
    template: [],
    metadata: {
      template_needs_import_node: false,
      namespace: context.state.metadata.namespace,
      bound_contenteditable: context.state.metadata.bound_contenteditable
    }
  };
  for (const node of hoisted) {
    context.visit(node, state);
  }
  if (is_single_element) {
    const element = (
      /** @type {import('#compiler').RegularElement} */
      trimmed[0]
    );
    id2 = id(context.state.scope.generate(element.name));
    context.visit(element, {
      ...state,
      node: id2
    });
    const callee = state.metadata.namespace === "svg" ? "$.svg_template" : "$.template";
    context.state.hoisted.push(
      const_builder(
        template_name,
        call(callee, template([quasi(state.template.join(""), true)], []))
      )
    );
    body.push(
      var_builder(
        id2.name,
        call(
          "$.open",
          id("$$anchor"),
          literal2(!state.metadata.template_needs_import_node),
          template_name
        )
      ),
      ...state.init
    );
    close2 = stmt(call("$.close", id("$$anchor"), id2));
  } else if (is_single_child_not_needing_template) {
    context.visit(trimmed[0], state);
    body.push(...state.init);
  } else {
    id2 = id(context.state.scope.generate("fragment"));
    process_children2(trimmed, call("$.child_frag", id2), {
      ...context,
      state
    });
    if (state.template.length > 0) {
      const callee = state.metadata.namespace === "svg" ? "$.svg_template" : "$.template";
      state.hoisted.push(
        var_builder(
          template_name,
          call(callee, template([quasi(state.template.join(""), true)], []), true_instance)
        )
      );
      body.push(
        var_builder(
          id2.name,
          call(
            "$.open_frag",
            id("$$anchor"),
            literal2(!state.metadata.template_needs_import_node),
            template_name
          )
        ),
        ...state.init
      );
      close2 = stmt(call("$.close_frag", id("$$anchor"), id2));
    } else {
      body.push(...state.init);
    }
  }
  if (state.update.length > 0 || state.update_effects.length > 0) {
    let update2;
    if (state.update_effects.length > 0) {
      for (const render of state.update_effects) {
        if (!update2) {
          update2 = render;
        }
        body.push(render);
      }
    }
    if (state.update.length > 0) {
      let render;
      if (state.update.length === 1 && state.update[0].singular) {
        render = state.update[0].singular;
      } else {
        render = stmt(
          call(
            "$.render_effect",
            thunk(
              block(
                state.update.map((n2) => {
                  if (n2.init) {
                    body.push(n2.init);
                  }
                  return n2.grouped;
                })
              )
            )
          )
        );
      }
      if (!update2) {
        update2 = render;
      }
      body.push(render);
    }
    update2.leadingComments = [
      {
        type: "Block",
        value: ` Update `,
        // @ts-expect-error
        has_trailing_newline: true
      }
    ];
  }
  body.push(...state.after_update);
  if (close2 !== void 0) {
    body.push(close2);
  }
  if (body[0]) {
    body[0].leadingComments = [
      {
        type: "Block",
        value: ` Init `,
        // @ts-expect-error
        has_trailing_newline: true
      }
    ];
  }
  return body;
}
function serialize_event_handler(node, { state, visit }) {
  if (node.expression) {
    let handler = node.expression;
    const dynamic_handler = () => function_builder(
      null,
      [rest(id("$$args"))],
      block([
        const_builder(
          "$$callback",
          /** @type {import('estree').Expression} */
          visit(handler)
        ),
        return_builder(
          call(member(id("$$callback"), id("apply"), false, true), this_instance, id("$$args"))
        )
      ])
    );
    if (handler.type === "Identifier" || handler.type === "MemberExpression") {
      const id2 = object2(handler);
      const binding = id2 === null ? null : state.scope.get(id2.name);
      if (binding !== null && (binding.kind === "state" || binding.kind === "legacy_reactive" || binding.kind === "derived" || binding.kind === "prop" || binding.kind === "store_sub")) {
        handler = dynamic_handler();
      } else {
        handler = /** @type {import('estree').Expression} */
        visit(handler);
      }
    } else if (handler.type === "ConditionalExpression" || handler.type === "LogicalExpression") {
      handler = dynamic_handler();
    } else {
      handler = /** @type {import('estree').Expression} */
      visit(handler);
    }
    if (node.modifiers.includes("stopPropagation")) {
      handler = call("$.stopPropagation", handler);
    }
    if (node.modifiers.includes("stopImmediatePropagation")) {
      handler = call("$.stopImmediatePropagation", handler);
    }
    if (node.modifiers.includes("preventDefault")) {
      handler = call("$.preventDefault", handler);
    }
    if (node.modifiers.includes("self")) {
      handler = call("$.self", handler);
    }
    if (node.modifiers.includes("trusted")) {
      handler = call("$.trusted", handler);
    }
    return handler;
  } else {
    return function_builder(
      null,
      [id("$$arg")],
      block([stmt(call("$.bubble_event.call", this_instance, id("$$events"), id("$$arg")))])
    );
  }
}
function process_children2(nodes, parent, { visit, state }) {
  const within_bound_contenteditable = state.metadata.bound_contenteditable;
  let sequence2 = [];
  let expression = parent;
  function flush_sequence(sequence3) {
    if (sequence3.length === 1) {
      const node = sequence3[0];
      if (node.type === "Text") {
        expression = call("$.sibling", expression);
        state.template.push(node.raw);
        return;
      }
      state.template.push(" ");
      const name2 = state.scope.generate("text");
      state.init.push(var_builder(name2, expression));
      const singular2 = stmt(
        call(
          "$.text_effect",
          id(name2),
          thunk(
            /** @type {import('estree').Expression} */
            visit(node.expression)
          )
        )
      );
      if (node.metadata.contains_call_expression && !within_bound_contenteditable) {
        state.update_effects.push(singular2);
      } else if (node.metadata.dynamic && !within_bound_contenteditable) {
        state.update.push({
          singular: singular2,
          grouped: stmt(
            call(
              "$.text",
              id(name2),
              /** @type {import('estree').Expression} */
              visit(node.expression)
            )
          )
        });
      } else {
        state.init.push(
          stmt(
            assignment(
              "=",
              id(`${name2}.nodeValue`),
              call(
                "$.stringify",
                /** @type {import('estree').Expression} */
                visit(node.expression)
              )
            )
          )
        );
      }
      return;
    }
    state.template.push(" ");
    const name = state.scope.generate("text");
    const contains_call_expression = sequence3.some(
      (n2) => n2.type === "ExpressionTag" && n2.metadata.contains_call_expression
    );
    state.init.push(var_builder(name, expression));
    const assignment2 = serialize_template_literal(sequence3, visit, state)[1];
    const init2 = stmt(assignment("=", id(`${name}.nodeValue`), assignment2));
    const singular = stmt(
      call(
        "$.text_effect",
        id(name),
        thunk(serialize_template_literal(sequence3, visit, state)[1])
      )
    );
    if (contains_call_expression && !within_bound_contenteditable) {
      state.update_effects.push(singular);
    } else if (sequence3.some((node) => node.type === "ExpressionTag" && node.metadata.dynamic) && !within_bound_contenteditable) {
      state.update.push({
        singular,
        grouped: stmt(call("$.text", id(name), assignment2))
      });
    } else {
      state.init.push(init2);
    }
    expression = call("$.sibling", id(name));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node.type === "Text" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2);
        sequence2 = [];
      }
      if (node.type === "SvelteHead" || node.type === "TitleElement") {
        visit(node, state);
      } else {
        const name = state.scope.generate(node.type === "RegularElement" ? node.name : "node");
        const id2 = id(name);
        if (node.type === "EachBlock" && nodes.length === 1 && parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "$.child") {
          node.metadata.is_controlled = true;
          visit(node, state);
        } else {
          state.init.push(var_builder(name, expression));
          expression = call("$.sibling", id2);
          visit(node, {
            ...state,
            node: id2
          });
        }
      }
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2);
  }
}
function serialize_attribute_value2(attribute_value, context) {
  let contains_call_expression = false;
  if (attribute_value === true) {
    return [contains_call_expression, literal2(true)];
  }
  if (attribute_value.length === 0) {
    return [contains_call_expression, literal2("")];
  }
  if (attribute_value.length === 1) {
    const value = attribute_value[0];
    if (value.type === "Text") {
      return [contains_call_expression, literal2(value.data)];
    } else {
      if (value.type === "ExpressionTag") {
        contains_call_expression = value.metadata.contains_call_expression;
      }
      return [
        contains_call_expression,
        /** @type {import('estree').Expression} */
        context.visit(value.expression)
      ];
    }
  }
  return serialize_template_literal(attribute_value, context.visit, context.state);
}
function serialize_template_literal(values, visit, state) {
  const quasis = [];
  const expressions = [];
  const scope = state.scope;
  let contains_call_expression = false;
  quasis.push(quasi(""));
  for (let i = 0; i < values.length; i++) {
    const node = values[i];
    if (node.type === "Text") {
      const last = (
        /** @type {import('estree').TemplateElement} */
        quasis.at(-1)
      );
      last.value.raw += node.data;
    } else {
      if (node.type === "ExpressionTag" && node.metadata.contains_call_expression) {
        contains_call_expression = true;
      }
      let expression = visit(node.expression);
      if (node.expression.type === "Identifier") {
        const name = node.expression.name;
        const binding = scope.get(name);
        if (binding !== null && binding.kind === "normal" && binding.mutated) {
          let has_already_cached = false;
          for (let node2 of state.init) {
            if (node2.type === "VariableDeclaration" && node2.declarations[0].id.type === "Identifier" && node2.declarations[0].id.name === name + "_const") {
              has_already_cached = true;
              expression = id(name + "_const");
              break;
            }
          }
          if (!has_already_cached) {
            const tmp_id = scope.generate(name + "_const");
            state.init.push(const_builder(tmp_id, expression));
            expression = id(tmp_id);
          }
        }
      }
      expressions.push(call("$.stringify", expression));
      quasis.push(quasi("", i + 1 === values.length));
    }
  }
  return [contains_call_expression, template(quasis, expressions)];
}
var template_visitors2 = {
  Fragment(node, context) {
    const body = create_block2(node, "frag", node.nodes, context);
    return block(body);
  },
  Comment(node, context) {
    context.state.template.push(`<!--${node.data}-->`);
  },
  HtmlTag(node, context) {
    context.state.template.push("<!>");
    const name = context.state.scope.generate("raw");
    const memo = context.state.scope.generate("raw_memo");
    context.state.init.push(
      const_builder(
        memo,
        call(
          "$.derived",
          thunk(
            /** @type {import('estree').Expression} */
            context.visit(node.expression)
          )
        )
      )
    );
    serialize_update_assignment(
      context.state,
      name,
      literal2(""),
      call("$.get", id(memo)),
      {
        grouped: stmt(
          call(
            "$.html",
            context.state.node,
            id(name),
            literal2(context.state.metadata.namespace === "svg")
          )
        )
      },
      false
    );
  },
  ConstTag(node, { state, visit }) {
    if (node.expression.left.type === "Identifier") {
      state.init.push(
        const_builder(
          node.expression.left,
          call(
            "$.derived",
            thunk(
              /** @type {import('estree').Expression} */
              visit(node.expression.right)
            )
          )
        )
      );
    } else {
      const identifiers = extract_identifiers(node.expression.left);
      const tmp = id(state.scope.generate("computed_const"));
      for (const node2 of identifiers) {
        const binding = (
          /** @type {import('#compiler').Binding} */
          state.scope.get(node2.name)
        );
        binding.expression = node2;
      }
      const fn = arrow(
        [],
        block([
          const_builder(
            /** @type {import('estree').Pattern} */
            visit(node.expression.left),
            /** @type {import('estree').Expression} */
            visit(node.expression.right)
          ),
          return_builder(object(identifiers.map((node2) => prop("init", node2, node2))))
        ])
      );
      state.init.push(const_builder(tmp, call("$.derived", fn)));
      for (const node2 of identifiers) {
        const binding = (
          /** @type {import('#compiler').Binding} */
          state.scope.get(node2.name)
        );
        binding.expression = member(call("$.get", tmp), node2);
      }
    }
  },
  DebugTag(node, { state, visit }) {
    state.init.push(
      stmt(
        call(
          "$.render_effect",
          thunk(
            block([
              stmt(
                call(
                  "console.log",
                  object(
                    node.identifiers.map(
                      (identifier) => prop(
                        "init",
                        identifier,
                        /** @type {import('estree').Expression} */
                        visit(identifier)
                      )
                    )
                  )
                )
              ),
              debugger_builder
            ])
          )
        )
      )
    );
  },
  AnimateDirective(node, { state, visit }) {
    const expression = node.expression === null ? literal2(null) : thunk(
      /** @type {import('estree').Expression} */
      visit(node.expression)
    );
    state.init.push(stmt(call("$.animate", state.node, id(node.name), expression)));
  },
  ClassDirective(node, { state, next: next2 }) {
    error(node, "INTERNAL", "Node should have been handled elsewhere");
  },
  StyleDirective(node, { state, next: next2 }) {
    error(node, "INTERNAL", "Node should have been handled elsewhere");
  },
  TransitionDirective(node, { state, visit }) {
    const type = node.intro && node.outro ? "$.transition" : node.intro ? "$.in" : "$.out";
    const expression = node.expression === null ? literal2(null) : thunk(
      /** @type {import('estree').Expression} */
      visit(node.expression)
    );
    state.init.push(
      stmt(
        call(
          type,
          state.node,
          id(node.name),
          expression,
          node.modifiers.includes("global") ? true_instance : false_instance
        )
      )
    );
  },
  RegularElement(node, context) {
    const parent = context.path.at(-1);
    const metadata = context.state.metadata;
    if (metadata.namespace !== "foreign") {
      if (metadata.namespace === void 0 || parent?.type === "Component") {
        if (is_svg_element(node.name)) {
          metadata.namespace = "svg";
        } else {
          metadata.namespace = "html";
        }
      } else if (node.name === "foreignObject") {
        metadata.namespace = "html";
      }
    }
    context.state.template.push(`<${node.name}`);
    const attributes3 = [];
    const class_directives = [];
    const style_directives = [];
    const lets = [];
    const is_custom_element = is_custom_element_node(node);
    let needs_input_reset = false;
    let needs_content_reset = false;
    let has_spread = false;
    let value_binding = null;
    let needs_special_value_handling = node.name === "option" || node.name === "select";
    let is_content_editable = false;
    let has_content_editable_binding = false;
    if (is_custom_element) {
      metadata.template_needs_import_node = true;
    }
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute") {
        attributes3.push(attribute);
        if ((attribute.name === "value" || attribute.name === "checked") && !is_text_attribute(attribute)) {
          needs_input_reset = true;
          needs_content_reset = true;
        } else if (attribute.name === "contenteditable" && (attribute.value === true || is_text_attribute(attribute) && attribute.value[0].data === "true")) {
          is_content_editable = true;
        }
      } else if (attribute.type === "SpreadAttribute") {
        attributes3.push(attribute);
        has_spread = true;
        needs_input_reset = true;
        needs_content_reset = true;
      } else if (attribute.type === "ClassDirective") {
        class_directives.push(attribute);
      } else if (attribute.type === "StyleDirective") {
        style_directives.push(attribute);
      } else if (attribute.type === "LetDirective") {
        lets.push(
          /** @type {import('estree').ExpressionStatement} */
          context.visit(attribute)
        );
      } else {
        if (attribute.type === "BindDirective") {
          if (attribute.name === "group" || attribute.name === "checked") {
            needs_special_value_handling = true;
            needs_input_reset = true;
          } else if (attribute.name === "value") {
            value_binding = attribute;
            needs_content_reset = true;
            needs_input_reset = true;
          } else if (attribute.name === "innerHTML" || attribute.name === "innerText" || attribute.name === "textContent") {
            has_content_editable_binding = true;
          }
        }
        context.visit(attribute);
      }
    }
    if (metadata.namespace === "foreign") {
      needs_content_reset = false;
      needs_input_reset = false;
      needs_special_value_handling = false;
      value_binding = null;
    }
    const previous_bound_contenteditable = metadata.bound_contenteditable;
    if (is_content_editable && has_content_editable_binding) {
      metadata.bound_contenteditable = true;
    }
    if (needs_input_reset && (node.name === "input" || node.name === "select")) {
      context.state.init.push(stmt(call("$.remove_input_attr_defaults", context.state.node)));
    }
    if (needs_content_reset && node.name === "textarea") {
      context.state.init.push(stmt(call("$.remove_textarea_child", context.state.node)));
    }
    if (value_binding !== null && node.name === "select") {
      setup_select_synchronization(value_binding, context);
    }
    const node_id = context.state.node;
    context.state.init.push(...lets);
    let is_attributes_reactive = false;
    if (has_spread) {
      const spread_id = serialize_element_spread_attributes2(attributes3, context, node_id);
      if (metadata.namespace !== "foreign") {
        add_select_to_spread_update(spread_id, node, context, node_id);
      }
      is_attributes_reactive = spread_id !== null;
    } else {
      for (
        const attribute of
        /** @type {import('#compiler').Attribute[]} */
        attributes3
      ) {
        if (needs_special_value_handling && attribute.name === "value") {
          serialize_element_special_value_attribute(node.name, node_id, attribute, context);
          continue;
        }
        if (attribute.name !== "autofocus" && (attribute.value === true || is_text_attribute(attribute))) {
          const name = get_attribute_name(attribute, context.state);
          const literal_value = (
            /** @type {import('estree').Literal} */
            serialize_attribute_value2(attribute.value, context)[1].value
          );
          if (name !== "class" || literal_value) {
            context.state.template.push(
              ` ${attribute.name}${DOMBooleanAttributes.includes(name) && literal_value === true ? "" : `="${literal_value === true ? "" : escape_html(String(literal_value), true)}"`}`
            );
            continue;
          }
        }
        const is = is_custom_element && metadata.namespace !== "foreign" ? serialize_custom_element_attribute_update_assignment(node_id, attribute, context) : serialize_element_attribute_update_assignment(node_id, attribute, context);
        if (is)
          is_attributes_reactive = true;
      }
    }
    serialize_class_directives2(class_directives, node_id, context, is_attributes_reactive);
    serialize_style_directives2(style_directives, node_id, context, is_attributes_reactive);
    context.state.template.push(">");
    const state = {
      ...context.state,
      scope: (
        /** @type {import('../../../scope').Scope} */
        context.state.scopes.get(node.fragment)
      ),
      preserve_whitespace: context.state.preserve_whitespace || (node.name === "pre" || node.name === "textarea") && metadata.namespace !== "foreign"
    };
    const { hoisted, trimmed } = clean_nodes(
      node,
      node.fragment.nodes,
      context.path,
      context.state.metadata.namespace,
      state.preserve_whitespace,
      state.analysis.preserve_comments,
      false
    );
    for (const node2 of hoisted) {
      context.visit(node2, state);
    }
    process_children2(
      trimmed,
      call(
        "$.child",
        node.name === "template" ? member(context.state.node, id("content")) : context.state.node
      ),
      { ...context, state }
    );
    metadata.bound_contenteditable = previous_bound_contenteditable;
    if (!VoidElements.includes(node.name)) {
      context.state.template.push(`</${node.name}>`);
    }
  },
  SvelteElement(node, context) {
    context.state.template.push(`<!>`);
    const attributes3 = [];
    const class_directives = [];
    const style_directives = [];
    const lets = [];
    let namespace = null;
    const element_id = id(context.state.scope.generate("$$element"));
    const inner_context = {
      ...context,
      state: {
        ...context.state,
        node: element_id,
        init: [],
        update: [],
        update_effects: [],
        after_update: []
      }
    };
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute") {
        attributes3.push(attribute);
        if (attribute.name === "xmlns" && is_text_attribute(attribute)) {
          namespace = attribute.value[0].data;
        }
      } else if (attribute.type === "SpreadAttribute") {
        attributes3.push(attribute);
      } else if (attribute.type === "ClassDirective") {
        class_directives.push(attribute);
      } else if (attribute.type === "StyleDirective") {
        style_directives.push(attribute);
      } else if (attribute.type === "LetDirective") {
        lets.push(
          /** @type {import('estree').ExpressionStatement} */
          context.visit(attribute)
        );
      } else {
        context.visit(attribute, inner_context.state);
      }
    }
    context.state.init.push(...lets);
    const is_attributes_reactive = serialize_dynamic_element_spread_attributes(attributes3, inner_context, element_id) !== null;
    serialize_class_directives2(class_directives, element_id, inner_context, is_attributes_reactive);
    serialize_style_directives2(style_directives, element_id, inner_context, is_attributes_reactive);
    const get_tag = thunk(
      /** @type {import('estree').Expression} */
      context.visit(node.tag)
    );
    if (context.state.analysis.dev && context.state.metadata.namespace !== "foreign") {
      if (node.fragment.nodes.length > 0) {
        context.state.init.push(stmt(call("$.validate_void_dynamic_element", get_tag)));
      }
      context.state.init.push(stmt(call("$.validate_dynamic_element_tag", get_tag)));
    }
    const inner = inner_context.state.init;
    if (inner_context.state.update.length > 0 || inner_context.state.update_effects.length > 0) {
      if (inner_context.state.update_effects.length > 0) {
        for (const render of inner_context.state.update_effects) {
          inner.push(render);
        }
      }
      if (inner_context.state.update.length > 0) {
        let render;
        if (inner_context.state.update.length === 1 && inner_context.state.update[0].singular) {
          render = inner_context.state.update[0].singular;
        } else {
          render = stmt(
            call(
              "$.render_effect",
              thunk(
                block(
                  inner_context.state.update.map((n2) => {
                    if (n2.init) {
                      inner.push(n2.init);
                    }
                    return n2.grouped;
                  })
                )
              )
            )
          );
        }
        inner.push(render);
      }
    }
    inner.push(...inner_context.state.after_update);
    inner.push(...create_block2(node, "dynamic_element", node.fragment.nodes, context));
    context.state.after_update.push(
      stmt(
        call(
          "$.element",
          context.state.node,
          get_tag,
          arrow([element_id, id("$$anchor")], block(inner)),
          namespace === "http://www.w3.org/2000/svg" ? literal2(true) : (
            /** @type {any} */
            void 0
          )
        )
      )
    );
  },
  EachBlock(node, context) {
    const each_node_meta = node.metadata;
    const collection = (
      /** @type {import('estree').Expression} */
      context.visit(node.expression)
    );
    let each_item_is_reactive = true;
    if (!each_node_meta.is_controlled) {
      context.state.template.push("<!>");
    }
    if (each_node_meta.array_name !== null) {
      context.state.init.push(const_builder(each_node_meta.array_name, thunk(collection)));
    }
    let each_type;
    if (node.key) {
      each_type = 1 << 2;
      if (node.key.type === "Identifier" && node.context.type === "Identifier" && node.context.name === node.key.name && context.state.analysis.immutable) {
        each_item_is_reactive = false;
      } else {
        each_type |= 1;
      }
      if (node.index || node.context.type !== "Identifier") {
        each_type |= 1 << 1;
      }
    } else {
      each_type = 1;
    }
    if (each_node_meta.is_controlled) {
      each_type |= 1 << 3;
    }
    const indirect_dependencies = collect_parent_each_blocks(context).flatMap((block2) => {
      const array2 = (
        /** @type {import('estree').Expression} */
        context.visit(block2.expression)
      );
      const transitive_dependencies = serialize_transitive_dependencies(
        block2.metadata.references,
        context
      );
      return [array2, ...transitive_dependencies];
    });
    if (each_node_meta.array_name) {
      indirect_dependencies.push(call(each_node_meta.array_name));
    } else {
      indirect_dependencies.push(collection);
      const transitive_dependencies = serialize_transitive_dependencies(
        each_node_meta.references,
        context
      );
      indirect_dependencies.push(...transitive_dependencies);
    }
    const create_mutation = (expression_for_id, expression_for_other) => {
      return (assignment2, { state, visit }) => {
        if (assignment2.left.type !== "Identifier" && assignment2.left.type !== "MemberExpression") {
          return serialize_set_binding2(assignment2, context, () => assignment2);
        }
        const left = object2(assignment2.left);
        const value = get_assignment_value2(assignment2, { state, visit });
        const invalidate = call(
          "$.invalidate_inner_signals",
          thunk(sequence(indirect_dependencies))
        );
        if (left === assignment2.left) {
          const assign = assignment("=", expression_for_id, value);
          return context.state.analysis.runes ? assign : sequence([assign, invalidate]);
        } else {
          const original_left = (
            /** @type {import('estree').MemberExpression} */
            assignment2.left
          );
          const left2 = member(
            expression_for_other,
            visit(original_left).property,
            original_left.computed
          );
          const assign = assignment(assignment2.operator, left2, value);
          return context.state.analysis.runes ? assign : sequence([assign, invalidate]);
        }
      };
    };
    const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
    const item = id(each_node_meta.item_name);
    const binding = (
      /** @type {import('#compiler').Binding} */
      context.state.scope.get(item.name)
    );
    binding.expression = each_item_is_reactive ? call("$.unwrap", item) : item;
    const declarations = [];
    if (node.context.type === "Identifier") {
      binding.mutation = create_mutation(
        member(
          each_node_meta.array_name ? call(each_node_meta.array_name) : collection,
          index,
          true
        ),
        binding.expression
      );
    } else {
      const unwrapped = binding.expression;
      const paths = extract_paths(node.context);
      for (const path of paths) {
        const name = (
          /** @type {import('estree').Identifier} */
          path.node.name
        );
        const binding2 = (
          /** @type {import('#compiler').Binding} */
          context.state.scope.get(name)
        );
        declarations.push(
          let_builder(
            path.node,
            thunk(
              /** @type {import('estree').Expression} */
              context.visit(path.expression?.(unwrapped))
            )
          )
        );
        if (context.state.analysis.dev) {
          declarations.push(stmt(call(name)));
        }
        binding2.expression = call(name);
        binding2.mutation = create_mutation(
          /** @type {import('estree').Pattern} */
          path.update_expression(unwrapped),
          binding2.expression
        );
      }
    }
    const children = create_block2(node, "each_block", node.body.nodes, context);
    const else_block = node.fallback ? arrow(
      [id("$$anchor")],
      /** @type {import('estree').BlockStatement} */
      context.visit(node.fallback)
    ) : literal2(null);
    const key_function = node.key && (each_type & 1) !== 0 ? arrow(
      [node.context.type === "Identifier" ? node.context : id("$$item")],
      block(
        declarations.concat(
          return_builder(
            /** @type {import('estree').Expression} */
            context.visit(node.key)
          )
        )
      )
    ) : literal2(null);
    if (context.state.analysis.dev && key_function.type !== "Literal") {
      context.state.init.push(
        stmt(call("$.validate_each_keys", thunk(collection), key_function))
      );
    }
    if (node.index && each_node_meta.contains_group_binding) {
      declarations.push(let_builder(node.index, index));
    }
    context.state.after_update.push(
      stmt(
        call(
          "$.each",
          context.state.node,
          each_node_meta.array_name ? each_node_meta.array_name : thunk(collection),
          literal2(each_type),
          key_function,
          arrow([id("$$anchor"), item, index], block(declarations.concat(children))),
          else_block
        )
      )
    );
  },
  IfBlock(node, context) {
    context.state.template.push("<!>");
    const consequent = (
      /** @type {import('estree').BlockStatement} */
      context.visit(node.consequent)
    );
    context.state.after_update.push(
      stmt(
        call(
          "$.if",
          context.state.node,
          thunk(
            /** @type {import('estree').Expression} */
            context.visit(node.test)
          ),
          arrow([id("$$anchor")], consequent),
          node.alternate ? arrow(
            [id("$$anchor")],
            /** @type {import('estree').BlockStatement} */
            context.visit(node.alternate)
          ) : literal2(null)
        )
      )
    );
  },
  AwaitBlock(node, context) {
    context.state.template.push("<!>");
    context.state.after_update.push(
      stmt(
        call(
          "$.await",
          context.state.node,
          thunk(
            /** @type {import('estree').Expression} */
            context.visit(node.expression)
          ),
          node.pending ? arrow(
            [id("$$anchor")],
            /** @type {import('estree').BlockStatement} */
            context.visit(node.pending)
          ) : literal2(null),
          node.then ? arrow(
            node.value ? [
              id("$$anchor"),
              /** @type {import('estree').Pattern} */
              context.visit(node.value)
            ] : [id("$$anchor")],
            /** @type {import('estree').BlockStatement} */
            context.visit(node.then)
          ) : literal2(null),
          node.catch ? arrow(
            node.error ? [
              id("$$anchor"),
              /** @type {import('estree').Pattern} */
              context.visit(node.error)
            ] : [id("$$anchor")],
            /** @type {import('estree').BlockStatement} */
            context.visit(node.catch)
          ) : literal2(null)
        )
      )
    );
  },
  KeyBlock(node, context) {
    context.state.template.push("<!>");
    const key2 = (
      /** @type {import('estree').Expression} */
      context.visit(node.expression)
    );
    const body = (
      /** @type {import('estree').Expression} */
      context.visit(node.fragment)
    );
    context.state.after_update.push(
      stmt(call("$.key", context.state.node, thunk(key2), arrow([id("$$anchor")], body)))
    );
  },
  FunctionExpression: function_visitor,
  ArrowFunctionExpression: function_visitor,
  OnDirective(node, context) {
    const state = context.state;
    if (node.expression) {
      let handler = serialize_event_handler(node, context);
      const event_name = node.name;
      const delegated = node.metadata.delegated;
      if (delegated !== null) {
        let delegated_assignment;
        if (!state.events.has(event_name)) {
          state.events.add(event_name);
        }
        if (delegated.type === "hoistable") {
          if (delegated.function === node.expression) {
            const func_name = context.state.scope.root.unique("on_" + event_name);
            state.hoisted.push(declaration("const", func_name, handler));
            handler = func_name;
          }
          if (node.modifiers.includes("once")) {
            handler = call("$.once", handler);
          }
          const hoistable_params = delegated.function.metadata.hoistable_params;
          const args2 = [handler, ...hoistable_params];
          delegated_assignment = array(args2);
        } else {
          if (node.modifiers.includes("once")) {
            handler = call("$.once", handler);
          }
          delegated_assignment = handler;
        }
        state.after_update.push(
          stmt(
            assignment(
              "=",
              member(context.state.node, id("__" + event_name)),
              delegated_assignment
            )
          )
        );
        return;
      }
      if (node.modifiers.includes("once")) {
        handler = call("$.once", handler);
      }
      const args = [
        literal2(event_name),
        context.state.node,
        handler,
        literal2(node.modifiers.includes("capture"))
      ];
      if (node.modifiers.includes("passive")) {
        args.push(literal2(true));
      } else if (node.modifiers.includes("nonpassive")) {
        args.push(literal2(false));
      } else if (PassiveEvents.includes(node.name)) {
        args.push(literal2(true));
      }
      state.after_update.push(stmt(call("$.event", ...args)));
    } else {
      state.after_update.push(
        stmt(
          call(
            "$.event",
            literal2(node.name),
            state.node,
            serialize_event_handler(node, context)
          )
        )
      );
    }
  },
  UseDirective(node, { state, next: next2, visit }) {
    const params = [id("$$node")];
    if (node.expression) {
      params.push(id("$$props"));
    }
    const args = [
      state.node,
      arrow(params, call(serialize_get_binding2(id(node.name), state), ...params))
    ];
    if (node.expression) {
      args.push(thunk(
        /** @type {import('estree').Expression} */
        visit(node.expression)
      ));
    }
    state.after_update.push(stmt(call("$.action", ...args)));
    next2();
  },
  BindDirective(node, context) {
    const { state, path } = context;
    const properties = [];
    let expression = node.expression;
    while (expression.type === "MemberExpression") {
      properties.unshift(
        expression.computed ? (
          /** @type {import('estree').Expression} */
          expression.property
        ) : literal2(
          /** @type {import('estree').Identifier} */
          expression.property.name
        )
      );
      expression = /** @type {import('estree').Identifier | import('estree').MemberExpression} */
      expression.object;
    }
    const getter = thunk(
      /** @type {import('estree').Expression} */
      context.visit(node.expression)
    );
    const assignment2 = assignment("=", node.expression, id("$$value"));
    const setter = arrow(
      [id("$$value")],
      serialize_set_binding2(
        assignment2,
        context,
        () => (
          /** @type {import('estree').Expression} */
          context.visit(assignment2)
        )
      )
    );
    let call_expr;
    const property = binding_properties[node.name];
    if (property && property.event) {
      call_expr = call(
        "$.bind_property",
        literal2(node.name),
        literal2(property.event),
        literal2(property.type ?? "get"),
        state.node,
        getter,
        setter
      );
    } else {
      switch (node.name) {
        case "online":
          call_expr = call(`$.bind_online`, setter);
          break;
        case "scrollX":
        case "scrollY":
          call_expr = call(
            "$.bind_window_scroll",
            literal2(node.name === "scrollX" ? "x" : "y"),
            getter,
            setter
          );
          break;
        case "innerWidth":
        case "innerHeight":
        case "outerWidth":
        case "outerHeight":
          call_expr = call("$.bind_window_size", literal2(node.name), setter);
          break;
        case "muted":
          call_expr = call(`$.bind_muted`, state.node, getter, setter);
          break;
        case "paused":
          call_expr = call(`$.bind_paused`, state.node, getter, setter);
          break;
        case "volume":
          call_expr = call(`$.bind_volume`, state.node, getter, setter);
          break;
        case "playbackRate":
          call_expr = call(`$.bind_playback_rate`, state.node, getter, setter);
          break;
        case "currentTime":
          call_expr = call(`$.bind_current_time`, state.node, getter, setter);
          break;
        case "buffered":
          call_expr = call(`$.bind_buffered`, state.node, setter);
          break;
        case "played":
          call_expr = call(`$.bind_played`, state.node, setter);
          break;
        case "seekable":
          call_expr = call(`$.bind_seekable`, state.node, setter);
          break;
        case "seeking":
          call_expr = call(`$.bind_seeking`, state.node, setter);
          break;
        case "ended":
          call_expr = call(`$.bind_ended`, state.node, setter);
          break;
        case "readyState":
          call_expr = call(`$.bind_ready_state`, state.node, setter);
          break;
        case "contentRect":
        case "contentBoxSize":
        case "borderBoxSize":
        case "devicePixelContentBoxSize":
          call_expr = call("$.bind_resize_observer", state.node, literal2(node.name), setter);
          break;
        case "clientWidth":
        case "clientHeight":
        case "offsetWidth":
        case "offsetHeight":
          call_expr = call("$.bind_element_size", state.node, literal2(node.name), setter);
          break;
        case "value": {
          const parent = path.at(-1);
          if (parent?.type === "RegularElement" && parent.name === "select") {
            call_expr = call(`$.bind_select_value`, state.node, getter, setter);
          } else {
            call_expr = call(`$.bind_value`, state.node, getter, setter);
          }
          break;
        }
        case "this":
          call_expr = call(`$.bind_this`, state.node, setter);
          break;
        case "textContent":
        case "innerHTML":
        case "innerText":
          call_expr = call(
            "$.bind_content_editable",
            literal2(node.name),
            state.node,
            getter,
            setter
          );
          break;
        case "checked":
          call_expr = call(`$.bind_checked`, state.node, getter, setter);
          break;
        case "group": {
          const indexes = [];
          for (const parent_each_block of node.metadata.parent_each_blocks.slice(0, -1)) {
            indexes.push(call("$.unwrap", parent_each_block.metadata.index));
          }
          let group_getter = getter;
          const parent = path.at(-1);
          if (parent?.type === "RegularElement") {
            const value = (
              /** @type {any[]} */
              /** @type {import('#compiler').Attribute} */
              parent.attributes.find(
                (a) => a.type === "Attribute" && a.name === "value" && !is_text_attribute(a) && a.value !== true
              )?.value
            );
            if (value !== void 0) {
              group_getter = thunk(
                block([
                  stmt(serialize_attribute_value2(value, context)[1]),
                  return_builder(
                    /** @type {import('estree').Expression} */
                    context.visit(node.expression)
                  )
                ])
              );
            }
          }
          call_expr = call(
            "$.bind_group",
            node.metadata.binding_group_name,
            array(indexes),
            state.node,
            group_getter,
            setter
          );
          break;
        }
        default:
          error(node, "INTERNAL", "unknown binding " + node.name);
      }
    }
    if (node.name === "this") {
      state.init.push(stmt(call_expr));
    } else {
      state.after_update.push(stmt(call_expr));
    }
  },
  Component(node, context) {
    context.state.template.push("<!>");
    const binding = context.state.scope.get(
      node.name.includes(".") ? node.name.slice(0, node.name.indexOf(".")) : node.name
    );
    if (binding !== null && binding.kind !== "normal") {
      const component2 = serialize_inline_component2(node, "$$component", context);
      context.state.after_update.push(
        stmt(
          call(
            "$.component",
            context.state.node,
            // TODO use untrack here to not update when binding changes?
            // Would align with Svelte 4 behavior, but it's arguably nicer/expected to update this
            thunk(
              /** @type {import('estree').Expression} */
              context.visit(member_id(node.name))
            ),
            arrow([id("$$component")], component2)
          )
        )
      );
      return;
    }
    const component = serialize_inline_component2(node, node.name, context);
    context.state.after_update.push(stmt(component));
  },
  SvelteSelf(node, context) {
    context.state.template.push("<!>");
    const component = serialize_inline_component2(node, context.state.analysis.name, context);
    context.state.after_update.push(stmt(component));
  },
  SvelteComponent(node, context) {
    context.state.template.push("<!>");
    let component = serialize_inline_component2(node, "$$component", context);
    if (context.state.analysis.dev) {
      component = call("$.validate_dynamic_component", thunk(component));
    }
    context.state.after_update.push(
      stmt(
        call(
          "$.component",
          context.state.node,
          thunk(
            /** @type {import('estree').Expression} */
            context.visit(node.expression)
          ),
          arrow([id("$$component")], component)
        )
      )
    );
  },
  Attribute(node) {
    error(node, "INTERNAL", `${node.type} should be handled in parent node`);
  },
  LetDirective(node, { state, path }) {
    const parent = path.at(-1);
    if (parent === void 0 || parent.type !== "Component" && parent.type !== "RegularElement" && parent.type !== "SvelteFragment") {
      error(node, "INTERNAL", "let directive at invalid position");
    }
    if (node.expression && node.expression.type !== "Identifier") {
      const name = state.scope.generate(node.name);
      const bindings2 = state.scope.get_bindings(node);
      for (const binding of bindings2) {
        binding.expression = member(call("$.get", id(name)), id(binding.node.name));
      }
      return const_builder(
        name,
        call(
          "$.derived",
          thunk(
            block([
              let_builder(
                /** @type {import('estree').Expression} */
                node.expression.type === "ObjectExpression" ? (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  object_pattern(node.expression.properties)
                ) : (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  array_pattern(node.expression.elements)
                ),
                member(call("$.unwrap", id("$$slotProps")), id(node.name))
              ),
              return_builder(object(bindings2.map((binding) => init(binding.node.name, binding.node))))
            ])
          )
        )
      );
    } else {
      const name = node.expression === null ? node.name : node.expression.name;
      return const_builder(
        name,
        call(
          "$.derived",
          thunk(member(call("$.unwrap", id("$$slotProps")), id(node.name)))
        )
      );
    }
  },
  SpreadAttribute(node, { visit }) {
    return visit(node.expression);
  },
  ExpressionTag(node) {
    error(node, "INTERNAL", `${node.type} should be handled in parent node`);
  },
  SvelteFragment(node, context) {
    const lets = [];
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        lets.push(
          /** @type {import('estree').ExpressionStatement} */
          context.visit(attribute)
        );
      }
    }
    const state = {
      ...context.state,
      // TODO this logic eventually belongs in create_block, when fragments are used everywhere
      scope: (
        /** @type {import('../../../scope').Scope} */
        context.state.scopes.get(node.fragment)
      )
    };
    context.state.init.push(...lets);
    context.state.init.push(
      ...create_block2(
        node,
        "slot_template",
        /** @type {import('#compiler').SvelteNode[]} */
        node.fragment.nodes,
        {
          ...context,
          state
        }
      )
    );
  },
  SlotElement(node, context) {
    context.state.template.push("<!>");
    const props = [];
    const spreads = [];
    let name = literal2("default");
    for (const attribute of node.attributes) {
      if (attribute.type === "SpreadAttribute") {
        spreads.push(
          /** @type {import('estree').Expression} */
          context.visit(attribute)
        );
      } else if (attribute.type === "Attribute") {
        const [, value] = serialize_attribute_value2(attribute.value, context);
        if (attribute.name === "name") {
          name = value;
        } else {
          if (attribute.metadata.dynamic) {
            props.push(get(attribute.name, [return_builder(value)]));
          } else {
            props.push(init(attribute.name, value));
          }
        }
      }
    }
    const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", thunk(array([object(props), ...spreads])));
    const fallback = node.fragment.nodes.length === 0 ? literal2(null) : arrow(
      [id("$$anchor")],
      block(create_block2(node, "fallback", node.fragment.nodes, context))
    );
    const slot = call(
      "$.slot",
      context.state.node,
      member(id("$$slots"), name, true),
      props_expression,
      fallback
    );
    context.state.init.push(stmt(slot));
  },
  SvelteHead(node, context) {
    context.state.init.push(
      stmt(
        call(
          "$.head",
          arrow(
            [id("$$anchor")],
            block(create_block2(node, "head", node.fragment.nodes, context))
          )
        )
      )
    );
  },
  TitleElement(node, { state, visit }) {
    if (node.fragment.nodes.length === 1 && node.fragment.nodes[0].type === "Text") {
      state.init.push(
        stmt(
          assignment(
            "=",
            member(id("$.document"), id("title")),
            literal2(
              /** @type {import('#compiler').Text} */
              node.fragment.nodes[0].data
            )
          )
        )
      );
    } else {
      state.update.push({
        grouped: stmt(
          assignment(
            "=",
            member(id("$.document"), id("title")),
            serialize_template_literal(
              /** @type {any} */
              node.fragment.nodes,
              visit,
              state
            )[1]
          )
        )
      });
    }
  },
  SvelteBody(node, { state, visit }) {
    const next_state = { ...state, node: id("$.document.body") };
    for (const attribute of node.attributes) {
      visit(attribute, next_state);
    }
  },
  SvelteWindow(node, { state, visit }) {
    const next_state = { ...state, node: id("$.window") };
    for (const attribute of node.attributes) {
      visit(attribute, next_state);
    }
  },
  SvelteDocument(node, { state, visit }) {
    const next_state = { ...state, node: id("$.document") };
    for (const attribute of node.attributes) {
      visit(attribute, next_state);
    }
  }
};

// src/compiler/phases/3-transform/dom/visitors/global.js
var global_visitors2 = {
  Identifier(node, { path, state }) {
    if (is_reference(
      node,
      /** @type {import('estree').Node} */
      path.at(-1)
    )) {
      return serialize_get_binding2(node, state);
    }
  },
  AssignmentExpression(node, context) {
    return serialize_set_binding2(node, context, context.next);
  },
  UpdateExpression(node, context) {
    const { state, next: next2, visit } = context;
    const argument = node.argument;
    if (argument.type === "Identifier") {
      const binding = state.scope.get(argument.name);
      const is_store = binding?.kind === "store_sub";
      const name = is_store ? argument.name.slice(1) : argument.name;
      if (binding?.kind === "state" || binding?.kind === "legacy_reactive" || binding?.kind === "prop" || is_store) {
        let fn = node.operator === "++" ? "$.increment" : "$.decrement";
        if (node.prefix)
          fn += "_pre";
        if (is_store) {
          fn += "_store";
          return call(fn, serialize_get_binding2(id(name), state), call("$" + name));
        } else {
          return call(fn, id(name));
        }
      } else {
        return next2();
      }
    } else {
      const assignment2 = assignment(
        node.operator === "++" ? "+=" : "-=",
        /** @type {import('estree').Pattern} */
        argument,
        literal2(1)
      );
      const serialized_assignment = serialize_set_binding2(assignment2, context, () => assignment2);
      const value = (
        /** @type {import('estree').Expression} */
        visit(argument)
      );
      if (serialized_assignment === assignment2) {
        return next2();
      } else {
        let statements;
        if (node.prefix) {
          statements = [stmt(serialized_assignment), return_builder(value)];
        } else {
          const tmp_id = state.scope.generate("$$value");
          statements = [
            const_builder(tmp_id, value),
            stmt(serialized_assignment),
            return_builder(id(tmp_id))
          ];
        }
        return call(thunk(block(statements)));
      }
    }
  },
  WhileStatement: loop_protect,
  DoWhileStatement: loop_protect,
  ForStatement: loop_protect
};

// src/compiler/phases/3-transform/dom/visitors/javascript.js
var javascript_visitors2 = {
  Program(node, { visit }) {
    return (
      /** @type {import('estree').Program} */
      {
        ...node,
        body: node.body.map((node2) => (
          /** @type {import('estree').Node} */
          visit(node2)
        ))
      }
    );
  },
  BlockStatement(node, { visit }) {
    return (
      /** @type {import('estree').BlockStatement} */
      {
        ...node,
        body: node.body.map((node2) => (
          /** @type {import('estree').Node} */
          visit(node2)
        ))
      }
    );
  },
  FunctionExpression: function_visitor,
  ArrowFunctionExpression: function_visitor,
  FunctionDeclaration(node, context) {
    const metadata = node.metadata;
    if (metadata?.hoistable) {
      const params = serialize_hoistable_params(node, context);
      context.state.hoisted.push(
        /** @type {import('estree').FunctionDeclaration} */
        {
          ...node,
          id: node.id !== null ? context.visit(node.id) : null,
          params,
          body: context.visit(node.body)
        }
      );
      return empty2;
    }
    context.next({ ...context.state });
  }
};

// src/compiler/phases/3-transform/dom/visitors/javascript-runes.js
var javascript_visitors_runes2 = {
  VariableDeclaration(node, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node.declarations) {
      const init2 = declarator2.init;
      const rune = get_rune(init2, state.scope);
      if (!rune) {
        if (init2 != null && is_hoistable_function(init2)) {
          const hoistable_function = visit(init2);
          state.hoisted.push(
            declaration(
              "const",
              declarator2.id,
              /** @type {import('estree').Expression} */
              hoistable_function
            )
          );
          continue;
        }
        declarations.push(
          /** @type {import('estree').VariableDeclarator} */
          visit(declarator2)
        );
        continue;
      }
      if (rune === "$props") {
        equal(declarator2.id.type, "ObjectPattern");
        const seen = [];
        for (const property of declarator2.id.properties) {
          if (property.type === "Property") {
            ok(property.key.type === "Identifier" || property.key.type === "Literal");
            let name;
            if (property.key.type === "Identifier") {
              name = property.key.name;
            } else if (property.key.type === "Literal") {
              name = /** @type {string} */
              property.key.value.toString();
            } else {
              throw new Error("unreachable");
            }
            seen.push(name);
            if (property.value.type === "Identifier") {
              const binding = (
                /** @type {import('#compiler').Binding} */
                state.scope.get(property.value.name)
              );
              declarations.push(
                declarator(property.value, get_props_method(binding, state, name))
              );
            } else if (property.value.type === "AssignmentPattern") {
              equal(property.value.left.type, "Identifier");
              const binding = (
                /** @type {import('#compiler').Binding} */
                state.scope.get(property.value.left.name)
              );
              declarations.push(
                declarator(
                  property.value.left,
                  get_props_method(binding, state, name, property.value.right)
                )
              );
            }
          } else {
            declarations.push(
              declarator(
                property.argument,
                call(
                  "$.rest_props",
                  id("$$props"),
                  array(seen.map((name) => literal2(name)))
                )
              )
            );
          }
        }
        continue;
      }
      const args = (
        /** @type {import('estree').CallExpression} */
        declarator2.init.arguments
      );
      const value = args.length === 0 ? id("undefined") : (
        /** @type {import('estree').Expression} */
        visit(args[0])
      );
      const opts = args[1] && /** @type {import('estree').Expression} */
      visit(args[1]);
      if (declarator2.id.type === "Identifier") {
        const callee = rune === "$state" ? "$.source" : "$.derived";
        const arg = rune === "$state" ? value : thunk(value);
        declarations.push(declarator(declarator2.id, call(callee, arg, opts)));
        continue;
      }
      if (rune === "$derived") {
        const bindings2 = state.scope.get_bindings(declarator2);
        const id2 = state.scope.generate("derived_value");
        declarations.push(
          declarator(
            id(id2),
            call(
              "$.derived",
              thunk(
                block([
                  let_builder(declarator2.id, value),
                  return_builder(array(bindings2.map((binding) => binding.node)))
                ])
              )
            )
          )
        );
        for (let i = 0; i < bindings2.length; i++) {
          bindings2[i].expression = member(call("$.get", id(id2)), literal2(i), true);
        }
        continue;
      }
      declarations.push(...create_state_declarators2(declarator2, state.scope, value));
    }
    if (declarations.length === 0) {
      return empty2;
    }
    return {
      ...node,
      declarations
    };
  },
  ExpressionStatement(node, context) {
    if (node.expression.type === "CallExpression") {
      const callee = node.expression.callee;
      if (callee.type === "Identifier" && callee.name === "$effect" && !context.state.scope.get("$effect")) {
        const func = context.visit(node.expression.arguments[0]);
        return {
          ...node,
          expression: call(
            "$.effect",
            /** @type {import('estree').Expression} */
            func
          )
        };
      }
      if (callee.type === "MemberExpression" && callee.object.type === "Identifier" && callee.object.name === "$effect" && callee.property.type === "Identifier" && callee.property.name === "pre" && !context.state.scope.get("$effect")) {
        const func = context.visit(node.expression.arguments[0]);
        return {
          ...node,
          expression: call(
            "$.pre_effect",
            /** @type {import('estree').Expression} */
            func
          )
        };
      }
    }
    context.next();
  }
};

// src/compiler/phases/3-transform/dom/visitors/javascript-legacy.js
var javascript_visitors_legacy2 = {
  VariableDeclaration(node, { state, visit }) {
    const declarations = [];
    for (const declarator2 of node.declarations) {
      const bindings2 = (
        /** @type {import('#compiler').Binding[]} */
        state.scope.get_bindings(declarator2)
      );
      const has_state = bindings2.some((binding) => binding.kind === "state");
      const has_props = bindings2.some((binding) => binding.kind === "prop");
      if (!has_state && !has_props) {
        const init2 = declarator2.init;
        if (init2 != null && is_hoistable_function(init2)) {
          const hoistable_function = visit(init2);
          state.hoisted.push(
            declaration(
              "const",
              declarator2.id,
              /** @type {import('estree').Expression} */
              hoistable_function
            )
          );
          continue;
        }
        declarations.push(
          /** @type {import('estree').VariableDeclarator} */
          visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(
              id(tmp),
              /** @type {import('estree').Expression} */
              visit(
                /** @type {import('estree').Expression} */
                declarator2.init
              )
            )
          );
          for (const path of paths) {
            const name = (
              /** @type {import('estree').Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {import('#compiler').Binding} */
              state.scope.get(name)
            );
            const value = path.expression?.(id(tmp));
            declarations.push(
              declarator(
                path.node,
                binding2.kind === "prop" || binding2.kind === "rest_prop" ? get_props_method(binding2, state, binding2.prop_alias ?? name, value) : value
              )
            );
          }
          continue;
        }
        const binding = (
          /** @type {import('#compiler').Binding} */
          state.scope.get(declarator2.id.name)
        );
        declarations.push(
          declarator(
            declarator2.id,
            get_props_method(
              binding,
              state,
              binding.prop_alias ?? declarator2.id.name,
              declarator2.init && /** @type {import('estree').Expression} */
              visit(declarator2.init)
            )
          )
        );
        continue;
      }
      declarations.push(
        ...create_state_declarators2(
          declarator2,
          state.scope,
          /** @type {import('estree').Expression} */
          declarator2.init && visit(declarator2.init)
        )
      );
    }
    if (declarations.length === 0) {
      return empty2;
    }
    return {
      ...node,
      declarations
    };
  },
  LabeledStatement(node, context) {
    if (context.path.length > 1)
      return;
    if (node.label.name !== "$")
      return;
    const state = context.state;
    const { dependencies } = (
      /** @type {import('#compiler').ReactiveStatement} */
      state.analysis.reactive_statements.get(node)
    );
    let serialized_body = (
      /** @type {import('estree').Statement} */
      context.visit(node.body)
    );
    if (serialized_body.type !== "BlockStatement") {
      serialized_body = block([serialized_body]);
    }
    const body = serialized_body.body;
    const new_body = [];
    const sequence2 = [];
    for (const binding of dependencies) {
      if (binding.kind === "normal")
        continue;
      const name = binding.node.name;
      let serialized = serialize_get_binding2(id(name), state);
      if (name === "$$props" || name === "$$restProps") {
        serialized = call("$.access_props", serialized);
      }
      sequence2.push(serialized);
    }
    if (sequence2.length > 0) {
      new_body.push(stmt(sequence(sequence2)));
    }
    new_body.push(stmt(call("$.untrack", thunk(block(body)))));
    serialized_body.body = new_body;
    state.legacy_reactive_statements.set(
      node,
      stmt(call("$.pre_effect", thunk(serialized_body)))
    );
    return empty2;
  },
  BreakStatement(node, context) {
    if (!node.label || node.label.name !== "$")
      return;
    const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
    if (in_reactive_statement) {
      return return_builder();
    }
  }
};

// src/compiler/phases/3-transform/dom/visitors/javascript-optimisations.js
var javascript_visitors_optimizations = {
  ObjectExpression(node, { state, next: next2, visit }) {
    const dynamic_get = /* @__PURE__ */ new Map();
    const dynamic_set = /* @__PURE__ */ new Map();
    const dynamic_id = /* @__PURE__ */ new Set();
    const properties = [];
    let has_spread = false;
    for (const property of node.properties) {
      if (property.type === "SpreadElement") {
        has_spread = true;
        continue;
      }
      if (property.kind !== "init" && property.key.type === "Identifier") {
        const func = (
          /** @type {import('estree').FunctionExpression} */
          property.value
        );
        const body = func.body.body;
        if (property.kind === "get" && body.length === 1 && body[0].type === "ReturnStatement" && body[0].argument != null && body[0].argument.type === "Identifier") {
          const name = body[0].argument.name;
          const binding = state.scope.get(name);
          if (binding !== null && (binding.kind === "state" || binding.kind === "derived")) {
            if (!dynamic_id.has(name)) {
              dynamic_id.add(name);
            }
            dynamic_get.set(property.key.name, name);
          } else {
            properties.push(
              /** @type {import('estree').Property} */
              visit(property)
            );
          }
        } else if (property.kind === "set" && func.params.length === 1 && func.params[0].type === "Identifier" && body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "AssignmentExpression" && body[0].expression.left.type === "Identifier" && body[0].expression.right.type === "Identifier" && body[0].expression.right.name === func.params[0].name) {
          const name = body[0].expression.left.name;
          const binding = state.scope.get(name);
          if (binding !== null && binding.kind === "state") {
            if (!dynamic_id.has(name)) {
              dynamic_id.add(name);
            }
            dynamic_set.set(property.key.name, [name, func.params[0].name]);
          } else {
            properties.push(
              /** @type {import('estree').Property} */
              visit(property)
            );
          }
        } else {
          properties.push(
            /** @type {import('estree').Property} */
            visit(property)
          );
        }
      } else {
        properties.push(
          /** @type {import('estree').Property} */
          visit(property)
        );
      }
    }
    if (!has_spread && (dynamic_get.size > 0 || dynamic_set.size > 0)) {
      const proto_id = state.scope.root.unique("object_proto");
      const hoisted_properties = [];
      for (const id2 of dynamic_id) {
        properties.push(prop("init", id("__" + id2), id(id2)));
      }
      for (const [prop_id, id2] of dynamic_get) {
        hoisted_properties.push(
          prop(
            "get",
            id(prop_id),
            function_builder(
              null,
              [],
              block([return_builder(call("$.get", member(this_instance, id("__" + id2))))])
            )
          )
        );
      }
      for (const [prop_id, [id2, param_id]] of dynamic_set) {
        hoisted_properties.push(
          prop(
            "set",
            id(prop_id),
            function_builder(
              null,
              [id(param_id)],
              block([stmt(call("$.set", member(this_instance, id("__" + id2)), id(param_id)))])
            )
          )
        );
      }
      properties.push(prop("init", id("__proto__"), proto_id));
      state.hoisted.push(var_builder(proto_id, object(hoisted_properties)));
      return object(properties);
    }
    next2();
  }
};

// src/compiler/phases/3-transform/dom/dom.js
function combine_visitors(...array2) {
  const visitors = {};
  for (const member2 of array2) {
    for (const key2 in member2) {
      if (key2 in visitors) {
        throw new Error(`Duplicate visitor: ${key2}`);
      }
      visitors[key2] = member2[key2];
    }
  }
  return visitors;
}
function dom_component(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    scopes: analysis.template.scopes,
    hoisted: [import_all("$", "svelte-experimental/internal")],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called outside create_block");
      return a;
    },
    get update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update.push should not be called outside create_block");
      return a;
    },
    get update_effects() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update_effects.push should not be called outside create_block");
      return a;
    },
    get after_update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "after_update.push should not be called outside create_block");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called outside create_block");
      return a;
    },
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      template_needs_import_node: false,
      namespace: analysis.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.module.ast,
      state,
      combine_visitors(
        set_scope(analysis.module.scopes),
        global_visitors2,
        javascript_visitors2,
        analysis.runes ? javascript_visitors_runes2 : javascript_visitors_legacy2
      )
    )
  );
  const instance_state = { ...state, scope: analysis.instance.scope };
  const instance = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.instance.ast,
      instance_state,
      combine_visitors(
        set_scope(analysis.instance.scopes),
        global_visitors2,
        javascript_visitors2,
        javascript_visitors_optimizations,
        analysis.runes ? javascript_visitors_runes2 : javascript_visitors_legacy2,
        {
          ImportDeclaration(node, { state: state2 }) {
            state2.hoisted.push(node);
            return { type: "EmptyStatement" };
          },
          ExportNamedDeclaration(node, { visit }) {
            if (node.declaration) {
              return visit(node.declaration);
            }
            return empty2;
          }
        }
      )
    )
  );
  const template2 = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.template.ast,
      { ...state, scope: analysis.instance.scope },
      combine_visitors(set_scope(analysis.template.scopes), global_visitors2, template_visitors2)
    )
  );
  if (!analysis.runes) {
    for (const [name, binding] of analysis.module.scope.declarations) {
      if (binding.kind === "state" && binding.declaration_kind === "import") {
        instance.body.unshift(
          var_builder("$$_import_" + name, call("$.reactive_import", thunk(id(name))))
        );
      }
    }
  }
  const store_setup = [];
  const legacy_reactive_declarations = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(const_builder(name, call("$.source")));
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        store_setup.push(
          const_builder("$$subscriptions", object([])),
          stmt(call("$.unsubscribe_on_destroy", id("$$subscriptions")))
        );
      }
      const store_reference = serialize_get_binding2(id(name.slice(1)), instance_state);
      const store_get = call(
        "$.store_get",
        store_reference,
        literal2(name),
        id("$$subscriptions")
      );
      store_setup.push(
        const_builder(
          binding.node,
          analysis.dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal2(name.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node);
    if (statement === void 0) {
      error(node, "INTERNAL", "Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const static_bindings = analysis.exports.map(({ name, alias }) => {
    const binding = analysis.instance.scope.get(name);
    return stmt(
      call(
        "$.bind_prop",
        id("$$props"),
        literal2(alias ?? name),
        binding?.kind === "state" ? call("$.get", id(name)) : id(name)
      )
    );
  });
  const properties = analysis.exports.map(({ name, alias }) => {
    const binding = analysis.instance.scope.get(name);
    return get(alias ?? name, [
      return_builder(binding?.kind === "state" ? call("$.get", id(name)) : id(name))
    ]);
  });
  if (analysis.accessors) {
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind !== "prop" || name.startsWith("$$"))
        continue;
      const key2 = binding.prop_alias ?? name;
      properties.push(
        get(key2, [return_builder(call("$.get", id(name)))]),
        set(key2, [stmt(call("$.set_sync", id(name), id("$$value")))])
      );
    }
  }
  const component_block = block([
    stmt(
      call(
        "$.push",
        id("$$events"),
        literal2(analysis.runes),
        ...analysis.immutable ? [literal2(true)] : []
      )
    ),
    ...store_setup,
    ...legacy_reactive_declarations,
    ...group_binding_declarations,
    .../** @type {import('estree').Statement[]} */
    instance.body,
    .../** @type {import('estree').Statement[]} */
    template2.body,
    ...static_bindings,
    ...properties.length > 0 ? [
      var_builder("$$accessors", object(properties)),
      stmt(call("$.pop", id("$$accessors"))),
      return_builder(id("$$accessors"))
    ] : [stmt(call("$.pop"))]
  ]);
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "prop")
        named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call("$.rest_props", id("$$props"), array(named_props.map((name) => literal2(name))))
      )
    );
  }
  const body = [
    ...state.hoisted,
    ...module.body,
    export_default(
      function_declaration(
        id(analysis.name),
        [id("$$anchor"), id("$$props"), id("$$events"), id("$$slots")],
        component_block
      )
    )
  ];
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name) => literal2(name)))))
    );
  }
  if (analysis.custom_element) {
    const ce = analysis.custom_element;
    const props_str = [];
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind !== "prop" || name.startsWith("$$"))
        continue;
      const key2 = binding.prop_alias ?? name;
      const prop_def = typeof ce === "boolean" ? {} : ce.props?.[key2] || {};
      if (!prop_def.type && binding.initial?.type === "Literal" && typeof binding.initial.value === "boolean") {
        prop_def.type = "Boolean";
      }
      const value = object(
        /** @type {import('estree').Property[]} */
        [
          prop_def.attribute ? init("attribute", literal2(prop_def.attribute)) : void 0,
          prop_def.reflect ? init("reflect", literal2(true)) : void 0,
          prop_def.type ? init("type", literal2(prop_def.type)) : void 0
        ].filter(Boolean)
      );
      props_str.push(init(key2, value));
    }
    const slots_str = array([...analysis.slot_names.keys()].map((name) => literal2(name)));
    const accessors_str = array(
      analysis.exports.map(({ name, alias }) => literal2(alias ?? name))
    );
    const use_shadow_dom = typeof ce === "boolean" || ce.shadow !== "none" ? true : false;
    const create_ce = call(
      "$.create_custom_element",
      id(analysis.name),
      object(props_str),
      slots_str,
      accessors_str,
      literal2(use_shadow_dom),
      /** @type {any} */
      typeof ce !== "boolean" ? ce.extend : void 0
    );
    if (typeof ce !== "boolean") {
      body.push(stmt(call("customElements.define", literal2(ce.tag), create_ce)));
    } else {
      body.push(stmt(create_ce));
    }
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function dom_module(analysis) {
  const state = {
    analysis,
    scope: analysis.module.scope,
    scopes: analysis.template.scopes,
    hoisted: [import_all("$", "svelte-experimental/internal")],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    // these should be set by create_block - if they're called outside, it's a bug
    get init() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "init.push should not be called");
      return a;
    },
    get update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update.push should not be called");
      return a;
    },
    get update_effects() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "update_effects.push should not be called outside create_block");
      return a;
    },
    get after_update() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "after_update.push should not be called");
      return a;
    },
    get template() {
      const a = [];
      a.push = () => error(null, "INTERNAL", "template.push should not be called");
      return a;
    },
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      template_needs_import_node: false,
      namespace: analysis.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: analysis.preserve_whitespace
  };
  const module = (
    /** @type {import('estree').Program} */
    walk(
      /** @type {import('#compiler').SvelteNode} */
      analysis.module.ast,
      state,
      combine_visitors(
        set_scope(analysis.module.scopes),
        global_visitors2,
        javascript_visitors2,
        analysis.runes ? javascript_visitors_runes2 : javascript_visitors_legacy2
      )
    )
  );
  return {
    type: "Program",
    sourceType: "module",
    body: [...state.hoisted, ...module.body]
  };
}

// ../../node_modules/.pnpm/locate-character@3.0.0/node_modules/locate-character/src/index.js
function rangeContains(range, index) {
  return range.start <= index && index < range.end;
}
function getLocator2(source, options = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options;
  let start = 0;
  const ranges = source.split("\n").map((line, i2) => {
    const end = start + line.length + 1;
    const range = { start, end, line: i2 };
    start = end;
    return range;
  });
  let i = 0;
  function locator(search, index) {
    if (typeof search === "string") {
      search = source.indexOf(search, index ?? 0);
    }
    if (search === -1)
      return void 0;
    let range = ranges[i];
    const d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search)) {
        return {
          line: offsetLine + range.line,
          column: offsetColumn + search - range.start,
          character: search
        };
      }
      i += d;
      range = ranges[i];
    }
  }
  return locator;
}

// src/compiler/phases/3-transform/index.js
function transform_component(analysis, source, options) {
  const program = options.generate === "ssr" ? ssr_component(analysis) : dom_component(analysis);
  const basename = (options.filename ?? "Component").split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Line",
        value: ` ${basename} (Svelte v${VERSION})`,
        // @ts-ignore
        has_trailing_newline: true
      },
      {
        type: "Line",
        value: " Note: compiler output will change before 5.0 is released!",
        // @ts-ignore
        has_trailing_newline: true
      }
    ];
  }
  return {
    js: print(program, { sourceMapSource: options.filename }),
    // TODO needs more logic to apply map from preprocess
    css: analysis.stylesheet.has_styles ? analysis.stylesheet.render(options.filename ?? "TODO", source, analysis.dev) : null,
    warnings: transform_warnings(source, analysis)
  };
}
function transform_module(analysis, source, options) {
  const program = options.generate === "ssr" ? ssr_module(analysis) : dom_module(analysis);
  const basename = (options.filename ?? "Module").split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Block",
        value: ` ${basename} generated by Svelte v${VERSION} `,
        // @ts-ignore
        has_trailing_newline: true
      }
    ];
  }
  return {
    js: print(program, {}),
    css: null,
    warnings: transform_warnings(source, analysis)
  };
}
function transform_warnings(source, analysis) {
  if (analysis.warnings.length === 0)
    return [];
  const locate = getLocator2(source, { offsetLine: 1 });
  const result = [];
  for (const warning of analysis.warnings) {
    const start = warning.position && /** @type {import('locate-character').Location} */
    locate(warning.position[0]);
    const end = warning.position && /** @type {import('locate-character').Location} */
    locate(warning.position[1]);
    result.push({
      start,
      end,
      filename: analysis.name,
      message: warning.message,
      code: warning.code
    });
  }
  return result;
}

// src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);

// src/compiler/utils/push_array.js
function push_array3(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// src/compiler/utils/mapped_code.js
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset2, source_index) {
  if (map.mappings.length == 0)
    return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset2.column;
        }
        seg[2] += offset2.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\d\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  /**
   * @type {string}
   */
  string = (
    /** @type {any} */
    void 0
  );
  /**
   * @type {import('@ampproject/remapping').DecodedSourceMap}
   */
  map = (
    /** @type {any} */
    void 0
  );
  /**
   * @param {string} string
   * @param {import('@ampproject/remapping').DecodedSourceMap | null} map
   */
  constructor(string = "", map = null) {
    this.string = string;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "")
      return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0)
      return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed)
      m1.sources = sources;
    if (names_changed)
      m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0)
            seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0)
            seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array3(
      m1.mappings[m1.mappings.length - 1],
      /** @type {import('@ampproject/remapping').SourceMapSegment[]} */
      m2.mappings.shift()
    );
    push_array3(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {import('@ampproject/remapping').DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string, map) {
    const line_count = string.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string, map);
    }
    if (string == "")
      return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++)
      map.mappings.push([]);
    return new _MappedCode(string, map);
  }
  /**
   * @static
   * @param {import('../preprocess/private.js').Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source, file_basename, get_location }) {
    let offset2 = get_location(0);
    if (!offset2)
      offset2 = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source == "")
      return new _MappedCode(source, map);
    const line_list = source.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "")
          continue;
        map.mappings[line].push([column, 0, offset2.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset2.column;
    }
    return new _MappedCode(source, map);
  }
};
function combine_sourcemaps(filename, sourcemap_list) {
  if (sourcemap_list.length == 0)
    return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file)
    delete map.file;
  if (!map.sources.length)
    map.sources = [filename];
  return map;
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = atob(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}

// src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec3 = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line = converted_mappings[0];
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec3.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset2, { file_basename, filename, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset2),
    file_basename,
    filename
  };
}
function calculate_replacements(re, get_replacement, source) {
  const replacements = [];
  source.replace(re, (...match) => {
    replacements.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset2 = match[match.length - 2];
        return { offset: offset2, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements);
}
function perform_replacements(replacements, source) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset: offset2, length, replacement } of replacements) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source.source.slice(last_end, offset2), last_end, source)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset2 + length;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source.source.slice(last_end), last_end, source)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements, location);
}

// src/compiler/preprocess/index.js
var regex_filepath_separator = /[/\\]/;
function get_file_basename(filename) {
  return (
    /** @type {string} */
    filename.split(regex_filepath_separator).pop()
  );
}
var PreprocessResult = class {
  /** @type {string} */
  source;
  /** @type {string | undefined} */
  filename;
  // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
  // so we use sourcemap_list.unshift() to add new maps
  // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
  /**
   * @default []
   * @type {Array<import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap>}
   */
  sourcemap_list = [];
  /**
   * @default []
   * @type {string[]}
   */
  dependencies = [];
  /**
   * @type {string | null  }
   */
  file_basename = (
    /** @type {any} */
    void 0
  );
  /**
   * @type {ReturnType<typeof getLocator>}
   */
  get_location = (
    /** @type {any} */
    void 0
  );
  /**
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source, filename) {
    this.source = source;
    this.filename = filename;
    this.update_source({ string: source });
    this.file_basename = filename == null ? null : get_file_basename(filename);
  }
  /**
   * @param {import('./private.js').SourceUpdate} opts
   */
  update_source({ string: source, map, dependencies }) {
    if (source != null) {
      this.source = source;
      this.get_location = getLocator2(source);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {import('./public.js').Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      // @ts-expect-error TODO there might be a bug in hiding here
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map = void 0;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map?.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source) {
  const { file_basename, get_location } = source;
  const build_mapped_code = (code, offset2) => MappedCode.from_source(slice_source(code, offset2, source));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name = match[1];
    const value = match[2] || match[3] || match[4];
    attrs[name] = !value || value;
  }
  return attrs;
}
function stringify_tag_attributes(attributes3) {
  if (!attributes3)
    return;
  let value = Object.entries(attributes3).map(([key2, value2]) => value2 === true ? key2 : `${key2}="${value2}"`).join(" ");
  if (value) {
    value = " " + value;
  }
  return value;
}
var regex_style_tags = /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi;
var regex_script_tags = /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
async function process_tag(tag_name, preprocessor, source) {
  const { filename, source: markup } = source;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes3 = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
    if (!attributes3 && !content)
      return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes3 || ""),
      markup,
      filename
    });
    if (!processed)
      return no_change();
    if (processed.dependencies)
      dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content)
      return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes3,
      stringify_tag_attributes(processed.attributes) ?? attributes3,
      slice_source(content, tag_offset, source)
    );
  }
  const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
  return { string, map, dependencies };
}
async function process_markup(process, source) {
  const processed = await process({
    content: source.source,
    filename: source.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source, preprocessor, options) {
  const filename = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source, filename);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}

// src/compiler/version.js
var VERSION = "5.0.0-preview";

// src/compiler/index.js
function compile(source, options) {
  try {
    validate_options(options);
    const parsed = parse6(source);
    const analysis = analyze_component(parsed, options);
    const result = transform_component(analysis, source, options);
    return result;
  } catch (e) {
    if (
      /** @type {any} */
      e.name === "CompileError"
    ) {
      handle_compile_error(
        /** @type {import('#compiler').CompileError} */
        e,
        options.filename,
        source
      );
    }
    throw e;
  }
}
function compileModule(source, options) {
  if (options.runes === false || !Runes.some((r) => source.includes(r))) {
    return null;
  }
  try {
    const analysis = analyze_module(parse4(source), options);
    if (analysis === null)
      return null;
    return transform_module(analysis, source, options);
  } catch (e) {
    if (
      /** @type {any} */
      e.name === "CompileError"
    ) {
      handle_compile_error(
        /** @type {import('#compiler').CompileError} */
        e,
        options.filename,
        source
      );
    }
    throw e;
  }
}
function validate_options(options) {
  if (options.namespace && !["svg", "html", "foreign"].includes(options.namespace)) {
    error(null, "invalid-compiler-option-namespace");
  }
}
function handle_compile_error(error2, filename, source) {
  error2.filename = filename;
  if (error2.position) {
    const locator = getLocator2(source, { offsetLine: 1 });
    const start = locator(error2.position[0]);
    const end = locator(error2.position[1]);
    error2.start = start;
    error2.end = end;
  }
  throw error2;
}
function _parse(source, options = {}) {
  const ast = parse6(source);
  const root = (
    /** @type {import('#compiler').SvelteNode | import('./legacy.js').LegacySvelteNode} */
    ast
  );
  if (options.modern) {
    return walk(root, null, {
      _(node, { next: next2 }) {
        delete node.parent;
        delete node.metadata;
        next2();
      }
    });
  }
  return walk(root, null, {
    _(node, { next: next2 }) {
      delete node.parent;
      delete node.metadata;
      next2();
    },
    // @ts-ignore
    Root(node, { visit }) {
      let start = null;
      let end = null;
      if (node.fragment.nodes.length > 0) {
        const first = (
          /** @type {import('#compiler').BaseNode} */
          node.fragment.nodes.at(0)
        );
        const last = (
          /** @type {import('#compiler').BaseNode} */
          node.fragment.nodes.at(-1)
        );
        start = /** @type {number} */
        first.start;
        end = /** @type {number} */
        last.end;
        while (/\s/.test(source[start]))
          start += 1;
        while (/\s/.test(source[end - 1]))
          end -= 1;
      }
      const { instance, module } = node;
      if (instance)
        delete instance.parent;
      if (module)
        delete module.parent;
      let css3 = void 0;
      if (ast.css) {
        css3 = walk(ast.css, null, {
          _(node2) {
            delete node2.parent;
          }
        });
      }
      return {
        html: {
          type: "Fragment",
          start,
          end,
          children: node.fragment.nodes.map((child) => visit(child))
        },
        instance,
        module,
        css: css3
      };
    },
    AnimateDirective(node) {
      return { ...node, type: "Animation" };
    },
    // @ts-ignore
    AwaitBlock(node, { visit }) {
      let pendingblock = {
        type: "PendingBlock",
        /** @type {number | null} */
        start: null,
        /** @type {number | null} */
        end: null,
        children: node.pending?.nodes.map((child) => visit(child)) ?? [],
        skip: true
      };
      let thenblock = {
        type: "ThenBlock",
        /** @type {number | null} */
        start: null,
        /** @type {number | null} */
        end: null,
        children: node.then?.nodes.map((child) => visit(child)) ?? [],
        skip: true
      };
      let catchblock = {
        type: "CatchBlock",
        /** @type {number | null} */
        start: null,
        /** @type {number | null} */
        end: null,
        children: node.catch?.nodes.map((child) => visit(child)) ?? [],
        skip: true
      };
      if (node.pending) {
        const first = (
          /** @type {import('#compiler').BaseNode} */
          node.pending.nodes.at(0)
        );
        const last = (
          /** @type {import('#compiler').BaseNode} */
          node.pending.nodes.at(-1)
        );
        pendingblock.start = /** @type {number} */
        first.start;
        pendingblock.end = /** @type {number} */
        last.end;
        pendingblock.skip = false;
      }
      if (node.then) {
        const first = (
          /** @type {import('#compiler').BaseNode} */
          node.then.nodes.at(0)
        );
        const last = (
          /** @type {import('#compiler').BaseNode} */
          node.then.nodes.at(-1)
        );
        thenblock.start = pendingblock.end ?? /** @type {number} */
        first.start;
        thenblock.end = /** @type {number} */
        last.end;
        thenblock.skip = false;
      }
      if (node.catch) {
        const first = (
          /** @type {import('#compiler').BaseNode} */
          node.catch.nodes.at(0)
        );
        const last = (
          /** @type {import('#compiler').BaseNode} */
          node.catch.nodes.at(-1)
        );
        catchblock.start = thenblock.end ?? pendingblock.end ?? /** @type {number} */
        first.start;
        catchblock.end = /** @type {number} */
        last.end;
        catchblock.skip = false;
      }
      return {
        type: "AwaitBlock",
        start: node.start,
        end: node.end,
        expression: node.expression,
        value: node.value,
        error: node.error,
        pending: pendingblock,
        then: thenblock,
        catch: catchblock
      };
    },
    BindDirective(node) {
      return { ...node, type: "Binding" };
    },
    ClassDirective(node) {
      return { ...node, type: "Class" };
    },
    // @ts-ignore
    Component(node, { visit }) {
      return {
        type: "InlineComponent",
        start: node.start,
        end: node.end,
        name: node.name,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    // @ts-ignore
    EachBlock(node, { visit }) {
      let elseblock = void 0;
      if (node.fallback) {
        const first = (
          /** @type {import('#compiler').BaseNode} */
          node.fallback.nodes.at(0)
        );
        const last = (
          /** @type {import('#compiler').BaseNode} */
          node.fallback.nodes.at(-1)
        );
        const start = (
          /** @type {number} */
          first.start
        );
        const end = (
          /** @type {number} */
          last.end
        );
        elseblock = {
          type: "ElseBlock",
          start,
          end,
          children: node.fallback.nodes.map((child) => visit(child))
        };
      }
      return {
        type: "EachBlock",
        start: node.start,
        end: node.end,
        children: node.body.nodes.map((child) => visit(child)),
        context: node.context,
        expression: node.expression,
        index: node.index,
        key: node.key,
        else: elseblock
      };
    },
    ExpressionTag(node, { path }) {
      const parent = path.at(-1);
      if (parent?.type === "Attribute") {
        if (source[
          /** @type {number} */
          parent.start
        ] === "{") {
          return { ...node, type: "AttributeShorthand" };
        }
      }
      return { ...node, type: "MustacheTag" };
    },
    HtmlTag(node) {
      return { ...node, type: "RawMustacheTag" };
    },
    // @ts-ignore
    IfBlock(node, { path, visit }) {
      const parent = path.at(-1);
      let elseif = void 0;
      if (parent?.type === "IfBlock" && parent.alternate?.nodes.length === 1 && node === parent.alternate.nodes[0]) {
        elseif = true;
      }
      let elseblock = void 0;
      if (node.alternate) {
        let nodes = node.alternate.nodes;
        if (nodes.length === 1 && nodes[0].type === "IfBlock") {
          nodes = nodes[0].consequent.nodes;
        }
        const first = (
          /** @type {import('#compiler').BaseNode} */
          nodes.at(0)
        );
        const last = (
          /** @type {import('#compiler').BaseNode} */
          nodes.at(-1)
        );
        const start = (
          /** @type {number} */
          first.start
        );
        const end = (
          /** @type {number} */
          last.end
        );
        elseblock = {
          type: "ElseBlock",
          start,
          end,
          children: node.alternate.nodes.map((child) => visit(child))
        };
      }
      return {
        type: "IfBlock",
        start: node.start,
        end: node.end,
        expression: node.test,
        children: node.consequent.nodes.map((child) => visit(child)),
        else: elseblock,
        elseif
      };
    },
    OnDirective(node) {
      return { ...node, type: "EventHandler" };
    },
    RegularElement(node, { visit }) {
      return {
        type: "Element",
        start: node.start,
        end: node.end,
        name: node.name,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    // @ts-ignore
    SlotElement(node, { visit }) {
      return {
        type: "Slot",
        start: node.start,
        end: node.end,
        name: node.name,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    SpreadAttribute(node) {
      return { ...node, type: "Spread" };
    },
    SvelteBody(node) {
      return { ...node, type: "Body" };
    },
    // @ts-ignore
    SvelteComponent(node, { visit }) {
      return {
        type: "InlineComponent",
        name: "svelte:component",
        start: node.start,
        end: node.end,
        expression: node.expression,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    SvelteDocument(node) {
      return { ...node, type: "Document" };
    },
    SvelteElement(node, { visit }) {
      let tag2 = node.tag;
      if (tag2.type === "Literal" && typeof tag2.value === "string") {
        tag2 = tag2.value;
      }
      return {
        type: "Element",
        name: "svelte:element",
        start: node.start,
        end: node.end,
        tag: tag2,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    SvelteFragment(node) {
      return { ...node, type: "SlotTemplate" };
    },
    SvelteHead(node, { visit }) {
      return {
        type: "Head",
        name: "svelte:head",
        start: node.start,
        end: node.end,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    SvelteOptions(node) {
      return { ...node, type: "Options" };
    },
    // @ts-ignore
    SvelteSelf(node, { visit }) {
      return {
        type: "InlineComponent",
        name: "svelte:self",
        start: node.start,
        end: node.end,
        attributes: node.attributes.map((child) => visit(child)),
        children: node.fragment.nodes.map((child) => visit(child))
      };
    },
    SvelteWindow(node) {
      return { ...node, type: "Window" };
    },
    // @ts-ignore
    Text(node, { path }) {
      const parent = path.at(-1);
      if (parent?.type === "RegularElement" && parent.name === "style") {
        return {
          type: "Text",
          start: node.start,
          end: node.end,
          data: node.data
        };
      }
    },
    TitleElement(node) {
      return { ...node, type: "Title" };
    },
    TransitionDirective(node) {
      return { ...node, type: "Transition" };
    },
    UseDirective(node) {
      return { ...node, type: "Action" };
    }
  });
}
export {
  VERSION,
  compile,
  compileModule,
  _parse as parse,
  preprocess
};
//# sourceMappingURL=compiler.js.map
